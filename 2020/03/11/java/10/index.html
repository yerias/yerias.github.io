<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA的String类源码解析"><meta name="keywords" content="Java"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>JAVA的String类源码解析 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#目录"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从源码的角度解析String不可变"><span class="toc-number">2.</span> <span class="toc-text">从源码的角度解析String不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-Pool-的角度解析String不可变"><span class="toc-number">3.</span> <span class="toc-text">String Pool 的角度解析String不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String对象不可变性的优缺点"><span class="toc-number">4.</span> <span class="toc-text">String对象不可变性的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String对象是否真的不可变"><span class="toc-number">5.</span> <span class="toc-text">String对象是否真的不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从源码的角度解析StringBuilder的可变"><span class="toc-number">6.</span> <span class="toc-text">从源码的角度解析StringBuilder的可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从源码的角度解析StringBuffer和StringBuilder的异同"><span class="toc-number">7.</span> <span class="toc-text">从源码的角度解析StringBuffer和StringBuilder的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译器对String做出了哪些优化"><span class="toc-number">8.</span> <span class="toc-text">编译器对String做出了哪些优化</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/xiaoqi.jpg"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><div class="follow-button"><a href="#">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">175</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">37</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">33</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://hadoop.apache.org/docs/r2.10.0/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">HADOOP</a><a class="author-info-links__name text-center" href="https://cwiki.apache.org/confluence/display/Hive/" target="_blank" rel="noopener">HIVE</a><a class="author-info-links__name text-center" href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">CDH</a><a class="author-info-links__name text-center" href="http://flume.apache.org/" target="_blank" rel="noopener">FLUME</a><a class="author-info-links__name text-center" href="https://azkaban.github.io/" target="_blank" rel="noopener">AZKABAN</a><a class="author-info-links__name text-center" href="https://www.maxinhong.com/" target="_blank" rel="noopener">叶梨子</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/qingyunzong" target="_blank" rel="noopener">老铁</a><a class="author-info-links__name text-center" href="https://blog.csdn.net/jim8973/" target="_blank" rel="noopener">飞哥</a><a class="author-info-links__name text-center" href="https://vinxikk.github.io/" target="_blank" rel="noopener">vinx</a><a class="author-info-links__name text-center" href="http://dongxicheng.org/" target="_blank" rel="noopener">懂西成(Hadoop技术内幕作者)</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/xing901022/" target="_blank" rel="noopener">xingoo</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/itboys/tag/" target="_blank" rel="noopener">大葱拌豆腐</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/shishanyuan" target="_blank" rel="noopener">郭景瞻(图解Spark作者)</a><a class="author-info-links__name text-center" href="https://segmentfault.com/u/wishdaren_5c243b920a3eb" target="_blank" rel="noopener">Wish大人</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/huxi2b/" target="_blank" rel="noopener">huxi_2b(kafka)</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/soroush-golpoor-1497416-unsplash.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">JAVA的String类源码解析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">5k</span><span class="post-meta__separator">|</span><span>Reading time: 17 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>源码的角度解析String不可变</li>
<li>String Pool 的角度解析String不可变</li>
<li>String对象不可变性的优缺点</li>
<li>String对象是否真的不可变</li>
<li>从源码的角度解析StringBuilder的可变</li>
<li>从源码的角度解析StringBuffer和StringBuilder的异同</li>
<li>编译器对String做出了哪些优化</li>
</ol>
<h2 id="从源码的角度解析String不可变"><a href="#从源码的角度解析String不可变" class="headerlink" title="从源码的角度解析String不可变"></a>从源码的角度解析String不可变</h2><p>所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。</p>
<p>String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"tunan"</span>;</span><br><span class="line">    System.out.println(name);	<span class="comment">//tunan</span></span><br><span class="line"></span><br><span class="line">    String name2 = upcase(name);</span><br><span class="line">    System.out.println(name2);	<span class="comment">//TUNAN</span></span><br><span class="line"></span><br><span class="line">    System.out.println(name);	<span class="comment">//tunan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当把name传给upcase()方法的时候，实际上传递的是一个引用的拷贝。而该引用所指的对象其实一直待在单一的物理位置上，从未动过。</p>
<p>回到upcase()的定义，传入其中的引用有了名字s，只有upcase()运行的时候，局部引用s才存在。一旦upcase()运行结束，s就消失了。当然了，upcase()的返回值，其实只是最终结果的引用。这足已说明，upcase()返回的引用已经指向了一个新的对象name2，而原本的name则还在原地。</p>
<p>既然String类型的变量name没有变过，我们从源码的角度去看为什么没有改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用字节数组存储字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储hash值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到String类是一个final类，但这并不是String不可变的真正原因，继续看String实现了CharSequence接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CharSequence是一个接口，它只包括length(), charAt(int index), subSequence(int start, int end)这几个API接口。同时除了String实现了CharSequence之外，StringBuffer和StringBuilder也实现了CharSequence接口。 </p>
<p>也就是说，CharSequence其实也就是定义了字符串操作的接口，其他具体的实现是由String、StringBuilder、StringBuffer完成的，String、StringBuilder、StringBuffer都可以转化为CharSequence类型。</p>
<p>继续看String类，<code>private final char value[];</code>这个final类型的字符型变量才是真正存储字符串的容器，也正是因为这个变量是final的，才真正决定了字符串不可变，也许你不相信，你可以说Stirng类也是final修饰的，也是不可变的，那么如果StringBuilder和StringBuffer也是final修饰的呢？</p>
<h2 id="String-Pool-的角度解析String不可变"><a href="#String-Pool-的角度解析String不可变" class="headerlink" title="String Pool 的角度解析String不可变"></a>String Pool 的角度解析String不可变</h2><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心，即字符串池（String Pool）。</p>
<p>我们知道，在Java中有两种创建字符串对象的方式：</p>
<ol>
<li><p>采用字面值的方式赋值 </p>
</li>
<li><p>采用new关键字新建一个字符串对象。</p>
<p>这两种方式在性能和内存占用方面存在着差别。</p>
</li>
</ol>
<p>方式一：采用字面值的方式赋值，例如：</p>
<p><img src="https://yerias.github.io/java_img/1.png" alt=""></p>
<p>采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在”aaa”这个对象，如果不存在，则在字符串池中创建”aaa”这个对象，然后将池中”aaa”这个对象的引用地址返回给字符串常量str，这样str会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。</p>
<p><img src="https://yerias.github.io/java_img/3.jpg" alt=""></p>
<p> 在本例中，执行：str == str2 ，会得到以下结果：</p>
<p><img src="https://yerias.github.io/java_img/2.png" alt=""></p>
<p>这是因为，创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str和str2指向了同一个对象，因此语句System.out.println(str == str2)输出：true。</p>
<p>方式二：采用new关键字新建一个字符串对象，例如：</p>
<p><img src="https://yerias.github.io/java_img/4.png" alt=""></p>
<p>采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象，如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象；如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。</p>
<p><img src="https://yerias.github.io/java_img/6.jpg" alt=""></p>
<p>在这个例子中，执行：str3 == str4，得到以下结果：</p>
<p><img src="https://yerias.github.io/java_img/5.png" alt=""></p>
<p>因为，采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句System.out.println(str3 == str4)输出：false。</p>
<p>字符串池的实现有一个前提条件：String对象是不可变的。因为这样可以保证多个引用可以同时指向字符串池中的同一个对象。如果字符串是可变的，那么一个引用操作改变了对象的值，对其他引用会有影响，这样显然是不合理的。</p>
<p><strong>Java语言规范（Java Language Specification）</strong>中对字符串做出了如下说明：每一个字符串常量都是指向一个字符串类实例的引用。字符串对象有一个固定值。字符串常量，或者一般的说，常量表达式中的字符串都被使用方法 String.intern进行保留来共享唯一的实例。</p>
<p>以上是Java语言规范中的原文，比较官方，用更通俗易懂的语言翻译过来主要说明了三点：</p>
<ol>
<li>每一个字符串常量都指向字符串池中或者堆内存中的一个字符串实例。</li>
<li>字符串对象值是固定的，一旦创建就不能再修改。</li>
<li>字符串常量或者常量表达式中的字符串都被方法String.intern()在字符串池中保留了唯一的实例。</li>
</ol>
<p><img src="https://yerias.github.io/java_img/7.jpg" alt=""></p>
<p>​        其他包</p>
<p>​            <img src="https://yerias.github.io/java_img/8.png" alt=""></p>
<p>​        结果</p>
<p>​                <img src="https://yerias.github.io/java_img/9.png" alt=""></p>
<p>结论：</p>
<ul>
<li>同一个包下同一个类中的字符串常量的引用指向同一个字符串对象；</li>
<li>同一个包下不同的类中的字符串常量的引用指向同一个字符串对象；</li>
<li>不同的包下不同的类中的字符串常量的引用仍然指向同一个字符串对象；</li>
<li>由常量表达式计算出的字符串是在编译时进行计算,然后被当作常量；</li>
<li>在运行时通过连接计算出的字符串是新创建的，因此是不同的；</li>
<li>通过计算生成的字符串显示调用intern方法后产生的结果与原来存在的同样内容的字符串常量是一样的。</li>
</ul>
<p>从上面的例子可以看出，字符串常量在<strong>编译时</strong>计算和在<strong>运行时</strong>计算，其执行过程是不同的，得到的结果也是不同的。我们来看看下面这段代码：</p>
<p><img src="https://yerias.github.io/java_img/10.png" alt=""></p>
<p> 代码输出如下：</p>
<p><img src="https://yerias.github.io/java_img/11.png" alt=""></p>
<p>为什么出现上面的结果呢？这是因为，字符串字面量拼接操作是在Java编译器编译期间就执行了，也就是说编译器编译时，直接把”java”、”language”和”specification”这三个字面量进行”+”操作得到一个”javalanguagespecification” 常量，并且直接将这个常量放入字符串池中，这样做实际上是一种优化，将3个字面量合成一个，避免了创建多余的字符串对象。而字符串引用的”+”运算是在Java运行期间执行的，即str + str2 + str3在程序执行期间才会进行计算，它会在堆内存中重新创建一个拼接后的字符串对象。总结来说就是：字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中；而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。</p>
<p><strong>到这里我们也能理解了什么是字符串的不可变性</strong>，其本质是在字符串池中开辟了一块空间，字符串的地址不变，字符串变量重新赋值感觉是字符串变了，其实是在字符串池中开辟了另外一块空间，并且字符串的引用重新指向新的空间地址，而原来的字符串内容和内存地址在字符串池中没有改变过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"aaa"</span>;</span><br><span class="line">name = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure>

<p><img src="https://yerias.github.io/java_img/12.jpg" alt=""></p>
<p>字符串池的位置是在堆中，那么GC的时候<strong>字符串如何保证不被GC？</strong><br>为了优化空间，运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用。这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收。</p>
<p>总结：字符串是常量，字符串池中的每个字符串对象只有唯一的一份，可以被多个引用所指向，避免了重复创建内容相同的字符串；通过字面值赋值创建的字符串对象存放在字符串池中，通过关键字new出来的字符串对象存放在堆中。</p>
<h2 id="String对象不可变性的优缺点"><a href="#String对象不可变性的优缺点" class="headerlink" title="String对象不可变性的优缺点"></a>String对象不可变性的优缺点</h2><p><strong>1.字符串常量池的需要</strong>.<br>字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。</p>
<p><strong>2. 线程安全考虑</strong>。<br>同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p>
<p><strong>3. 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载</strong>。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p>
<p><strong>4. 支持hash映射和缓存。</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>
<p>缺点：</p>
<ol>
<li>如果有对String对象值改变的需求，那么会创建大量的String对象(使用StringBuffer或者StringBuilder替代)。</li>
</ol>
<h2 id="String对象是否真的不可变"><a href="#String对象是否真的不可变" class="headerlink" title="String对象是否真的不可变"></a>String对象是否真的不可变</h2><p>String对象的不可变，其根本是内存地址的不可变，这在字符串池中有解析</p>
<p>虽然String对象将value设置为final，并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">"hello world"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> +s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取String类中的value字段(private final char value[];)</span></span><br><span class="line">Field valueFieldOfString  = String.class.getDeclaredField("value");</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString .setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] =<span class="string">'_'</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> +s);</span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br></pre></td></tr></table></figure>

<p>发现String的值已经发生了改变。也就是说，通过反射是可以修改所谓的“不可变”对象的</p>
<h2 id="从源码的角度解析StringBuilder的可变"><a href="#从源码的角度解析StringBuilder的可变" class="headerlink" title="从源码的角度解析StringBuilder的可变"></a>从源码的角度解析StringBuilder的可变</h2><p>StringBuilder可以动态构造字符串，并且是线程不安全的，我们从源码的角度解析StringBuilder为什么可以动态构造字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//默认char容量16</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//指定了则使用父类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们首先看到StringBuilder也是final修饰的， 和String一样，不仅如此StringBuffer也是final修饰的，下面将不再解释，它继承了AbstractStringBuilder，并且和String、StringBuffer一样，都实现了CharSequence接口</p>
<p>看构造方法默认容量是16，指定了容量则使用父类的构造方法，我们现在去看下父类中如何实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用字节数组存储字符串</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录存储的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空构造方法</span></span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入初始值的构造方法</span></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类的构造方法中是new了一个指定长度的char字节数组，这说明StringBuilder底层也是使用字符数组保存字符串的，需要注意的是value的定义，和String类中的实现不同，这里没有private和final修饰，正是因为这点，所以StringBuilder是可变的，StringBuilder的value字节数组可以动态的改变大小。</p>
<p>我们已经知道了StringBuilder为什么可变，还需要注意的是它的append方法，该方法直接决定了StringBuilder如何追加字符串。也是和StringBuffer唯一不同的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接重写的父类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)	<span class="comment">//检查是否空</span></span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();	<span class="comment">//获得字符串长度</span></span><br><span class="line">    ensureCapacityInternal(count + len);	<span class="comment">//检查容量/库容</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);	<span class="comment">//拷贝内容</span></span><br><span class="line">    count += len;	<span class="comment">//增加长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;	<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;	<span class="comment">//扩容为原字节数组长度的两倍+2，注意不是count</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现append方法的底层是对字符数组内容的复制，并且容量不够时，是扩容为原字节数组长度的两倍+2，是字节数组，不是容量</p>
<h2 id="从源码的角度解析StringBuffer和StringBuilder的异同"><a href="#从源码的角度解析StringBuffer和StringBuilder的异同" class="headerlink" title="从源码的角度解析StringBuffer和StringBuilder的异同"></a>从源码的角度解析StringBuffer和StringBuilder的异同</h2><p>StringBuffer和StringBuilder的所有实现一模一样，包括继承的父类，实现的接口，扩容机制，value的定义，正是这些特性让他们两很像，同时也都支持动态构造字符串。</p>
<p>我们知道StringBuffer和StringBuilder最大的不同是线程安全性的问题，StringBuffer在所有以StringBuilder为基础的代码上，在重写父类的方法的同时加了synchronized修饰，保证了线程的安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面只是节选一些StringBuffer中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(<span class="keyword">char</span>[] chars)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(String string)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(StringBuffer sb)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(CharSequence s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span>[] chars)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, String string)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="编译器对String做出了哪些优化"><a href="#编译器对String做出了哪些优化" class="headerlink" title="编译器对String做出了哪些优化"></a>编译器对String做出了哪些优化</h2><p>String的不可变性会带来一定的效率问题。为String对象重载的 “+” 操作符就是一个例子。重载的意思是，一个操作符在应用于特定的类时，被赋予了特殊的意义。</p>
<p>我们用一段代码来验证 “+” 用来拼接String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String mongo = <span class="string">"mongo"</span>;</span><br><span class="line">String s = <span class="string">"abc"</span> + mongo + <span class="string">"def"</span> +<span class="number">47</span>;</span><br><span class="line">System.out.println(s);	<span class="comment">//abcmongodef47</span></span><br></pre></td></tr></table></figure>

<p>我们猜想一下字符串s的工作方式，它可能有一个append方法，首先s的内容是abc，然后新建一个字符串的内容是abcmongo，继续新建内容是abcmongodef的字符串，最后新建abcmongodef47的字符串，也许你会说为什么不是 “abc” + mongo + “def” +47 一起生成一个字符串然后赋值给s，但是我们不要忘记字符串String，它是一个类。</p>
<p>这种设计方法可以行的通，但是为了最终生成的String，产生了一大堆的需要GC的中间对象。这样的性能是非常糟糕的。</p>
<p>那么String是如何做优化的？我们使用JDK自带的工具javap来反编译以上代码，-c表示生成JVM字节码，删除没用的部分，剩下的内容如下</p>
<p><code>javap -c StringTest</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"StringTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string</span>.<span class="title">StringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String mongo</span><br><span class="line">       <span class="number">2</span>: astore_1							<span class="comment">// store mongo</span></span><br><span class="line">       3: new           #3                  // StringBuilder</span><br><span class="line">       <span class="number">6</span>: dup								</span><br><span class="line">       7: invokespecial #4                  // StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      10: ldc           #5                  // String abc</span><br><span class="line">      12: invokevirtual #6                  // StringBuilder.append：abc</span><br><span class="line">      <span class="number">15</span>: aload_1							<span class="comment">// load mongo</span></span><br><span class="line">      16: invokevirtual #6                  // StringBuilder.append：mongo</span><br><span class="line">      19: ldc           #7                  // String def</span><br><span class="line">      21: invokevirtual #6                  // StringBuilder.append：def</span><br><span class="line">      <span class="number">24</span>: bipush        <span class="number">47</span>						</span><br><span class="line">      26: invokevirtual #8                  // StringBuilder.append：47</span><br><span class="line">      29: invokevirtual #9                  // StringBuilder.toString：abcmongodef47</span><br><span class="line">      <span class="number">32</span>: astore_2							<span class="comment">// store s = abcmongodef47</span></span><br><span class="line">      33: getstatic     #10                 // Field System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">36</span>: aload_2</span><br><span class="line">      37: invokevirtual #11                 // PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使看不懂编译语句也不重要，我们需要注意的重点是：编译器自动引入了java.lang.StringBuilder类，虽然我们在源码中并没有使用StringBuilder类，但是编译器却自动使用了它，因为它更加高效。</p>
<p>现在也许你会觉得可以随意的使用String对象，反正编译器会自动优化性能，<strong>可是我们千万要记住一点，在循环的内部拼接字符串，并不会起到优化的效果。</strong></p>
<p>下面的程序采用两种方式生成String：方法一使用多个String对象；方法二中使用了StringBuilder。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WitherStringBuilder</span> </span>&#123;</span><br><span class="line">	<span class="comment">//方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">implicit</span><span class="params">(String[] fields)</span></span>&#123;</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            result += fields[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">explicit</span><span class="params">(String[] fields)</span></span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            result.append(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行javap -c WitherStringBuilder，可以看到两个方法对应的(简化过的)字节码，首先是implicit()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">implicit</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: ldc           #2                  // String</span><br><span class="line">     <span class="number">2</span>: astore_2</span><br><span class="line">     <span class="number">3</span>: iconst_0</span><br><span class="line">     <span class="number">4</span>: istore_3</span><br><span class="line">     <span class="number">5</span>: iload_3</span><br><span class="line">     <span class="number">6</span>: aload_1</span><br><span class="line">     <span class="number">7</span>: arraylength</span><br><span class="line">     <span class="number">8</span>: if_icmpge     <span class="number">38</span></span><br><span class="line">    11: new           #3                  // StringBuilder</span><br><span class="line">    <span class="number">14</span>: dup</span><br><span class="line">    15: invokespecial #4                  // StringBuilder."&lt;init&gt;":()</span><br><span class="line">    <span class="number">18</span>: aload_2</span><br><span class="line">    19: invokevirtual #5                  // StringBuilder.append:()</span><br><span class="line">    <span class="number">22</span>: aload_1</span><br><span class="line">    <span class="number">23</span>: iload_3</span><br><span class="line">    <span class="number">24</span>: aaload</span><br><span class="line">    25: invokevirtual #5                  //StringBuilder.append:()</span><br><span class="line">    28: invokevirtual #6                  // StringBuilder.toString:()</span><br><span class="line">    <span class="number">31</span>: astore_2</span><br><span class="line">    <span class="number">32</span>: iinc          <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">35</span>: goto          <span class="number">5</span></span><br><span class="line">    <span class="number">38</span>: aload_2</span><br><span class="line">    <span class="number">39</span>: areturn</span><br></pre></td></tr></table></figure>

<p>注意从第8行到第35行构成一个循环体。</p>
<p>第8行：对堆栈中的操作数进行 “大于或等于的整数比较运算”，循环结束时跳到第38行。</p>
<p>第35行：返回循环体的起始点(第5行)。</p>
<p>要注意的重点是：StringBuilder是在循环之内构造的，这意味着每经过循环一次，就会创建一个新的StringBuilder对象。这样的操作没有任何优化可言。</p>
<p>下面是explicit()方法对应的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">explicit</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: new           #3                  // StringBuilder</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: invokespecial #4                  // StringBuilder."&lt;init&gt;":()</span><br><span class="line">     <span class="number">7</span>: astore_2</span><br><span class="line">     <span class="number">8</span>: iconst_0</span><br><span class="line">     <span class="number">9</span>: istore_3</span><br><span class="line">    <span class="number">10</span>: iload_3</span><br><span class="line">    <span class="number">11</span>: aload_1</span><br><span class="line">    <span class="number">12</span>: arraylength</span><br><span class="line">    <span class="number">13</span>: if_icmpge     <span class="number">30</span></span><br><span class="line">    <span class="number">16</span>: aload_2</span><br><span class="line">    <span class="number">17</span>: aload_1</span><br><span class="line">    <span class="number">18</span>: iload_3</span><br><span class="line">    <span class="number">19</span>: aaload</span><br><span class="line">    20: invokevirtual #5                  // StringBuilder.append:()</span><br><span class="line">    <span class="number">23</span>: pop</span><br><span class="line">    <span class="number">24</span>: iinc          <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">27</span>: goto          <span class="number">10</span></span><br><span class="line">    <span class="number">30</span>: aload_2</span><br><span class="line">    31: invokevirtual #6                  // StringBuilder.toString:()</span><br><span class="line">    <span class="number">34</span>: areturn</span><br></pre></td></tr></table></figure>

<p>可以看到，不仅循环部分的代码更加简短，而且它只生成了一个StringBuilder对象。所以遇到循环内拼接字符串时在循环体的外部定义StringBuilder()可以大大提升程序的性能。当然，如果字符串操作简单的话，那么就可以信赖编译器的优化。</p>
<p>而且显示地创建StringBuilder还允许你预先为其指定大小。如果你已经知道最终的字符串大概多长，那预先指定StringBuilder的大小还可以避免多次重新分配缓冲。</p>
<hr>
<p>参考书籍：《Java编程思想(第4版)》</p>
<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/kissazi2/p/3648671.html" target="_blank" rel="noopener">https://www.cnblogs.com/kissazi2/p/3648671.html</a></p>
<p><a href="https://www.cnblogs.com/xudong-bupt/p/3961159.html" target="_blank" rel="noopener">https://www.cnblogs.com/xudong-bupt/p/3961159.html</a></p>
<p><a href="https://www.cnblogs.com/fangfuhai/p/5500065.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangfuhai/p/5500065.html</a></p>
<p><a href="https://www.cnblogs.com/jaylon/p/5721571.html" target="_blank" rel="noopener">https://www.cnblogs.com/jaylon/p/5721571.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Tunan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yerias.github.io/2020/03/11/java/10/">http://yerias.github.io/2020/03/11/java/10/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="social-share" data-disabled="facebook,twitter,douban,linkedin,diandian"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/15/zookeeper/2/"><i class="fa fa-chevron-left">  </i><span>Curator的介绍&amp;使用</span></a></div><div class="next-post pull-right"><a href="/2020/03/10/nginx/1/"><span>Nginx的简介&amp;安装&amp;常用操作</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/soroush-golpoor-1497416-unsplash.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="footer_custom_text">大家好，我是图南，很高兴认识你们！</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>