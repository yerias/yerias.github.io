<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BigData Developer"><meta name="keywords" content="yerias,TUNANのBlog,BigData"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">129</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">TUNANのBlog</div><div id="site-sub-title">感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/26/%E7%BF%BB%E8%AF%91/2/">Introducing Window Functions in Spark SQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/">原文翻译</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/">原文翻译</a></span><div class="content"><p>原文：<a href="https://databricks.com/blog/2015/07/15/introducing-window-functions-in-spark-sql.html" target="_blank" rel="noopener">https://databricks.com/blog/2015/07/15/introducing-window-functions-in-spark-sql.html</a></p>
<hr>
<p>在这篇博客文章中，我们将介绍Apache Spark 1.4中添加的新窗口函数特性。窗口函数允许Spark SQL的用户计算结果，比如给定行的秩或输入行的范围内的移动平均值。它们显著提高了Spark的SQL和DataFrame api的表达能力。本博客将首先介绍窗口函数的概念，然后讨论如何与Spark SQL和Spark的DataFrame API一起使用它们。</p>
<h2 id="什么是窗口函数"><a href="#什么是窗口函数" class="headerlink" title="什么是窗口函数?"></a>什么是窗口函数?</h2><p>在1.4之前，Spark SQL支持两种函数，可用于计算单个返回值。内置函数或udf(如substr或round)将单个行中的值作为输入，并为每个输入行生成单个返回值。聚合函数(如SUM或MAX)对一组行进行操作，并为每个组计算单个返回值。</p>
<p>虽然这两种方法在实践中都非常有用，但是仍然有大量的操作不能单独使用这些类型的函数来表示。具体来说，无法同时对一组行进行操作，同时仍然为每个输入行返回一个值。这种限制使得执行各种数据处理任务(如计算移动平均值、计算累计和或访问当前行之前的行值)变得非常困难。幸运的是，对于Spark SQL的用户来说，窗口函数填补了这一空白。</p>
<p>在其核心，一个窗口函数根据一组行(称为Frame)为表的每个输入行计算一个返回值。每个输入行都可以有一个与之关联的唯一frame。窗口函数的这种特性使它们比其他函数更强大，并允许用户以简洁的方式表达各种数据处理任务，而这些任务如果没有窗口函数是很难(如果不是不可能)表达的。现在，让我们看两个例子。</p>
<p>假设我们有一个如下所示的productRevenue表。</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/1-1.png" alt="1-1"></p>
<p>我们想回答两个问题:</p>
<ol>
<li><p>每一类中最畅销和第二畅销的产品是什么(<strong>分组top n</strong>)?</p>
</li>
<li><p>每种产品的收入和同类产品中最畅销的产品的收入有什么不同(<strong>最大值 - 当前值</strong>)?</p>
</li>
</ol>
<p>回答第一个问题“在每个类别中，最畅销和第二畅销的产品是什么?”，我们需要根据产品的收入对其进行分类，并根据排名选择最畅销和第二畅销的产品。下面是通过使用窗口函数dense_rank来回答这个问题的SQL查询(我们将在下一节中解释使用窗口函数的语法)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  product,</span><br><span class="line">  <span class="keyword">category</span>,</span><br><span class="line">  revenue</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        product,</span><br><span class="line">        <span class="keyword">category</span>,</span><br><span class="line">        revenue,</span><br><span class="line">        <span class="keyword">dense_rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">category</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> revenue <span class="keyword">DESC</span>) <span class="keyword">as</span> <span class="keyword">rank</span></span><br><span class="line">    <span class="keyword">FROM</span> productRevenue) tmp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">rank</span> &lt;= <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这个查询的结果如下所示。如果不使用窗口函数，就很难用SQL表达查询，即使可以表达SQL查询，底层引擎也很难有效地评估查询。</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/1-2.png" alt="1-2"></p>
<p>对于第二个问题，“每种产品的收入与同类产品中最畅销的产品的收入有什么不同?”，要计算一个产品的收入差异，我们需要找到每个产品在相同类别下的最高收入价值。下面是一个用于回答这个问题的Python DataFrame程序(<strong>python代码不重要，看思路</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pyspark.sql.window <span class="keyword">import</span> Window</span><br><span class="line"><span class="keyword">import</span> pyspark.sql.functions <span class="keyword">as</span> func</span><br><span class="line">windowSpec = \</span><br><span class="line">  Window 		<span class="comment"># 定义开窗函数</span></span><br><span class="line">    .partitionBy(df[<span class="string">'category'</span>]) \   <span class="comment"># 分组</span></span><br><span class="line">    .orderBy(df[<span class="string">'revenue'</span>].desc()) \	<span class="comment"># 排序</span></span><br><span class="line">    .rangeBetween(-sys.maxsize, sys.maxsize)  <span class="comment"># 拿到最大值</span></span><br><span class="line">dataFrame = sqlContext.table(<span class="string">"productRevenue"</span>) <span class="comment"># 拿到表</span></span><br><span class="line">revenue_difference = \</span><br><span class="line">  (func.max(dataFrame[<span class="string">'revenue'</span>]).over(windowSpec) - dataFrame[<span class="string">'revenue'</span>]) <span class="comment"># 使用开窗函数</span></span><br><span class="line">dataFrame.select(     <span class="comment"># 查询</span></span><br><span class="line">  dataFrame[<span class="string">'product'</span>],</span><br><span class="line">  dataFrame[<span class="string">'category'</span>],</span><br><span class="line">  dataFrame[<span class="string">'revenue'</span>],</span><br><span class="line">  revenue_difference.alias(<span class="string">"revenue_difference"</span>))   <span class="comment"># 给个别名</span></span><br></pre></td></tr></table></figure>

<p>这个程序的结果如下所示。在不使用窗口函数的情况下，用户必须找到所有类别的所有最高收入值，然后将这个派生的数据集与原始的productRevenue表连接起来，以计算收入差异。</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/1-3.png" alt="1-3"></p>
<h2 id="使用窗口函数"><a href="#使用窗口函数" class="headerlink" title="使用窗口函数"></a>使用窗口函数</h2><p>Spark SQL支持三种窗口函数:排序函数、分析函数和聚合函数。可用的排序函数和分析函数总结如下表所示。对于聚合函数，用户可以使用任何现有的聚合函数作为窗口函数。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>SQL</strong></th>
<th><strong>DataFrame API</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Ranking functions</strong></td>
<td>rank</td>
<td>rank</td>
</tr>
<tr>
<td></td>
<td>dense_rank</td>
<td>denseRank</td>
</tr>
<tr>
<td></td>
<td>percent_rank</td>
<td>percentRank</td>
</tr>
<tr>
<td></td>
<td>ntile</td>
<td>ntile</td>
</tr>
<tr>
<td></td>
<td>row_number</td>
<td>rowNumber</td>
</tr>
<tr>
<td><strong>Analytic functions</strong></td>
<td>cume_dist</td>
<td>cumeDist</td>
</tr>
<tr>
<td></td>
<td>first_value</td>
<td>firstValue</td>
</tr>
<tr>
<td></td>
<td>last_value</td>
<td>lastValue</td>
</tr>
<tr>
<td></td>
<td>lag</td>
<td>lag</td>
</tr>
<tr>
<td></td>
<td>lead</td>
<td>lead</td>
</tr>
</tbody></table>
<p>要使用窗口函数，用户需要标记一个函数被任意一方用作窗口函数</p>
<ol>
<li>在SQL中支持的函数后添加OVER子句，例如<code>avg(revenue) OVER (...)</code>; </li>
<li>调用DataFrame API中支持的函数上的over方法，例如<code>rank().over(...)</code></li>
</ol>
<p>一旦一个函数被标记为一个窗口函数，下一个关键步骤就是定义与这个函数相关的窗口规范。窗口规范定义在与给定输入行关联的frame中包含哪些行。一个窗口规范包括三个部分:</p>
<ul>
<li><p>分区规范:控制哪些行将与给定行位于同一分区中。此外，在订购和计算frame之前，用户可能希望确保将category列具有相同值的所有行收集到相同的机器上。如果没有给出分区规范，那么所有数据必须收集到一台机器上。</p>
</li>
<li><p>排序规范:控制分区中的行排序的方式，确定给定行在其分区中的位置。</p>
</li>
<li><p>Frame规范:根据当前输入行的相对位置，声明当前输入行的frame中包含哪些行。例如，“当前行之前的三行到当前行”描述了一个frame，其中包括当前输入行和出现在当前行之前的三行。</p>
</li>
</ul>
<p>在SQL中， <code>PARTITION BY</code> 和 <code>ORDER BY</code> 关键字分别用于为分区规范指定分区表达式和为排序规范指定排序表达式。SQL语法如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">OVER (PARTITION BY ... ORDER BY ...)</span><br></pre></td></tr></table></figure>

<p>在DataFrame API中，我们提供了实用程序函数来定义窗口规范。以Python为例，用户可以按如下方式指定分区表达式和排序表达式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.window <span class="keyword">import</span> Window</span><br><span class="line">windowSpec = \</span><br><span class="line">  Window \	<span class="comment"># 定义窗口</span></span><br><span class="line">    .partitionBy(...) \  <span class="comment"># 分区</span></span><br><span class="line">    .orderBy(...)  <span class="comment"># 排序</span></span><br></pre></td></tr></table></figure>

<p>除了排序和分区之外，用户还需要定义frame的开始边界、frame的结束边界和frame的类型，这是frame规范的三个组成部分。</p>
<p>边界有<code>UNBOUNDED PRECEDING</code>, <code>UNBOUNDED FOLLOWING</code>, <code>CURRENT ROW</code>, <code>PRECEDING</code>,和<code>&lt;value&gt; FOLLOWING</code>五种类型。 <code>&lt;value&gt; FOLLOWING</code>. <code>UNBOUNDED PRECEDING</code> and <code>UNBOUNDED FOLLOWING</code>分别表示分区的第一行和最后一行。对于其他三种类型的边界，它们指定当前输入行的位置偏移量，并根据框架的类型定义它们的特定含义。有两种类型的frame，<em>ROW</em> frame 和<em>RANGE</em> frame.</p>
<h3 id="ROW-frame"><a href="#ROW-frame" class="headerlink" title="ROW frame"></a>ROW frame</h3><p>ROW frame是基于当前输入行位置的物理偏移量，也就是说<code>CURRENT ROW</code>, <code>&lt;value&gt; PRECEDING</code>, or <code>&lt;value&gt; FOLLOWING</code>指定物理偏移.如果使用<code>CURRENT ROW</code>作为边界，它表示当前输入行。 <code>PRECEDING</code> and <code>FOLLOWING</code>分别描述当前输入行之前和之后出现的行数。</p>
<p>下图演示了一个行frame， <code>1 PRECEDING</code>作为开始边界， <code>1 FOLLOWING</code> 作为结束边界(在SQL中表现为<code>ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</code>)</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/2-1-1024x338.png" alt="2-1-1024x338"></p>
<h3 id="RANGE-frame"><a href="#RANGE-frame" class="headerlink" title="RANGE frame"></a>RANGE frame</h3><p>RANGE frames基于当前输入行位置的逻辑偏移量，语法与ROW frame类似。逻辑偏移量是当前输入行的排序表达式的值与frame的边界行相同表达式的值之间的差。由于这个定义，当使用RANGE frame时，只允许一个排序表达式。此外，对于RANGE frame，对于边界计算而言，具有与当前输入行相同的排序表达式值的所有行都被认为是相同的行。</p>
<p>现在，让我们看一个例子。在本例中，排序表达式是revenue;开始边界是 <code>2000 PRECEDING</code>;结束边界是<code>1000 FOLLOWING</code>，(这个frame被在SQL中被定义为<code>RANGE BETWEEN 2000 PRECEDING AND 1000 FOLLOWING</code>)，下面的五幅图说明了如何使用当前输入行的更新来更新frame。基本上，对于每一个当前的输入行，基于收入值，我们计算收入范围<code>[current revenue value - 2000, current revenue value + 1000]</code>。收入值在此范围内的所有行都位于当前输入行的frame中。</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/2-2-1024x369.png" alt="2-2-1024x369"></p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/2-3-1024x263.png" alt="2-3-1024x263"></p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/2-4-1024x263.png" alt="2-4-1024x263"></p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/2-5-1024x263.png" alt="2-5-1024x263"></p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/2-6-1024x263.png" alt="2-6-1024x263"></p>
<p>总之，要定义窗口规范，用户可以在SQL中使用以下语法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">OVER (PARTITION BY ... ORDER BY ... frame_type BETWEEN <span class="keyword">start</span> <span class="keyword">AND</span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>在这里，<code>frame_type</code>可以是行(对于ROW frame)或范围(对于 RANGE frame);</p>
<p>都可以使用 <code>UNBOUNDED PRECEDING</code>, <code>CURRENT ROW</code>, <code>&lt;value&gt; PRECEDING</code>, and <code>&lt;value&gt; FOLLOWING</code>其中的任意一个作为开始;  <code>UNBOUNDED FOLLOWING</code>, <code>CURRENT ROW</code>, <code>&lt;value&gt; PRECEDING</code>, and<code>&lt;value&gt; FOLLOWING</code>其中的任意一个作为结束.</p>
<p>在Python DataFrame API中，用户可以定义如下的窗口规范。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql.window <span class="keyword">import</span> Window</span><br><span class="line"><span class="comment"># Defines partitioning specification and ordering specification.</span></span><br><span class="line">windowSpec = \</span><br><span class="line">  Window \</span><br><span class="line">    .partitionBy(...) \</span><br><span class="line">    .orderBy(...)</span><br><span class="line"><span class="comment"># Defines a Window Specification with a ROW frame.</span></span><br><span class="line">windowSpec.rowsBetween(start, end)</span><br><span class="line"><span class="comment"># Defines a Window Specification with a RANGE frame.</span></span><br><span class="line">windowSpec.rangeBetween(start, end)</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/26/%E7%BF%BB%E8%AF%91/1/">ORCFile in HDP 2: Better Compression, Better Performance</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/">原文翻译</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8E%9F%E6%96%87%E7%BF%BB%E8%AF%91/">原文翻译</a></span><div class="content"><p>原文：<a href="https://blog.cloudera.com/orcfile-in-hdp-2-better-compression-better-performance/" target="_blank" rel="noopener">https://blog.cloudera.com/orcfile-in-hdp-2-better-compression-better-performance/</a></p>
<hr>
<p>即将发布的Hive 0.12将在存储层带来一些新的重大改进，包括更高的压缩和更好的查询性能。</p>
<h2 id="高压缩"><a href="#高压缩" class="headerlink" title="高压缩"></a>高压缩</h2><p>ORCFile是在Hive 0.11中引入的，提供了很好的压缩，通过一些技术来实现，包括运行长度编码、字符串字典编码和位图编码。</p>
<p>这种对效率的关注导致了一些令人印象深刻的压缩比。这张图片显示了TPC-DS数据集在不同编码下的规模为500。该数据集包含随机生成的数据，包括字符串、浮点数和整数数据。</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/ORCFile.png" alt="ORCFile"></p>
<p>我们已经看到，有些客户的集群已经从存储的角度扩展到了ORCFile，这是一种释放空间的方法，同时与现有的作业100%兼容。</p>
<p>存储在ORCFile中的数据可以通过HCatalog读取或写入，因此任何Pig或Map/Reduce进程都可以无缝地运行。Hive 12 建立在这些令人印象深刻的压缩比上，并在Hive和执行层提供深度集成来加速查询，从处理更大的数据集和更低的延迟的角度来看都是如此。</p>
<h2 id="谓词下推"><a href="#谓词下推" class="headerlink" title="谓词下推"></a>谓词下推</h2><p>SQL查询通常会有一些WHERE条件，可以用来方便地排除需要考虑的行。在旧版本的Hive中，在稍后通过SQL处理消除之前，将行从存储层中读取出来。有很多浪费的开销，Hive 12通过允许将谓词下推并在存储层本身进行计算来优化这一点。它是由环境控制的<code>hive.optimize.ppd=true</code>.</p>
<p>这需要读者具有足够的智慧来理解谓词。幸运的是，ORC已经进行了相应的改进，允许将谓词推入其中，并利用其内联索引提供性能优势。</p>
<p>例如，如果你有一个SQL查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> CUSTOMER <span class="keyword">WHERE</span> CUSTOMER.state = ‘CA’;</span><br></pre></td></tr></table></figure>

<p>ORCFile只返回与WHERE谓词实际匹配的行，而跳过驻留在任何其他状态的客户。从表中读取的列越多，要避免的数据封送处理就越多，速度也就越快。</p>
<h2 id="ORCFile内联索引"><a href="#ORCFile内联索引" class="headerlink" title="ORCFile内联索引"></a>ORCFile内联索引</h2><p>在进入下一节之前，我们需要花一点时间讨论ORCFile如何将行分解为行组，并在这些行组中应用列式压缩和索引。</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/orc2.png" alt="orc2"></p>
<p>ORC的谓词下推将参考内联索引，以尝试确定何时可以一次性跳过整个块。有时，您的数据集自然会促进这一点。例如，如果您的数据是一个时间序列，并且时间戳是单调递增的，那么当您在这个时间戳上加上where条件时，ORC将能够跳过许多行组。</p>
<p>在其他情况下，可能需要对数据进行排序。如果对一列进行排序，相关记录将被限制在磁盘上的一个区域，其他部分将很快被跳过。</p>
<p>对于数字类型和字符串类型，跳过可以工作。在这两个实例中，都是通过在内联索引中记录一个最小值和一个最大值并确定查找值是否落在这个范围之外来完成的。</p>
<p>排序可以导致非常好的加速。这里有一个权衡，您需要提前决定对哪些列排序。决策过程在某种程度上类似于决定在传统SQL系统中索引哪些列。最好的回报是您拥有一个经常使用的列，并且在非常特定的条件下访问它，并且在很多查询中使用它。请记住，您可以在创建表时设置hive.enforce.sorting=true并使用SORT BY关键字强制Hive对列进行排序。</p>
<p>ORCFile是我们的一个重要的刺激举措，以提高Hive性能100倍。为了显示影响，我们使用修改后的数据模式运行修改后的TPC-DS查询27。查询27在一个大型事实表上执行星型模式连接，访问4个独立的维度表。在修改后的模式中，销售的状态被反规范化为事实表，结果表按状态排序。通过这种方式，当查询扫描事实表时，它可以跳过整个行块，因为查询根据状态进行筛选。这导致了一些增量加速，正如您可以从下面的图表中看到的。</p>
<p><img src="https://yerias.github.io/%E7%BF%BB%E8%AF%91/orc1.png" alt="orc1"></p>
<p>这个功能给你最好的性价比时:</p>
<ol>
<li><p>在具有中等到较大基数的列上，您经常以一种精确的方式过滤大型事实表。</p>
</li>
<li><p>您可以选择大量的列，或者宽列。您保存的数据封送处理越多，您的加速就越大。</p>
</li>
</ol>
<h2 id="使用ORCFile"><a href="#使用ORCFile" class="headerlink" title="使用ORCFile"></a>使用ORCFile</h2><p>使用ORCFile或将现有数据转换为ORCFile非常简单。要使用它，只需添加存储为orc到您的create table语句的结尾，如下所示:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">...</span><br><span class="line">) <span class="keyword">STORED</span> <span class="keyword">AS</span> orc;</span><br></pre></td></tr></table></figure>

<p>若要将现有数据转换为ORCFile，请创建一个与源表具有相同模式并存储为orc的表，然后可以使用如下查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> orctable <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> oldtable;</span><br></pre></td></tr></table></figure>

<p>Hive将处理所有细节的ORCFile转换，你可以自由删除旧表，以释放大量的空间。</p>
<p>创建ORC表时，可以使用许多表属性进一步优化ORC的工作方式。</p>
<table>
<thead>
<tr>
<th><strong>Key</strong></th>
<th><strong>Default</strong></th>
<th><strong>Notes</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>orc.compress</code></td>
<td><code>ZLIB</code></td>
<td>压缩除使用列式压缩外，还可以使用NONE, ZLIB, SNAPPY</td>
</tr>
<tr>
<td><code>orc.compress.size</code></td>
<td><code>262,144 (= 256 KiB)</code></td>
<td>每个压缩块中的字节数</td>
</tr>
<tr>
<td>orc.stripe.size</td>
<td><code>268,435,456 (= 256 MiB)</code></td>
<td>每条数据中的字节数</td>
</tr>
<tr>
<td><code>orc.row.index.stride</code></td>
<td><code>10,000</code></td>
<td>索引项之间的行数 (必须 &gt;= 1,000)</td>
</tr>
<tr>
<td><code>orc.create.index</code></td>
<td><code>true</code></td>
<td>是否创建内联索引</td>
</tr>
</tbody></table>
<p>例如，假设您想使用snappy压缩而不是zlib压缩。方法如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">...</span><br><span class="line">) <span class="keyword">STORED</span> <span class="keyword">AS</span> orc tblproperties (<span class="string">"orc.compress"</span>=<span class="string">"SNAPPY"</span>);</span><br></pre></td></tr></table></figure>



</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/24/spark/22/">Kafka Offset管理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>Kafka中的每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序号，用于partition唯一标识一条消息。</p>
<p><strong>Offset记录着下一条将要发送给Consumer的消息的序号。</strong></p>
<p>Offset从语义上来看拥有两种：Current Offset和Committed Offset。</p>
<h2 id="Current-Offset"><a href="#Current-Offset" class="headerlink" title="Current Offset"></a>Current Offset</h2><p>Current Offset保存在Consumer客户端中，它表示Consumer希望收到的下一条消息的序号。它仅仅在pull()方法中使用。例如，Consumer第一次调用pull()方法后收到了20条消息，那么Current Offset就被设置为20。这样Consumer下一次调用pull()方法时，Kafka就知道应该从序号为21的消息开始读取。这样就能够保证每次Consumer pull消息时，都能够收到不重复的消息。</p>
<h2 id="Committed-Offset"><a href="#Committed-Offset" class="headerlink" title="Committed Offset"></a>Committed Offset</h2><p>Committed Offset保存在Broker上，它表示Consumer已经确认消费过的消息的序号。主要通过<code>commitSync</code>和<code>commitAsync</code> API来操作。举个例子，Consumer通过pull() 方法收到20条消息后，此时Current Offset就是20，经过一系列的逻辑处理后，并没有调用<code>consumer.commitAsync()</code>或<code>consumer.commitSync()</code>来提交Committed Offset，那么此时Committed Offset依旧是0。</p>
<p>Committed Offset主要用于Consumer Rebalance。在Consumer Rebalance的过程中，一个partition被分配给了一个Consumer，那么这个Consumer该从什么位置开始消费消息呢？答案就是Committed Offset。另外，如果一个Consumer消费了5条消息（pull并且成功commitSync）之后宕机了，重新启动之后它仍然能够从第6条消息开始消费，因为Committed Offset已经被Kafka记录为5。</p>
<p>总结一下，Current Offset是针对Consumer的pull过程的，它可以保证每次pull都返回不重复的消息；而Committed Offset是用于Consumer Rebalance过程的，它能够保证新的Consumer能够从正确的位置开始消费一个partition，从而避免重复消费。</p>
<h2 id="Offset存储模型"><a href="#Offset存储模型" class="headerlink" title="Offset存储模型"></a>Offset存储模型</h2><p>由于一个partition只能固定的交给一个消费者组中的一个消费者消费，因此Kafka保存offset时并不直接为每个消费者保存，而是以groupid-topic-partition -&gt; offset的方式保存。如图所示：</p>
<p><img src="https://yerias.github.io/spark_img/group-topic-partition-offset.jpg" alt="group-topic-partition-offset"></p>
<p><strong>Kafka在保存Offset的时候，实际上是将Consumer Group和partition对应的offset以消息的方式保存在__consumers_offsets这个topic中</strong>。</p>
<p>下图展示了__consumers_offsets中保存的offset消息的格式：</p>
<p><img src="https://yerias.github.io/spark_img/_consumers_offsets.jpg" alt="_consumers_offsets"></p>
<p><img src="https://yerias.github.io/spark_img/__consumers_offsets_data.jpg" alt="__consumers_offsets_data"></p>
<p>如图所示，一条offset消息的格式为groupid-topic-partition -&gt; offset。因此consumer pull消息时，已知groupid和topic，又通过Coordinator分配partition的方式获得了对应的partition，自然能够通过Coordinator查找__consumers_offsets的方式获得最新的offset了。</p>
<h2 id="Kafka-Offset-的几种管理方式"><a href="#Kafka-Offset-的几种管理方式" class="headerlink" title="Kafka Offset 的几种管理方式"></a>Kafka Offset 的几种管理方式</h2><ul>
<li><code>Spark Checkpoint：</code>在 Spark Streaming 执行Checkpoint 操作时，将 Kafka Offset 一并保存到 HDFS 中。这种方式的问题在于：当 Spark Streaming 应用升级或更新时，以及当Spark 本身更新时，Checkpoint 可能无法恢复。因而，不推荐采用这种方式。</li>
<li><code>HBASE、Redis 等外部 NOSQL 数据库：</code>这一方式可以支持大吞吐量的 Offset 更新，但它最大的问题在于：用户需要自行编写 HBASE 或 Redis 的读写程序，并且需要维护一个额外的组件。</li>
<li><code>ZOOKEEPER：</code>老版本的位移offset是提交到zookeeper中的，目录结构是 ：/consumers/&lt;group.id&gt;/offsets/ &lt;topic&gt;/&lt;partitionId&gt; ，但是由于 ZOOKEEPER 的写入能力并不会随着 ZOOKEEPER 节点数量的增加而扩大，因而，当存在频繁的 Offset 更新时，ZOOKEEPER 集群本身可能成为瓶颈。因而，不推荐采用这种方式。</li>
<li><code>KAFKA 自身的一个特殊 Topic（__consumer_offsets）中</code>：这种方式支持大吞吐量的Offset 更新，又不需要手动编写 Offset 管理程序或者维护一套额外的集群，但是Kafka不支持事物，不能保证输出的幂等性(Exactly once)。</li>
</ul>
<p><img src="https://yerias.github.io/spark_img/offsets-manager.png" alt="offsets-manager"></p>
<h2 id="Redis实现Offset幂等性消费"><a href="#Redis实现Offset幂等性消费" class="headerlink" title="Redis实现Offset幂等性消费"></a>Redis实现Offset幂等性消费</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Spark Streaming实时消费kafka数据的时候，程序停止或者Kafka节点挂掉会导致数据丢失，Spark Streaming也没有设置CheckPoint(节点挂了，数据容易丢失)，所以每次出现问题的时候，重启程序，而程序的消费方式是Direct，所以在程序down掉的这段时间Kafka上的数据是消费不到的，虽然可以设置offset为smallest，但是会导致重复消费，重新overwrite hive上的数据，但是不允许重复消费的场景就不能这样做。</p>
<h3 id="原理阐述"><a href="#原理阐述" class="headerlink" title="原理阐述"></a>原理阐述</h3><p>在Spark Streaming中消费 Kafka 数据的时候，有两种方式分别是 ：</p>
<ol>
<li><p>基于 Receiver-based 的 createStream 方法。receiver从Kafka中获取的数据都是存储在Spark Executor的内存中的，然后Spark Streaming启动的job会去处理那些数据。然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark Streaming的<strong>预写日志机制</strong>（Write Ahead Log，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。本文对此方式不研究，有兴趣的可以自己实现，个人不喜欢这个方式。</p>
</li>
<li><p>Direct Approach (No Receivers) 方式的 createDirectStream 方法，但是第二种使用方式中  kafka 的 offset 是保存在 checkpoint 中的，如果程序重启的话，会丢失一部分数据，我使用的是这种方式。KafkaUtils.createDirectStream。本文将用代码说明如何将 kafka 中的 offset 保存到 Redis 中，以及如何从 Redis 中读取已存在的 offset。参数auto.offset.reset为latest的时候程序才会读取redis的offset。</p>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>OffsetsManager trait</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OffsetsManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">obtainOffsets</span></span>(topics: <span class="type">Array</span>[<span class="type">String</span>], groupId: <span class="type">String</span>): <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">Long</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">storeOffsets</span></span>(offsetRanges: <span class="type">Array</span>[<span class="type">OffsetRange</span>], groupId: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedisOffsetsManager object</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RedisOffsetsManager</span> <span class="keyword">extends</span> <span class="title">OffsetsManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 拿到offset</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">obtainOffsets</span></span>(topics: <span class="type">Array</span>[<span class="type">String</span>], groupId: <span class="type">String</span>): <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">Long</span>] = &#123;</span><br><span class="line">        <span class="comment">// 定义fromOffsets、jedis、offsetMap</span></span><br><span class="line">        <span class="keyword">var</span> fromOffsets: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">Long</span>] = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> jedis: <span class="type">Jedis</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> offsetMap: util.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化jedis</span></span><br><span class="line">            jedis = <span class="type">RedisUtils</span>.getJedis</span><br><span class="line">            <span class="comment">// 拿到offsetMap</span></span><br><span class="line">            offsetMap = jedis.hgetAll(topics(<span class="number">0</span>) + <span class="string">"_"</span> + groupId)</span><br><span class="line">            <span class="comment">// 导入java集合转scala的依赖</span></span><br><span class="line">            <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line">            offsetMap.asScala.foreach(row =&gt; &#123;</span><br><span class="line">                <span class="comment">// 拿到topicPartition</span></span><br><span class="line">                <span class="keyword">val</span> topicPartition = <span class="keyword">new</span> <span class="type">TopicPartition</span>(topics(<span class="number">0</span>), row._1.toInt)</span><br><span class="line">                <span class="comment">// 将topicPartition和offset放入fromOffsets</span></span><br><span class="line">                fromOffsets += topicPartition -&gt; row._2.toLong</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> e:<span class="type">Exception</span> =&gt; e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭jedis</span></span><br><span class="line">            jedis.close()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回fromOffsets</span></span><br><span class="line">        fromOffsets</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 存储offset</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">storeOffsets</span></span>(offsetRanges: <span class="type">Array</span>[<span class="type">OffsetRange</span>], groupId: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 定义jedis</span></span><br><span class="line">        <span class="keyword">var</span> jedis:<span class="type">Jedis</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化jedis</span></span><br><span class="line">            jedis = <span class="type">RedisUtils</span>.getJedis</span><br><span class="line">            offsetRanges.foreach(o  =&gt; &#123;</span><br><span class="line">                <span class="comment">// 存储offset</span></span><br><span class="line">                jedis.hset(o.topic + <span class="string">"_"</span> + groupId, o.partition + <span class="string">""</span>, o.untilOffset + <span class="string">""</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> e:<span class="type">Exception</span> =&gt; e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭jedis0</span></span><br><span class="line"></span><br><span class="line">            jedis.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里offsets保存在Redis，如果是MySQL同理，只需要实现obtainOffsets和storeOffsets方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MySQLOffsetsManager</span> <span class="keyword">extends</span> <span class="title">OffsetsManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">obtainOffsets</span></span>(topics: <span class="type">Array</span>[<span class="type">String</span>], groupId: <span class="type">String</span>): <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">Long</span>] = ???</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">storeOffsets</span></span>(offsetRanges: <span class="type">Array</span>[<span class="type">OffsetRange</span>], groupId: <span class="type">String</span>): <span class="type">Unit</span> = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OffsetsRedis</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OffsetsRedis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 消费者组</span></span><br><span class="line">        <span class="keyword">val</span> groupId = <span class="string">"use_a_separate_group_id_for_each_stream_3"</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">            <span class="string">"bootstrap.servers"</span> -&gt; <span class="string">"hadoop:9090,hadoop:9091,hadoop:9092"</span>,</span><br><span class="line">            <span class="string">"key.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">            <span class="string">"value.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">            <span class="string">"group.id"</span> -&gt; groupId,</span><br><span class="line">            <span class="string">"auto.offset.reset"</span> -&gt; <span class="string">"earliest"</span>, <span class="comment">//latest</span></span><br><span class="line">            <span class="string">"enable.auto.commit"</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 拿到topic</span></span><br><span class="line">        <span class="keyword">val</span> topics = <span class="type">Array</span>(<span class="string">"test"</span>) <span class="comment">// topic</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 拿到偏移量</span></span><br><span class="line">        <span class="keyword">val</span> fromOffsets = <span class="type">RedisOffsetsManager</span>.obtainOffsets(topics,groupId) <span class="comment">//Map[TopicPartition, Long]()</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>](</span><br><span class="line">            ssc,</span><br><span class="line">            <span class="type">PreferConsistent</span>,</span><br><span class="line">            <span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](topics, kafkaParams, fromOffsets)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        stream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rdd.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 拿到offsetRanges 包括topic、partition、fromOffset、untilOffset</span></span><br><span class="line">                <span class="keyword">val</span> offsetRanges: <span class="type">Array</span>[<span class="type">OffsetRange</span>] = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 已经拿到了offset，可以开始业务逻辑处理</span></span><br><span class="line">                <span class="keyword">val</span> result = rdd.map(row =&gt; &#123;</span><br><span class="line">                    (row.value(), <span class="number">1</span>)</span><br><span class="line">                &#125;).reduceByKey(_ + _)</span><br><span class="line">                .collect()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 事物写入redis</span></span><br><span class="line">                <span class="keyword">var</span> jedis: <span class="type">Jedis</span> = <span class="literal">null</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jedis = <span class="type">RedisUtils</span>.getJedis</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 提交业务逻辑</span></span><br><span class="line">                    <span class="keyword">for</span> (pair &lt;- result) &#123;</span><br><span class="line">                        jedis.hincrBy(<span class="string">"wc_redis_ss"</span>, pair._1, pair._2)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 写offset</span></span><br><span class="line">                    <span class="type">RedisOffsetsManager</span>.storeOffsets(offsetRanges,groupId)</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">                    e.printStackTrace()</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    jedis.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">s"拉取数据中..."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 开始作业</span></span><br><span class="line">        ssc.start()</span><br><span class="line">        ssc.awaitTermination()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="exactly-once方案"><a href="#exactly-once方案" class="headerlink" title="exactly once方案"></a>exactly once方案</h3><p>准确的说也不是严格的方案，要根据实际的业务场景来配合。</p>
<p>现在的方案是保存rdd的最后一个offset，我们可以考虑在处理完一个消息之后就更新offset，保存offset和业务处理做成一个事务，当出现Exception的时候，都进行回退，或者将出现问题的offset和消息发送到另一个kafka或者保存到数据库，另行处理错误的消息。代码demo如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">stream.foreachRDD(rdd =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rdd.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 拿到offsetRanges 包括topic、partition、fromOffset、untilOffset</span></span><br><span class="line">        <span class="keyword">val</span> offsetRanges: <span class="type">Array</span>[<span class="type">OffsetRange</span>] = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经拿到了offset，可以开始业务逻辑处理</span></span><br><span class="line">        <span class="keyword">val</span> result = rdd.map(row =&gt; &#123;</span><br><span class="line">            (row.value(), <span class="number">1</span>)</span><br><span class="line">        &#125;).reduceByKey(_ + _)</span><br><span class="line">        .collect()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事物写入redis</span></span><br><span class="line">        <span class="keyword">var</span> pipeline: <span class="type">Pipeline</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> jedis: <span class="type">Jedis</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = <span class="type">RedisUtils</span>.getJedis</span><br><span class="line">            pipeline = jedis.pipelined()</span><br><span class="line">            pipeline.multi()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交业务逻辑</span></span><br><span class="line">            <span class="keyword">for</span> (pair &lt;- result) &#123;</span><br><span class="line">                pipeline.hincrBy(<span class="string">"wc_redis_ss"</span>, pair._1, pair._2)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写offset</span></span><br><span class="line">            offsetRanges.foreach(o =&gt; &#123;</span><br><span class="line">                pipeline.hset(topics(<span class="number">0</span>) + <span class="string">"_"</span> + groupId, o.partition + <span class="string">""</span>, o.untilOffset + <span class="string">""</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交&amp;同步</span></span><br><span class="line">            pipeline.exec()</span><br><span class="line">            pipeline.sync()</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">            <span class="comment">// 失败回滚</span></span><br><span class="line">            pipeline.discard()</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            pipeline.close()</span><br><span class="line">            jedis.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">s"拉取数据中..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>注意：</code>pipeline不能在Redis集群中使用，但是适用于主从架构</p>
<h2 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h2><p>数据流系统的语义通常根据系统可以处理每个记录的次数来捕获。在所有可能的操作条件下(除了故障等)，系统可以提供三种类型的保证。</p>
<ul>
<li>At most once: 每个记录要么处理一次，要么根本不处理。</li>
<li>At least once:  每个记录将被处理一次或多次。这比最多一次强，因为它确保不会丢失任何数据。但是可能有重复的。</li>
<li>Exactly once: 每条记录将被精确处理一次——没有数据会丢失，也没有数据会被多次处理。这显然是三者中最有力的保证。</li>
</ul>
<h2 id="auto-offset-reset参数"><a href="#auto-offset-reset参数" class="headerlink" title="auto.offset.reset参数"></a>auto.offset.reset参数</h2><p>Kafka 默认是定期帮你自动提交位移的（enable.auto.commit=true）。有时候，我们需要采用自己来管理位移提交，这时候需要设置 enable.auto.commit=false。</p>
<ul>
<li><p>earliest: 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</p>
</li>
<li><p>latest: 当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</p>
</li>
<li><p>none: topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</p>
</li>
</ul>
<p>默认建议用earliest。设置该参数后 kafka出错后重启，找到未消费的offset可以继续消费。</p>
<p>而latest 这个设置容易丢失消息，假如kafka出现问题，还有数据往topic中写，这个时候重启kafka，这个设置会从最新的offset开始消费,中间出问题的哪些就不管了。 </p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/24/spark/21/">SS黑名单管理&amp;窗口&amp;闭包&amp;SS对接Kafka&amp;KafkaRDD</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>黑名单管理</li>
<li>窗口</li>
<li>闭包</li>
<li>SS对接Kafka</li>
<li>KafkaRDD</li>
</ol>
<h2 id="黑名单管理"><a href="#黑名单管理" class="headerlink" title="黑名单管理"></a>黑名单管理</h2><p>Spark Streaming在计算流式数据时，有时候需要过滤一些数据，比如一些特殊的字段，或者利用爬虫爬取数据的恶意ip，又或者那些帮助某些无良商家刷广告的人，那么我们有一个黑名单，来过滤或者禁止他们的访问</p>
<p>思路：</p>
<ol>
<li>准备一个管理黑名单的文件，读进RDD作为key，并添加一个value值为true</li>
<li>Spark Streaming接收流式数据，使用transform转换为RDD，拿到key用来做join，value为数据内容</li>
<li>两个RDD做left join，并过滤掉value值为true的数据</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取黑名单数据，并做简单处理</span></span><br><span class="line">    <span class="keyword">val</span> blacks = <span class="type">List</span>(<span class="string">"tunan"</span>)</span><br><span class="line">    <span class="keyword">val</span> blackRDD = ssc.sparkContext.parallelize(blacks)</span><br><span class="line">    <span class="keyword">val</span> blackMapRDD = blackRDD.map((_,<span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从socket拿到流式数据</span></span><br><span class="line">    <span class="keyword">val</span> stream = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据转换成RDD</span></span><br><span class="line">    stream.transform( rdd =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> mapRDD= rdd.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">","</span>)</span><br><span class="line">            <span class="comment">// 拿到做join的key，value为数据内容</span></span><br><span class="line">            (words(<span class="number">0</span>), row)</span><br><span class="line">        &#125;)</span><br><span class="line">		<span class="comment">// 流式数据为基表，做left join</span></span><br><span class="line">        <span class="keyword">val</span> joinRDD = mapRDD.leftOuterJoin(blackMapRDD)</span><br><span class="line">		<span class="comment">// 过滤掉黑名单数据</span></span><br><span class="line">        <span class="keyword">val</span> filterRDD = joinRDD.filter(_._2._2.getOrElse(<span class="literal">false</span>) != <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// 返回数据内容</span></span><br><span class="line">        filterRDD.map(_._2._1)</span><br><span class="line">    &#125;).print()</span><br><span class="line">    </span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="窗口-了解，Flink详解"><a href="#窗口-了解，Flink详解" class="headerlink" title="窗口(了解，Flink详解)"></a>窗口(了解，Flink详解)</h2><p>Spark Streaming还提供了窗口计算功能，允许在数据的滑动窗口上应用转换操作。下图说明了滑动窗口的工作方式：<img src="E:%5Chexo%5Cyeriasblog%5Cthemes%5Cmelody%5Csource%5Cspark_img%5Cstreaming-dstream-window.png" alt="streaming-dstream-window"></p>
<p>如图所示，每当窗口滑过<code>originalDStream</code>时，落在窗口内的源RDD被组合并被执行操作以产生<code>windowedDStream</code>的RDD。在上面的例子中，操作应用于最近3个时间单位的数据，并以2个时间单位滑动。这表明任何窗口操作都需要指定两个参数：</p>
<ul>
<li><p>窗口长度（windowlength） - 窗口的时间长度（上图的示例中为：3）。</p>
</li>
<li><p>滑动间隔（slidinginterval） - 两次相邻的窗口操作的间隔（即每次滑动的时间长度）（上图示例中为：2）。</p>
<p>这两个参数必须是源DStream的批间隔的倍数（上图示例中为：1）。</p>
</li>
</ul>
<p>我们以一个例子来说明窗口操作。 对之前的单词计数的示例进行扩展，每10秒钟对过去30秒的数据进行wordcount。为此，我们必须在最近30秒的pairs DStream数据中对(word, 1)键值对应用<code>reduceByKey</code>操作。这是通过使用<code>reduceByKeyAndWindow</code>操作完成的。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行wordcount</span></span><br><span class="line"><span class="keyword">val</span> words = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> wordPair = words.map(x =&gt; (x, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//val wordCountResult = wordPair.reduceByKey(_ + _)</span></span><br><span class="line"><span class="keyword">val</span> wordCountResult = wordPair.reduceByKeyAndWindow(</span><br><span class="line">    (a: <span class="type">Int</span>, b: <span class="type">Int</span>) =&gt; (a + b), <span class="type">Seconds</span>(<span class="number">30</span>), <span class="type">Seconds</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>一些常见的窗口操作如下表所示。所有这些操作都用到了上述两个参数：<code>windowLength</code>和<code>slideInterval</code>。</p>
<ul>
<li><p><code>window(windowLength, slideInterval)</code></p>
<p>基于源DStream产生的窗口化的批数据计算一个新的DStream</p>
</li>
<li><p><code>countByWindow(windowLength, slideInterval)</code></p>
<p>返回流中元素的一个滑动窗口数</p>
</li>
<li><p><code>reduceByWindow(func, windowLength, slideInterval)</code></p>
<p>返回一个单元素流。利用函数func聚集滑动时间间隔的流的元素创建这个单元素流。函数必须是相关联的以使计算能够正确的并行计算。</p>
</li>
<li><p><code>reduceByKeyAndWindow(func, windowLength, slideInterval, [numTasks])</code></p>
<p>应用到一个(K,V)对组成的DStream上，返回一个由(K,V)对组成的新的DStream。每一个key的值均由给定的reduce函数聚集起来。注意：在默认情况下，这个算子利用了Spark默认的并发任务数去分组。你可以用numTasks参数设置不同的任务数</p>
</li>
<li><p><code>reduceByKeyAndWindow(func, invFunc, windowLength, slideInterval, [numTasks])</code></p>
<p>上述<code>reduceByKeyAndWindow()</code>的更高效的版本，其中使用前一窗口的reduce计算结果递增地计算每个窗口的reduce值。这是通过对进入滑动窗口的新数据进行reduce操作，以及“逆减（inverse reducing）”离开窗口的旧数据来完成的。一个例子是当窗口滑动时对键对应的值进行“一加一减”操作。但是，它仅适用于“可逆减函数（invertible reduce functions）”，即具有相应“反减”功能的减函数（作为参数invFunc）。 像<code>reduceByKeyAndWindow</code>一样，通过可选参数可以配置reduce任务的数量。 请注意，使用此操作必须启用检查点。</p>
</li>
<li><p><code>countByValueAndWindow(windowLength, slideInterval, [numTasks])</code></p>
<p>应用到一个(K,V)对组成的DStream上，返回一个由(K,V)对组成的新的DStream。每个key的值都是它们在滑动窗口中出现的频率。</p>
</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Spark的难点之一是理解<strong>跨集群执行代码时变量和方法的范围和生命周期</strong>。在范围之外修改变量的RDD操作可能经常引起混淆。在下面的示例中，我们将查看使用foreach()递增计数器的代码，但是其他操作也可能出现类似的问题。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> rdd = sc.parallelize(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong: Don't do this!!</span></span><br><span class="line">rdd.foreach(x =&gt; counter += x)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"Counter value: "</span> + counter)</span><br></pre></td></tr></table></figure>

<p>上述代码的行为是未定义的，可能无法按预期工作。为了执行作业，Spark将RDD操作的处理分解为tasks，每个任务由executor执行。在执行之前，Spark计算task的闭包。闭包是那些executor在RDD上执行其计算时必须可见的变量和方法(在本例中为foreach())。这个闭包被序列化并发送给每个executor 。</p>
<p>闭包中发送给每个executor 的变量现在都是副本，因此，当在foreach函数中引用counter时，它不再是driver 上的计数器。在executors的内存中仍然有一个计数器，但它对executor不再可见!executor只看到来自序列化闭包的副本。因此，counter的最终值仍然是零，因为<strong>counter上的所有操作都引用了序列化闭包中的值</strong>。</p>
<p>一般来说，像循环或局部定义方法这样的闭包结构不应该用来改变全局状态。Spark不保证闭包外部引用的对象的突变行为。一些这样做的代码可能在本地模式下工作，但那只是偶然的，而且这样的代码在分布式模式下不会像预期的那样工作。如果需要全局聚合，则使用Accumulator。</p>
<h2 id="SS对接Kafka"><a href="#SS对接Kafka" class="headerlink" title="SS对接Kafka"></a>SS对接Kafka</h2><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。</p>
<p>SS是Spark上的一个流式处理框架，可以面向海量数据实现高吞吐量、高容错的实时计算。SS支持多种类型数据源，包括Kafka、Flume、twitter、zeroMQ、Kinesis以及TCP sockets等。SS实时接收数据流，并按照一定的时间间隔将连续的数据流拆分成一批批离散的数据集；然后应用诸如map、reduce、join和window等丰富的API进行复杂的数据处理；最后提交给Spark引擎进行运算，得到批量结果数据，因此其也被称为准实时处理系统。而结果也能保存在很多地方，如HDFS，数据库等。另外SS也能和MLlib（机器学习）以及GraphX（图计算）完美融合。</p>
<p>下面我们就来一个SS对接Kafka的案例(Kafka的研究看我的其他博客)</p>
<p>Kafka Product API</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 设置配置文件，这些配置文件都是源码中找的</span></span><br><span class="line">    <span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"hadoop:9090,hadoop:9091,hadoop:9092"</span>);</span><br><span class="line">    props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">    props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">    props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">    <span class="comment">// 创建producer</span></span><br><span class="line">    <span class="keyword">val</span> producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>[<span class="type">String</span>, <span class="type">String</span>](props)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环发送数据</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> par = i%<span class="number">3</span> <span class="comment">// 数组走的分区</span></span><br><span class="line">        producer.send(<span class="keyword">new</span> <span class="type">ProducerRecord</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">"test"</span>,par,<span class="string">""</span>,<span class="type">Integer</span>.toString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭producer</span></span><br><span class="line">    producer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spark Streaming  Consumer</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建ssc</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接kafka配置参数</span></span><br><span class="line">    <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">        <span class="string">"bootstrap.servers"</span> -&gt; <span class="string">"hadoop:9090,hadoop:9091,hadoop:9092"</span>,</span><br><span class="line">        <span class="string">"key.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">        <span class="string">"value.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">        <span class="string">"group.id"</span> -&gt; <span class="string">"use_a_separate_group_id_for_each_stream"</span>,</span><br><span class="line">        <span class="string">"auto.offset.reset"</span> -&gt; <span class="string">"earliest"</span>, <span class="comment">//latest</span></span><br><span class="line">        <span class="string">"enable.auto.commit"</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 可以设置多个topic</span></span><br><span class="line">    <span class="keyword">val</span> topics = <span class="type">Array</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="comment">// 创建DirectStream</span></span><br><span class="line">    <span class="keyword">val</span> stream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>](</span><br><span class="line">        ssc,</span><br><span class="line">        <span class="type">PreferConsistent</span>,</span><br><span class="line">        <span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](topics, kafkaParams)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    stream.map(x =&gt; (x.value(),<span class="number">1</span>)).reduceByKey(_+_)</span><br><span class="line">    .foreachRDD(rdd =&gt; &#123;</span><br><span class="line">        <span class="comment">// 分区操作</span></span><br><span class="line">        rdd.foreachPartition(partition =&gt; &#123;</span><br><span class="line">            <span class="comment">// 一个分区连一个jedis</span></span><br><span class="line">            <span class="keyword">val</span> jedis = <span class="type">RedisUtils</span>.getJedis</span><br><span class="line">            partition.foreach(fields =&gt;&#123;</span><br><span class="line">                <span class="comment">// 保存到Hash中</span></span><br><span class="line">                jedis.hincrBy(<span class="string">"wc_redis"</span>,fields._1,fields._2)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            jedis.close()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 启动程序</span></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，无论在哪里写进Kafka的数据，都可以从Spark Streaming的客户端写出来，我们这里保存的是Redis，保存在MySQL是同样的思路。</p>
<h2 id="KafkaRDD"><a href="#KafkaRDD" class="headerlink" title="KafkaRDD"></a>KafkaRDD</h2><p>最后我们看一下如何在代码中拿到Kafka的Offset</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">        <span class="string">"bootstrap.servers"</span> -&gt; <span class="string">"hadoop:9090,hadoop:9091,hadoop:9092"</span>,</span><br><span class="line">        <span class="string">"key.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">        <span class="string">"value.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">        <span class="string">"group.id"</span> -&gt; <span class="string">"use_a_separate_group_id_for_each_stream"</span>,</span><br><span class="line">        <span class="string">"auto.offset.reset"</span> -&gt; <span class="string">"earliest"</span>, <span class="comment">//latest</span></span><br><span class="line">        <span class="string">"enable.auto.commit"</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topics = <span class="type">Array</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="comment">// stream不能做任何操作，否则得到的不是一个KafkaRDD</span></span><br><span class="line">    <span class="keyword">val</span> stream = <span class="type">KafkaUtils</span>.createDirectStream[<span class="type">String</span>, <span class="type">String</span>](</span><br><span class="line">        ssc,</span><br><span class="line">        <span class="type">PreferConsistent</span>,</span><br><span class="line">        <span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](topics, kafkaParams)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先拿到HasOffsetRanges，才能开始业务逻辑</span></span><br><span class="line">    stream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">        <span class="comment">// 通过rdd.asInstanceOf[HasOffsetRanges]拿到KafkaRDD，它保存了每个分区的offset</span></span><br><span class="line">        <span class="keyword">val</span> offsetRanges = rdd.asInstanceOf[<span class="type">HasOffsetRanges</span>].offsetRanges</span><br><span class="line">        <span class="comment">// KafkaRDD维护了topic、partition、fromOffset、untilOffset</span></span><br><span class="line">        offsetRanges.foreach &#123; o =&gt;</span><br><span class="line">            println(<span class="string">s"<span class="subst">$&#123;o.topic&#125;</span> <span class="subst">$&#123;o.partition&#125;</span> <span class="subst">$&#123;o.fromOffset&#125;</span> <span class="subst">$&#123;o.untilOffset&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动程序</span></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>对HasOffsetRanges的类型转换只有在对createDirectStream的结果调用的第一个方法中完成时才会成功，而不是在随后的方法链中。</li>
<li>RDD分区和Kafka分区之间的一一映射会在RDD发生shuffle或者repartition操作之后改变，比如reduceByKey或window</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/23/redis/1/">单节点部署redis</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a></span><div class="content"><h3 id="第一步：下载redis安装包-整个安装流程建议在root用户下完成"><a href="#第一步：下载redis安装包-整个安装流程建议在root用户下完成" class="headerlink" title="第一步：下载redis安装包(整个安装流程建议在root用户下完成)"></a>第一步：下载redis安装包(整个安装流程建议在root用户下完成)</h3><p>wget <a href="http://download.redis.io/releases/redis-5.0.5.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-5.0.5.tar.gz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop local]# wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">--2017-12-13 12:35:12--  http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">Resolving download.redis.io (download.redis.io)... 109.74.203.151</span><br><span class="line">Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1723533 (1.6M) [application/x-gzip]</span><br><span class="line">Saving to: ‘redis-5.0.5.tar.gz’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[==========================================================================================================&gt;] 1,723,533    608KB/s   <span class="keyword">in</span> 2.8s   </span></span><br><span class="line"></span><br><span class="line">2017-12-13 12:35:15 (608 KB/s) - ‘redis-5.0.5.tar.gz’ saved [1723533/1723533]</span><br></pre></td></tr></table></figure>

<h3 id="第二步：解压压缩包"><a href="#第二步：解压压缩包" class="headerlink" title="第二步：解压压缩包"></a>第二步：解压压缩包</h3><p>tar -zxvf redis-5.0.5.tar.gz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop local]# tar -zxvf redis-5.0.5.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="第三步：yum安装gcc依赖"><a href="#第三步：yum安装gcc依赖" class="headerlink" title="第三步：yum安装gcc依赖"></a>第三步：yum安装gcc依赖</h3><p>yum install gcc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop local]# yum install gcc</span><br></pre></td></tr></table></figure>

<p>遇到选择,输入y即可</p>
<h3 id="第四步：跳转到redis解压目录下"><a href="#第四步：跳转到redis解压目录下" class="headerlink" title="第四步：跳转到redis解压目录下"></a>第四步：跳转到redis解压目录下</h3><p>cd redis-5.0.5</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop local]# cd redis-5.0.5</span><br></pre></td></tr></table></figure>

<h3 id="第五步：编译安装"><a href="#第五步：编译安装" class="headerlink" title="第五步：编译安装"></a>第五步：编译安装</h3><p>make MALLOC=libc　　</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop redis-5.0.5]# make MALLOC=libc</span><br></pre></td></tr></table></figure>

<p>cd src &amp;&amp; make install</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop redis-5.0.5]# cd src &amp;&amp; make install</span><br><span class="line">    CC Makefile.dep</span><br><span class="line"></span><br><span class="line">Hint: It's a good idea to run 'make test' ;)</span><br><span class="line"></span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br><span class="line">    INSTALL install</span><br></pre></td></tr></table></figure>

<h3 id="第六步：修改配置文件"><a href="#第六步：修改配置文件" class="headerlink" title="第六步：修改配置文件"></a>第六步：修改配置文件</h3><p>修改redis.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置端口号</span></span><br><span class="line">prot 16379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 允许后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件保存位置</span></span><br><span class="line">logfile /home/hadoop/tmp/redis.log</span><br></pre></td></tr></table></figure>



<h3 id="第七步：设置redis服务"><a href="#第七步：设置redis服务" class="headerlink" title="第七步：设置redis服务"></a>第七步：设置redis服务</h3><p>1、在/etc目录下新建redis目录</p>
<p>mkdir redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop etc]# mkdir redis</span><br></pre></td></tr></table></figure>

<p>2、将/home/hadoop/app/redis-5.0.5/redis.conf 文件复制一份到/etc/redis目录下，并命名为6379.conf　　</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop redis]# cp /home/hadoop/app/redis-5.0.5/redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure>

<p>3、将redis的启动脚本复制一份放到/etc/init.d目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop init.d]# cp /home/hadoop/app/redis-5.0.5/utils/redis_init_script /etc/init.d/redisd</span><br></pre></td></tr></table></figure>

<p>4、设置redis开机自启动</p>
<p>先切换到/etc/init.d目录下</p>
<p>然后执行自启命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop init.d]# chkconfig redisd on</span><br><span class="line">service redisd does not support chkconfig</span><br></pre></td></tr></table></figure>

<p>看结果是redisd不支持chkconfig</p>
<p>解决方法：</p>
<p>使用vim编辑redisd文件，在第一行加入如下两行注释，保存退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chkconfig:   2345 90 10</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> description:  Redis is a persistent key-value database</span></span><br></pre></td></tr></table></figure>

<p>注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。</p>
<p>再次执行开机自启命令，成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop init.d]# chkconfig redisd on</span><br></pre></td></tr></table></figure>

<p>现在可以直接已服务的形式启动和关闭redis了</p>
<p>启动：</p>
<p>service redisd start　</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop ~]# service redisd start</span><br><span class="line">Starting Redis server...</span><br><span class="line">2288:C 13 Dec 13:51:38.087 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">2288:C 13 Dec 13:51:38.087 # Redis version=4.0.6, bits=64, commit=00000000, modified=0, pid=2288, just started</span><br><span class="line">2288:C 13 Dec 13:51:38.087 # Configuration loaded</span><br></pre></td></tr></table></figure>

<p>关闭：</p>
<p>方法1：service redisd stop</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop ~]# service redisd stop</span><br><span class="line">Stopping ...</span><br><span class="line">Redis stopped</span><br></pre></td></tr></table></figure>

<p>方法2：redis-cli SHUTDOWN</p>
<p>如果出现如下问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@hadoop ~]# service redisd start</span><br><span class="line">/var/run/redis_6379.pid exists, process is already running or crashed</span><br></pre></td></tr></table></figure>

<p>可参考资料：<a href="http://blog.csdn.net/luozhonghua2014/article/details/54649295" target="_blank" rel="noopener">http://blog.csdn.net/luozhonghua2014/article/details/54649295</a></p>
<h3 id="开启客户端"><a href="#开启客户端" class="headerlink" title="开启客户端"></a>开启客户端</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本机启动</span></span><br><span class="line">./redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定端口和主机启动</span></span><br><span class="line">./redis-cli -p 16379 -h hadoop</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/21/kafka/2/">单节点部署三台kafka</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Kakfa/">Kakfa</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Kakfa/">Kakfa</a></span><div class="content"><ol>
<li><p>下载地址：<a href="http://archive.cloudera.com/kafka/kafka/4/kafka-2.2.1-kafka4.1.0.tar.gz" target="_blank" rel="noopener">http://archive.cloudera.com/kafka/kafka/4/kafka-2.2.1-kafka4.1.0.tar.gz</a></p>
</li>
<li><p>解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf kafka-2.2.1-kafka4.1.0.tar.gz -C ../app</span><br></pre></td></tr></table></figure>
</li>
<li><p>在部署kafka之前 ，检测zookeeper是ok的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zktest, tunan, zookeeper, kafka]</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑config/server.properties文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">broker.id=0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">log.dirs=/tmp/kafka-logs</span></span><br><span class="line"></span><br><span class="line">broker.id=0</span><br><span class="line">host.name=hadoop</span><br><span class="line">port=9090</span><br><span class="line">log.dirs=/home/hadoop/tmp/kafka-logs00</span><br><span class="line">zookeeper.connect=hadoop:2181/kafka</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制Kafka文件夹为三份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -R kafka_2.11-2.2.1-kafka-4.1.0/ kafka01</span><br><span class="line">cp -R kafka_2.11-2.2.1-kafka-4.1.0/ kafka02</span><br><span class="line">mv  kafka_2.11-2.2.1-kafka-4.1.0/ kafka03</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改kafka02的config/server.properties文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">broker.id=1</span><br><span class="line">host.name=hadoop</span><br><span class="line">port=9091</span><br><span class="line">log.dirs=/home/hadoop/tmp/kafka-logs01</span><br><span class="line">zookeeper.connect=hadoop:2181/kafka</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改kafka03的config/server.properties文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">broker.id=2</span><br><span class="line">host.name=hadoop</span><br><span class="line">port=9092</span><br><span class="line">log.dirs=/home/hadoop/tmp/kafka-logs02</span><br><span class="line">zookeeper.connect=hadoop:2181/kafka</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动(三台都需要输入命令)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建topic</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-topics.sh \</span><br><span class="line">--create \</span><br><span class="line">--zookeeper hadoop:2181/kafka \</span><br><span class="line">--partitions 3 \</span><br><span class="line">--replication-factor 2 \</span><br><span class="line">--topic test</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看topic</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-topics.sh \</span><br><span class="line">--list \</span><br><span class="line">--zookeeper hadoop:2181/kafka</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定topic的状况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-topics.sh \</span><br><span class="line">--describe \</span><br><span class="line">--zookeeper hadoop:2181/kafka \</span><br><span class="line">--topic test</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p>启动生产者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-console-producer.sh \</span><br><span class="line">--broker-list hadoop:9090,hadoop:9091,hadoop:9092 \</span><br><span class="line">--topic test</span><br></pre></td></tr></table></figure>

<p>启动消费者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh \</span><br><span class="line">--bootstrap-server hadoop:9090,hadoop:9091,hadoop:9092 \</span><br><span class="line">--from-beginning \</span><br><span class="line">--topic test</span><br></pre></td></tr></table></figure>

<p>发送数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">a</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接收数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">a</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭kafka集群(每台都要执行)</p>
<p>修改kafka-server-stop.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PIDS=$(ps ax | grep -i 'kafka\.Kafka' | grep java | grep -v grep | awk '&#123;print $1&#125;')</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PIDS=$(jps -lm | grep -i 'kafka'| awk '&#123;print $1&#125;')</span><br></pre></td></tr></table></figure>

<p><strong>命令详解：</strong>使用jps -lm命令列出所有的java进程，然后通过管道，利用grep -i ‘kafka.Kafka’命令将kafka进程筛出来，最后再接一管道命令，利用awk将进程号取出来。</p>
<p>分别执行kafka-server-stop.sh</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/20/spark/20/">Spark Streaming简介&amp;Spark Streaming的内部结构&amp;StreamingContext对象&amp;离散流（DStream）&amp;IDEA开发Spark Streaming</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><hr>
<p>参考博客: <a href="https://vinxikk.github.io/2018/05/29/spark/" target="_blank" rel="noopener">https://vinxikk.github.io/2018/05/29/spark/</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>Spark Streaming简介</li>
<li>Spark Streaming的内部结构</li>
<li>StreamingContext对象</li>
<li>离散流（DStream）</li>
<li>IDEA开发Spark Streaming</li>
</ol>
<h2 id="Spark-Streaming简介"><a href="#Spark-Streaming简介" class="headerlink" title="Spark Streaming简介"></a>Spark Streaming简介</h2><p>Spark Streaming是核心Spark API的扩展，实现<strong>可扩展</strong>、<strong>高吞吐量</strong>、<strong>可容错的实时数据流处理</strong>。数据可以从诸如Kafka，Flume，Kinesis或TCP套接字等众多来源获取，并且可以使用由高级函数（如map，reduce，join和window）开发的复杂算法进行流数据处理。最后，处理后的数据可以被推送到文件系统，数据库和实时仪表板。而且还可以在数据流上应用Spark提供的机器学习和图处理算法。</p>
<p><img src="https://yerias.github.io/spark_img/what-is-spark-streaming.png" alt="what-is-spark-streaming"></p>
<h2 id="Spark-Streaming的内部结构"><a href="#Spark-Streaming的内部结构" class="headerlink" title="Spark Streaming的内部结构"></a>Spark Streaming的内部结构</h2><p>在内部，它的工作原理如下。Spark Streaming接收实时输入数据流，并将数据切分成批，然后由Spark引擎对其进行处理，最后生成“批”形式的结果流。</p>
<p><img src="https://yerias.github.io/spark_img/streaming-batch-process.png" alt="streaming-batch-process"></p>
<p>Spark Streaming将连续的数据流抽象为discretizedstream(DStream)。在内部，DStream由一个RDD序列表示。</p>
<h2 id="StreamingContext对象"><a href="#StreamingContext对象" class="headerlink" title="StreamingContext对象"></a>StreamingContext对象</h2><p>初始化<code>StreamingContext</code>：</p>
<p>方式一，从<code>SparkConf</code>对象中创建：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Context对象：StreamingContext</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"MyNetworkWordCount"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line"><span class="comment">//指定批处理的时间间隔</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>方式二，从现有的<code>SparkContext</code>实例中创建：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc, <span class="type">Seconds</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>appName参数是应用程序在集群UI上显示的名称。</li>
<li>master是Spark，Mesos或YARN集群的URL，或者一个特殊的<code>“local [*]”</code>字符串来让程序以本地模式运行。</li>
<li>当在集群上运行程序时，不需要在程序中硬编码master参数，而是使用spark-submit提交应用程序并将master的URL以脚本参数的形式传入。但是，对于本地测试和单元测试，您可以通过<code>“local[*]”</code>来运行Spark Streaming程序（请确保本地系统中的cpu核心数够用）。</li>
<li><code>StreamingContext</code>会内在的创建一个<code>SparkContext</code>的实例（所有Spark功能的起始点），你可以通过<code>ssc.sparkContext</code>访问到这个实例。</li>
<li>批处理的时间窗口长度必须根据应用程序的延迟要求和可用的集群资源进行设置。</li>
</ul>
<p>注意：</p>
<ul>
<li>一旦一个<code>StreamingContext</code>开始运作，就不能设置或添加新的流计算。</li>
<li>一旦一个上下文被停止，它将无法重新启动。</li>
<li>同一时刻，一个JVM中只能有一个<code>StreamingContext</code>处于活动状态。</li>
<li><code>StreamingContext</code>上的<code>stop()</code>方法也会停止<code>SparkContext</code>。 要仅停止<code>StreamingContext</code>（保持<code>SparkContext</code>活跃），请将<code>stop()</code> 方法的可选参数<code>stopSparkContext</code>设置为<code>false</code>。</li>
<li>只要前一个<code>StreamingContext</code>在下一个<code>StreamingContext</code>被创建之前停止（不停止<code>SparkContext</code>），<code>SparkContext</code>就可以被重用来创建多个<code>StreamingContext</code>。</li>
</ul>
<h2 id="离散流（DStream）"><a href="#离散流（DStream）" class="headerlink" title="离散流（DStream）"></a>离散流（DStream）</h2><p><code>DiscretizedStream</code>(<code>DStream</code>) 是Spark Streaming对流式数据的基本抽象。它表示连续的数据流，这些连续的数据流可以是从数据源接收的输入数据流，也可以是通过对输入数据流执行转换操作而生成的经处理的数据流。在内部，<code>DStream</code>由一系列连续的RDD表示，如下图：</p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-1.png" alt="streaming-dstream-1"></p>
<p>我们将一行行文本组成的流转换为单词流，具体做法为：将<code>flatMap</code>操作应用于名为lines的 DStream中的每个RDD上，以生成words DStream的RDD。如下图所示：</p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-2.png" alt="streaming-dstream-2"></p>
<p>但是DStream和RDD也有区别，下面画图说明：</p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-3.png" alt="streaming-dstream-3"></p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-4.png" alt="streaming-dstream-4"></p>
<h2 id="IDEA开发Spark-Streaming"><a href="#IDEA开发Spark-Streaming" class="headerlink" title="IDEA开发Spark Streaming"></a>IDEA开发Spark Streaming</h2><p>要编写自己的Spark流程序，必须将以下依赖项添加到Maven项目中。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spark-streaming_2<span class="number">.12</span>&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="SocketFile简单的单词计数"><a href="#SocketFile简单的单词计数" class="headerlink" title="SocketFile简单的单词计数"></a>SocketFile简单的单词计数</h3><ol>
<li><p>实现代scala代码逻辑</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到StreamingContext对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    dispose(ssc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启StreamingContext</span></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dispose</span></span>(ssc: <span class="type">StreamingContext</span>) = &#123;</span><br><span class="line">    <span class="comment">//输入记录</span></span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑处理</span></span><br><span class="line">    <span class="keyword">val</span> words = text.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> pair = words.map(x =&gt; (x, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> result = pair.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出记录</span></span><br><span class="line">    result.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用nc发送消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">$ nc -lk <span class="number">9100</span></span><br><span class="line"></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端接收消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1357008430000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(hello,<span class="number">1</span>)</span><br><span class="line">(world,<span class="number">1</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>DStreams 是表示从源端接收的输入数据的数据流。在这个简单的示例中，行是一个输入DStream，因为它表示从netcat服务器接收到的数据流。每个输入DStream(本节后面讨论的文件流除外)都与接收方(Scala doc、Java doc)对象相关联，接收方接收来自源的数据并将其存储在Spark内存中进行处理。</p>
<p><code>注意</code>：Spark流应用程序需要分配足够的Core来处理接收到的数据，以及运行接收方。设置core的数量要大于Receivers的数量。</p>
<h3 id="Checkpoint维护State"><a href="#Checkpoint维护State" class="headerlink" title="Checkpoint维护State"></a>Checkpoint维护State</h3><p>什么是updateStateByKey?</p>
<ul>
<li><strong>updateStateByKey</strong>(<em>func</em>)可以返回一个新“state”的DStream，其中通过对键的前一个状态和键的新值应用给定的函数来更新每个键的状态。这可以用来维护每个键的任意状态数据。</li>
</ul>
<p>什么是Checkpoint?</p>
<ul>
<li>Checkpoint可以通过在一个容错的、可靠的文件系统中设置一个目录来启用，Checkpoint信息将被保存到这个目录中。这是通过使用streamingContext.checkpoint(checkpointDirectory)实现的。</li>
</ul>
<ol>
<li><p>下面案例也是单词计数，只不过需求变成了<strong>求当天到现在为止的单词计数</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    dispose(ssc)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dispose</span></span>(ssc: <span class="type">StreamingContext</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置checkpoint目录，保存offset</span></span><br><span class="line">    ssc.checkpoint(<span class="string">"./chk"</span>)</span><br><span class="line">    <span class="comment">// updateStateByKey：维护记录的state</span></span><br><span class="line">    lines.flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).updateStateByKey(updateFunction)</span><br><span class="line">    .print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现对新值和旧值的累加</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateFunction</span></span>(newValues: <span class="type">Seq</span>[<span class="type">Int</span>], oldValues: <span class="type">Option</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> curr = newValues.sum</span><br><span class="line">    <span class="keyword">val</span> old = oldValues.getOrElse(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> count = curr + old</span><br><span class="line">    <span class="type">Some</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用nc发送消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">$ nc -lk <span class="number">9100</span></span><br><span class="line"></span><br><span class="line">a a a b b c</span><br><span class="line">a a a b b c</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端接收消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1587439170000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,<span class="number">2</span>)</span><br><span class="line">(a,<span class="number">3</span>)</span><br><span class="line">(c,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1587439175000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,<span class="number">4</span>)</span><br><span class="line">(a,<span class="number">6</span>)</span><br><span class="line">(c,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上面的代码一直运行，结果可以一直累加，但是代码一旦停止运行，再次运行时，结果会不会接着上一次进行计算，上一次的计算结果丢失了，主要原因上每次程序运行都会初始化一个程序入口，而2次运行的程序入口不是同一个入口，所以会导致第一次计算的结果丢失</p>
<p>第一次的运算结果状态保存在Driver里面，所以我们如果想用上一次的计算结果，我们需要将上一次的Driver里面的运行结果状态取出来，而上面的代码有一个checkpoint方法，它会把上一次Driver里面的运算结果状态保存在checkpoint的目录里面，我们在第二次启动程序时，从checkpoint里面取出上一次的运行结果状态，把这次的Driver状态恢复成和上一次Driver一样的状态</p>
<h3 id="Checkpoint维护State-HA"><a href="#Checkpoint维护State-HA" class="headerlink" title="Checkpoint维护State HA"></a>Checkpoint维护State HA</h3><p>以下代码参考<a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#checkpointing" target="_blank" rel="noopener">官网</a></p>
<p>如果想让应用程序从驱动程序故障中恢复，我们应该重写代码，让它具备下面的功能</p>
<ul>
<li>当程序第一次启动时，它将创建一个新的StreamingContext，设置所有的流，然后调用start()。</li>
<li>当程序在失败后重新启动时，它将从Checkpoint目录中的Checkpoint数据重新创建一个StreamingContext。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> checkpoint = <span class="string">"./chk_v2"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到StreamingContext</span></span><br><span class="line">    <span class="keyword">val</span> ssc  = <span class="type">StreamingContext</span>.getOrCreate(checkpoint, functionToCreateContext)</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建StreamingContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionToCreateContext</span></span>(): <span class="type">StreamingContext</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">50000</span>))   <span class="comment">// new context</span></span><br><span class="line"></span><br><span class="line">    dispose(ssc)</span><br><span class="line"></span><br><span class="line">    ssc.checkpoint(checkpoint)   <span class="comment">// set checkpoint directory</span></span><br><span class="line">    ssc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理具题的业务逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dispose</span></span>(ssc: <span class="type">StreamingContext</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>) <span class="comment">// create DStreams</span></span><br><span class="line"></span><br><span class="line">    lines</span><br><span class="line">    .flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    .map((_, <span class="number">1</span>))</span><br><span class="line">    .updateStateByKey(updateFunction)</span><br><span class="line">    .print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新state</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateFunction</span></span>(newValues: <span class="type">Seq</span>[<span class="type">Int</span>], oldValues: <span class="type">Option</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> curr = newValues.sum</span><br><span class="line">    <span class="keyword">val</span> old = oldValues.getOrElse(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> count = curr + old</span><br><span class="line">    <span class="type">Some</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码中维护State的方法"><a href="#源码中维护State的方法" class="headerlink" title="源码中维护State的方法"></a>源码中维护State的方法</h3><p>在阅读源码中的Example模块下Streaming下的StatefulNetworkWordCount object时，发现了一种维护State的写法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存checkpoint</span></span><br><span class="line"><span class="keyword">val</span> checkpoint = <span class="string">"./chk_v3"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 拿到 StreamingContext</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="type">StreamingContext</span>.getOrCreate(checkpoint, functionToCreateContext)</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 StreamingContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionToCreateContext</span></span>(): <span class="type">StreamingContext</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    ssc.checkpoint(checkpoint)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对记录做累加操作</span></span><br><span class="line">    <span class="keyword">val</span> mappingFunc = (word: <span class="type">String</span>, one: <span class="type">Option</span>[<span class="type">Int</span>], state: <span class="type">State</span>[<span class="type">Int</span>]) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(state.isTimingOut())&#123;</span><br><span class="line">            println(<span class="string">"超时3秒没拿到数据"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">val</span> sum = one.getOrElse(<span class="number">0</span>) + state.getOption.getOrElse(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">val</span> output = (word, sum)</span><br><span class="line">            state.update(sum)</span><br><span class="line">            output</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑处理</span></span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>)</span><br><span class="line">    lines</span><br><span class="line">    .flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    .map((_,<span class="number">1</span>))</span><br><span class="line">    .mapWithState(<span class="type">StateSpec</span>.function(mappingFunc)</span><br><span class="line">                  .timeout(<span class="type">Seconds</span>(<span class="number">3</span>))</span><br><span class="line">                 ).print()</span><br><span class="line"></span><br><span class="line">    ssc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/20/spark/19/">Idea加载Spark源码，并且在控制台查询SQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><ol>
<li><p>下载Spark源码</p>
<p>本次案例，我们使用Apche版本，版本为：spark-2.4.5</p>
<p>下载链接：<a href="https://github.com/apache/spark" target="_blank" rel="noopener">https://github.com/apache/spark</a></p>
<p><em>20200421更新：</em></p>
<p>一般使用spark对应版本的scala编译最好，如果使用不同版本的scala编译，需要修改主pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.12.10<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译Spark源码</p>
<p>在编译Spark源码之前，需要修改一些东西，原因是scope规定provided会报ClassNotFoundException</p>
<ul>
<li><p>修改hive-thriftserver模块下的pom.xm文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-continuation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-servlets<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-proxy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-util<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--       &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果还有其他类似的ClassNotFoundException，都是这个原因引起的，注释即可</p>
</li>
</ul>
<p>使用<code>git-bash</code>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -DskipTests=true</span><br><span class="line"></span><br><span class="line">## 经过漫长的等待，出现如下界面时，表示编译成功(忘记保留了，这里先用hive的)</span><br><span class="line">[INFO] Reactor Summary:</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] Hive 1.1.0-cdh5.16.2 ............................... SUCCESS [  3.119 s]</span><br><span class="line">[INFO] Hive Classifications ............................... SUCCESS [  2.406 s]</span><br><span class="line">[INFO] Hive Shims Common .................................. SUCCESS [  3.327 s]</span><br><span class="line">[INFO] Hive Shims 0.23 .................................... SUCCESS [  3.494 s]</span><br><span class="line">[INFO] Hive Shims Scheduler ............................... SUCCESS [  2.423 s]</span><br><span class="line">[INFO] Hive Shims ......................................... SUCCESS [  1.463 s]</span><br><span class="line">[INFO] Hive Common ........................................ SUCCESS [  8.382 s]</span><br><span class="line">[INFO] Hive Serde ......................................... SUCCESS [  8.001 s]</span><br><span class="line">[INFO] Hive Metastore ..................................... SUCCESS [ 28.285 s]</span><br><span class="line">[INFO] Hive Ant Utilities ................................. SUCCESS [  1.668 s]</span><br><span class="line">[INFO] Spark Remote Client ................................ SUCCESS [  4.915 s]</span><br><span class="line">[INFO] Hive Query Language ................................ SUCCESS [01:36 min]</span><br><span class="line">[INFO] Hive Service ....................................... SUCCESS [ 22.921 s]</span><br><span class="line">[INFO] Hive Accumulo Handler .............................. SUCCESS [  5.496 s]</span><br><span class="line">[INFO] Hive JDBC .......................................... SUCCESS [  5.797 s]</span><br><span class="line">[INFO] Hive Beeline ....................................... SUCCESS [  3.957 s]</span><br><span class="line">[INFO] Hive CLI ........................................... SUCCESS [  4.060 s]</span><br><span class="line">[INFO] Hive Contrib ....................................... SUCCESS [  4.321 s]</span><br><span class="line">[INFO] Hive HBase Handler ................................. SUCCESS [  5.518 s]</span><br><span class="line">[INFO] Hive HCatalog ...................................... SUCCESS [  1.399 s]</span><br><span class="line">[INFO] Hive HCatalog Core ................................. SUCCESS [  5.933 s]</span><br><span class="line">[INFO] Hive HCatalog Pig Adapter .......................... SUCCESS [  4.632 s]</span><br><span class="line">[INFO] Hive HCatalog Server Extensions .................... SUCCESS [  4.477 s]</span><br><span class="line">[INFO] Hive HCatalog Webhcat Java Client .................. SUCCESS [  4.903 s]</span><br><span class="line">[INFO] Hive HCatalog Webhcat .............................. SUCCESS [  7.452 s]</span><br><span class="line">[INFO] Hive HCatalog Streaming ............................ SUCCESS [  4.306 s]</span><br><span class="line">[INFO] Hive HWI ........................................... SUCCESS [  3.461 s]</span><br><span class="line">[INFO] Hive ODBC .......................................... SUCCESS [  3.061 s]</span><br><span class="line">[INFO] Hive Shims Aggregator .............................. SUCCESS [  0.840 s]</span><br><span class="line">[INFO] Hive TestUtils ..................................... SUCCESS [  1.077 s]</span><br><span class="line">[INFO] Hive Packaging 1.1.0-cdh5.16.2 ..................... SUCCESS [  4.194 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 04:22 min</span><br><span class="line">[INFO] Finished at: 2020-04-12T18:50:46+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
</li>
<li><p>将源码导入IDEA </p>
<p>源码以Maven方式，导入IDEA后，等待依赖加载完成</p>
<p>在编译之前需要删除spark-sql下的test包下的streaming包，不然会在<code>Build Project</code>时进入这里，引起<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>异常</p>
<p>点击<code>Build Project</code>编译</p>
</li>
</ol>
<h3 id="本地调试Spark-SQL"><a href="#本地调试Spark-SQL" class="headerlink" title="本地调试Spark SQL"></a>本地调试Spark SQL</h3><ol>
<li><p>找到<code>hive-thriftserver</code>模块，在<code>main</code>下，新建<code>resources</code>目录，并标记为资源目录</p>
</li>
<li><p>拷贝集群上如下配置文件到<code>resources</code>目录中</p>
<p>hive-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.header<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.current.db<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.uris<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>thrift://hadoop:9083<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>指向的是运行metastore服务的主机<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器需启动 metastore 服务</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">hive --service metastore &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>SparkSQLCLIDriver</code></p>
<p>在运行之前，需要在VM options中添加参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-<span class="type">Dspark</span>.master=local[<span class="number">2</span>] -<span class="type">Djline</span>.<span class="type">WindowsTerminal</span>.directConsole=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>控制台输出如下信息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Spark</span> master: local[<span class="number">2</span>], <span class="type">Application</span> <span class="type">Id</span>: local<span class="number">-1587372819248</span></span><br><span class="line">spark-sql (<span class="keyword">default</span>)&gt; show databases;</span><br><span class="line">show databases;</span><br><span class="line">databaseName</span><br><span class="line">access_dw</span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">offline_dw</span><br><span class="line">store_format</span><br></pre></td></tr></table></figure>




</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/18/error/6/">Error: java.io.IOException: Invalid LZO header</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Error/">Error</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Error/">Error</a></span><div class="content"><p>在使用Flume传输数据的时候，需要注意几个字段</p>
<p>我们这里使用的是flume传输到hdfs</p>
<p>参数：hdfs.fileType 指定的数据传输类型，默认SequenceFile，如果直接传输本文本数据，则会乱码。在传输文本数据的时候它的值要修改为DataStream</p>
<p>而现在根据我们的错误提示就知道我们使用了Lzo压缩，所以需要把它的值修改为CompressedStream，即可解决问题。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>hdfs.fileType</td>
<td>SequenceFile</td>
<td>File format: currently <code>SequenceFile</code>, <code>DataStream</code> or <code>CompressedStream</code> (1)DataStream will not compress output file and please don’t set codeC (2)CompressedStream requires set hdfs.codeC with an available codeC</td>
</tr>
</tbody></table>
<hr>
<p>还需要注意的一个参数是：hdfs.codeC ，在使用flume时，可以将数据压缩输出，它的值可选为gzip, bzip2, lzo, lzop, snappy</p>
<p>lzop的后缀是lzo</p>
<p>lzo的后缀是lzp.default</p>
<hr>
<p>还是要熟悉一下flume的文档。。。<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#hdfs-sink" target="_blank" rel="noopener">hdfs</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/16/spark/18/">自定义外部Text数据源</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>这里接着上次的解读jdbc数据源，现在我们自己实现一个text的外部数据源</p>
<hr>
<ol>
<li><p>创建DefaultSource类实现RelationProviderTrait，注意这里的类名必须是DefaultSource，源码中写死了</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultSource</span>  <span class="keyword">extends</span> <span class="title">RelationProvider</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(sqlContext: <span class="type">SQLContext</span>, parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span> = &#123;</span><br><span class="line">      <span class="comment">//拿到client传入的参数path</span></span><br><span class="line">    <span class="keyword">val</span> path = parameters.get(<span class="string">"path"</span>)</span><br><span class="line">      <span class="comment">//判断path是否存在</span></span><br><span class="line">    path <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(p) =&gt;<span class="keyword">new</span> <span class="type">TextDataSourceRelation</span>(sqlContext,p)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"path is required ..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义Relation，继承BashRelation和TableScan，拿到Schema和RDD[Row]</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextDataSourceRelation</span>(<span class="params">context:<span class="type">SQLContext</span>,path:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">BaseRelation</span> <span class="keyword">with</span> <span class="title">TableScan</span> <span class="keyword">with</span> <span class="title">Logging</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span> = context</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//重写StructType接口的方式实现Schema</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">schema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>&#123;</span><br><span class="line">    <span class="type">List</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"id"</span>,<span class="type">StringType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"name"</span>,<span class="type">StringType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"sex"</span>,<span class="type">StringType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"sal"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"comm"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写buildScan拿到RDD[Row]</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">      <span class="comment">//拿到文本数据</span></span><br><span class="line">    <span class="keyword">val</span> textRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sqlContext.sparkContext.textFile(path)</span><br><span class="line">      <span class="comment">//拿到每个StructField</span></span><br><span class="line">    <span class="keyword">val</span> schemaField: <span class="type">Array</span>[<span class="type">StructField</span>] = schema.fields</span><br><span class="line">      <span class="comment">//对每行数据逗号切分，并且去掉空格，返回集合</span></span><br><span class="line">    textRDD.map(_.split(<span class="string">","</span>).map(_.trim))</span><br><span class="line">      <span class="comment">//对集合中的每个元素操作，通过zipWithIndex算子可以拿到元素的内容和对应的索引号</span></span><br><span class="line">      .map(row =&gt; row.zipWithIndex.map &#123;</span><br><span class="line">          <span class="comment">//模式匹配，拿到了value和index，然后对其做操作</span></span><br><span class="line">        <span class="keyword">case</span> (value, index) =&gt; &#123;</span><br><span class="line">            <span class="comment">//通过schemaField和index拿到列名</span></span><br><span class="line">          <span class="keyword">val</span> columnName = schemaField(index).name</span><br><span class="line">            <span class="comment">//判断当前的列名是否是sex，并在工具类中做匹配，对value转换类型</span></span><br><span class="line">          <span class="type">Utils</span>.caseTo(<span class="keyword">if</span> (columnName.equalsIgnoreCase(<span class="string">"sex"</span>)) &#123;</span><br><span class="line">              <span class="comment">//如果列名是sex，列下元素是1、2或者3，则返回对应的字符</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="string">"1"</span>) &#123;</span><br><span class="line">              <span class="string">"男"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="string">"2"</span>) &#123;</span><br><span class="line">              <span class="string">"女"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="string">"未知"</span></span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//如果列名不是sex，则直接返回元素</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value</span><br><span class="line">              <span class="comment">//传入dataType的类型，在工具类中做匹配，使value与schema的类型一致</span></span><br><span class="line">          &#125;, schemaField(index).dataType)</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//结果是个集合，转换成RDD[Row]</span></span><br><span class="line">      &#125;).map(x =&gt; <span class="type">Row</span>.fromSeq(x))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义Utils类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">caseTo</span></span>(value:<span class="type">String</span>,dataType: <span class="type">DataType</span>) =&#123;</span><br><span class="line">      <span class="comment">//模式匹配，转换value的类型</span></span><br><span class="line">    dataType <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _:<span class="type">DoubleType</span> =&gt; value.toDouble</span><br><span class="line">      <span class="keyword">case</span> _:<span class="type">LongType</span> =&gt; value.toLong</span><br><span class="line">      <span class="keyword">case</span> _:<span class="type">StringType</span> =&gt; value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .master(<span class="string">"local[2]"</span>)</span><br><span class="line">      .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> textDF: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"com.tunan.spark.sql.extds.text"</span>).load(<span class="string">"tunan-spark-sql/extds"</span>)</span><br><span class="line"></span><br><span class="line">    textDF.printSchema()</span><br><span class="line">    textDF.show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- id: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- name: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- sex: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- sal: double (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- comm: double (nullable = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">ERROR</span> <span class="type">TextDataSourceRelation</span>: 进入buildScan方法</span><br><span class="line">+---+----+----+-------+------+</span><br><span class="line">| id|name| sex|    sal|  comm|</span><br><span class="line">+---+----+----+-------+------+</span><br><span class="line">|  <span class="number">1</span>|张三|  男|<span class="number">10000.0</span>|<span class="number">1000.0</span>|</span><br><span class="line">|  <span class="number">2</span>|李四|  男|<span class="number">12000.0</span>|<span class="number">2000.0</span>|</span><br><span class="line">|  <span class="number">3</span>|王五|  女|<span class="number">12500.0</span>|<span class="number">1000.0</span>|</span><br><span class="line">|  <span class="number">4</span>|赵六|未知|<span class="number">20000.0</span>|<span class="number">2000.0</span>|</span><br><span class="line">|  <span class="number">5</span>|图南|  男|<span class="number">21000.0</span>|<span class="number">1000.0</span>|</span><br><span class="line">|  <span class="number">6</span>|小七|  女|<span class="number">10000.0</span>|<span class="number">1500.0</span>|</span><br><span class="line">+---+----+----+-------+------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/">&lt;&lt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/">&gt;&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>