<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BigData Developer"><meta name="keywords" content="yerias,TUNANのBlog,BigData"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">129</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">TUNANのBlog</div><div id="site-sub-title">感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/25/linux/shell/4/">Shell的数组</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/Shell/">Shell</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Shell/">Shell</a></span><div class="content"><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。</p>
<p>与大部分编程语言类似，数组元素的下标由0开始。</p>
<p>Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br></pre></td></tr></table></figure>

<p>我们也可以使用下标来定义数组:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure>

<h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><p>读取数组元素值的一般格式是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">my_array=(A B "C" D)</span><br><span class="line"></span><br><span class="line">echo "第一个元素为: $&#123;my_array[0]&#125;"</span><br><span class="line">echo "第二个元素为: $&#123;my_array[1]&#125;"</span><br><span class="line">echo "第三个元素为: $&#123;my_array[2]&#125;"</span><br><span class="line">echo "第四个元素为: $&#123;my_array[3]&#125;"</span><br></pre></td></tr></table></figure>

<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">第一个元素为: A</span><br><span class="line">第二个元素为: B</span><br><span class="line">第三个元素为: C</span><br><span class="line">第四个元素为: D</span><br></pre></td></tr></table></figure>

<h3 id="获取数组中的所有元素"><a href="#获取数组中的所有元素" class="headerlink" title="获取数组中的所有元素"></a>获取数组中的所有元素</h3><p>使用@ 或 * 可以获取数组中的所有元素，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line">echo "数组的元素为: $&#123;my_array[*]&#125;"</span><br><span class="line">echo "数组的元素为: $&#123;my_array[@]&#125;"</span><br></pre></td></tr></table></figure>

<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组的元素为: A B C D</span><br></pre></td></tr></table></figure>

<h3 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h3><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[*]&#125;"</span><br><span class="line">echo "数组元素个数为: $&#123;#my_array[@]&#125;"</span><br></pre></td></tr></table></figure>

<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">数组元素个数为: 4</span><br><span class="line">数组元素个数为: 4</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/24/linux/shell/3/">Shell的参数传递</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/Shell/">Shell</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Shell/">Shell</a></span><div class="content"><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例我们向脚本传递三个参数，并分别输出，其中 <strong>$0</strong> 为执行的文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "Shell 传递参数实例！";</span><br><span class="line">echo "执行的文件名：$0";</span><br><span class="line">echo "第一个参数为：$1";</span><br><span class="line">echo "第二个参数为：$2";</span><br><span class="line">echo "第三个参数为：$3";</span><br></pre></td></tr></table></figure>

<p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh 1 2 3</span></span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure>

<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th align="left">参数处理</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$#</td>
<td align="left">传递到脚本的参数个数</td>
</tr>
<tr>
<td align="left">$*</td>
<td align="left">以一个单字符串显示所有向脚本传递的参数。 如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td align="left">$$</td>
<td align="left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="left">$!</td>
<td align="left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="left">$@</td>
<td align="left">与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td>
</tr>
<tr>
<td align="left">$-</td>
<td align="left">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td align="left">$?</td>
<td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "Shell 传递参数实例！";</span><br><span class="line">echo "第一个参数为：$1";</span><br><span class="line"></span><br><span class="line">echo "参数个数为：$#";</span><br><span class="line">echo "传递的参数作为一个字符串显示：$*";</span><br></pre></td></tr></table></figure>

<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh 1 2 3</span></span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">第一个参数为：1</span><br><span class="line">参数个数为：3</span><br><span class="line">传递的参数作为一个字符串显示：1 2 3</span><br></pre></td></tr></table></figure>

<p>$* 与 $@ 区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "-- \$* 演示 ---"</span><br><span class="line">for i in "$*"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "-- \$@ 演示 ---"</span><br><span class="line">for i in "$@"; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>执行脚本，输出结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh 1 2 3</span></span><br><span class="line">-- $* 演示 ---</span><br><span class="line">1 2 3</span><br><span class="line">-- $@ 演示 ---</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/23/linux/shell/2/">Shell的字符串</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/Shell/">Shell</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Shell/">Shell</a></span><div class="content"><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p>
<h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str='this is a string'</span><br></pre></td></tr></table></figure>

<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li>
</ul>
<h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name='runoob'</span><br><span class="line">str="Hello, I know you are \"$your_name\"! \n"</span><br><span class="line">echo -e $str</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello, I know you are "runoob"!</span><br></pre></td></tr></table></figure>

<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name="runoob"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用双引号拼接</span></span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, $&#123;your_name&#125; !"</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用单引号拼接</span></span><br><span class="line">greeting_2='hello, '$your_name' !'</span><br><span class="line">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class="line">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure>

<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string="abcd"</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure>

<h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><p>以下实例从字符串第 <strong>2</strong> 个字符开始截取 <strong>4</strong> 个字符：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string="runoob is a great site"</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure>

<h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string="runoob is a great site"</span><br><span class="line">echo `expr index "$string" io`  # 输出 4</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 以上脚本中 <strong>`</strong> 是反引号，而不是单引号 <strong>‘</strong>，不要看错了哦。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/22/linux/shell/1/">Shell的变量</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/Shell/">Shell</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Shell/">Shell</a></span><div class="content"><h3 id="第一个Shell脚本"><a href="#第一个Shell脚本" class="headerlink" title="第一个Shell脚本"></a>第一个Shell脚本</h3><p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p>
<p>输入一些代码，第一行一般是这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "Hello World !"</span><br></pre></td></tr></table></figure>

<p><code>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</code></p>
<p>echo 命令用于向窗口输出文本。</p>
<h3 id="运行-Shell-脚本的两种方法"><a href="#运行-Shell-脚本的两种方法" class="headerlink" title="运行 Shell 脚本的两种方法"></a>运行 Shell 脚本的两种方法</h3><ol>
<li><p>作为可执行程序</p>
<p>将上面的代码保存为 test.sh，并 cd 到相应目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure>

<p>注意，一定要写成 <strong>./test.sh</strong>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p>
</li>
<li><p>作为解释器参数</p>
<p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure>

<p>这种方式运行的脚本，可以省略第一行指定解释器信息。</p>
</li>
</ol>
<h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name="runoob.com"</span><br></pre></td></tr></table></figure>

<p>注意，<code>变量名和等号之间不能有空格</code>，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>
</ul>
<p>有效的 Shell 变量名示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUNOOB</span><br><span class="line">LD_LIBRARY_PATH</span><br><span class="line">_var</span><br><span class="line">var2</span><br></pre></td></tr></table></figure>

<p>无效的变量命名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">?var=123</span><br><span class="line">user*name=runoob</span><br></pre></td></tr></table></figure>

<p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br></pre></td></tr></table></figure>

<p>以上语句将 /etc 下目录的文件名循环出来。</p>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name="qinjx"</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure>

<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo "I am good at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>
<p>推荐给所有变量加上花括号，这是个好的编程习惯。</p>
<p>已定义的变量，可以被重新定义，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name="tom"</span><br><span class="line">echo $your_name</span><br><span class="line">your_name="alibaba"</span><br><span class="line">echo $your_name</span><br></pre></td></tr></table></figure>

<p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name=”alibaba”，使用变量的时候才加美元符（$）。</p>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>下面的例子尝试更改只读变量，结果报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">myUrl="http://www.google.com"</span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl="http://www.runoob.com"</span><br></pre></td></tr></table></figure>

<p>运行脚本，结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is read only.</span><br></pre></td></tr></table></figure>

<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>使用 unset 命令可以删除变量。语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure>

<p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<p>实例: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">myUrl="http://www.runoob.com"</span><br><span class="line">unset myUrl</span><br><span class="line">echo $myUrl</span><br></pre></td></tr></table></figure>

<p>以上实例执行将没有任何输出。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/21/linux/5/">后台执行、crontab调度和软连接的使用场景</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DataWarehouse/">DataWarehouse</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span><div class="content"><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>整理 后台执行脚本</li>
<li>整理 rundeck 视频 部署</li>
<li>整理 crontab 每隔10s</li>
<li>整理 软连接 场景 坑</li>
</ol>
<h3 id="整理后台执行脚本"><a href="#整理后台执行脚本" class="headerlink" title="整理后台执行脚本"></a>整理后台执行脚本</h3><p>后台执行后命令有三个，分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./test.sh &amp;</span><br><span class="line">nohup ./test.sh &amp; </span><br><span class="line">nohup ./test.sh &gt; /root/test.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>一般使用第三条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# nohup ./show.sh &gt;&gt; ./show.log 2&gt;&amp;1 &amp;　　　　#输出重定向</span><br><span class="line">[4] 18637</span><br><span class="line">[root@aliyun ~]# </span><br><span class="line">[root@aliyun ~]# tail -F show.log 　　　　#实时接收输出内容</span><br><span class="line">nohup: ignoring input</span><br><span class="line">Thu Nov 21 17:07:58 CST 2019</span><br><span class="line">Thu Nov 21 17:08:08 CST 2019</span><br><span class="line">Thu Nov 21 17:08:18 CST 2019</span><br><span class="line">Thu Nov 21 17:08:28 CST 2019</span><br><span class="line">Thu Nov 21 17:08:48 CST 2019</span><br></pre></td></tr></table></figure>

<h3 id="整理-rundeck-视频-部署"><a href="#整理-rundeck-视频-部署" class="headerlink" title="整理 rundeck 视频 部署"></a>整理 rundeck 视频 部署</h3><p><a href="https://www.bilibili.com/video/av35466584?from=search&amp;seid=1197620829255678947" target="_blank" rel="noopener">https://www.bilibili.com/video/av35466584?from=search&amp;seid=1197620829255678947</a></p>
<h3 id="整理-crontab-每隔10s"><a href="#整理-crontab-每隔10s" class="headerlink" title="整理 crontab 每隔10s"></a>整理 crontab 每隔10s</h3><p>Linux自带的任务调度工具 crontab 的调度单位分别是 分、时、日、周、月 最小的划分粒度是分钟，因此不能解决秒级别的调度问题，</p>
<p>* 代表每次，如 * / 6 代表每6分钟执行一次</p>
<p>但是换一种思路，我可以把调度代码包在循环体中，这个循环体执行6次，每次sleep 10s ，加起来就是分钟，即每分钟执行6次，每次间隔10秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">for((i=0;i&lt;6;i++));</span><br><span class="line">do</span><br><span class="line">        date</span><br><span class="line">        sleep 10s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这样打印出来的结果是间隔10秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ./show.sh </span><br><span class="line">Thu Nov 21 17:19:23 CST 2019</span><br><span class="line">Thu Nov 21 17:19:33 CST 2019</span><br><span class="line">Thu Nov 21 17:19:43 CST 2019</span><br><span class="line">Thu Nov 21 17:19:53 CST 2019</span><br><span class="line">Thu Nov 21 17:20:03 CST 2019</span><br><span class="line">Thu Nov 21 17:20:13 CST 2019</span><br></pre></td></tr></table></figure>

<h3 id="4-整理-软连接-场景-坑"><a href="#4-整理-软连接-场景-坑" class="headerlink" title="4.整理 软连接 场景 坑"></a>4.整理 软连接 场景 坑</h3><p>软连接的使用: ln -s 源文件路径 目标文件路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ln -s test.txt test</span><br><span class="line">[root@aliyun ~]# ll</span><br><span class="line">total 24</span><br><span class="line">-rw------- 1 root root       5 Nov 21 17:03 nohup.out</span><br><span class="line">-rw-r--r-- 1 root root      45 Nov 12 23:21 print.sh</span><br><span class="line">-rw-r--r-- 1 root root     196 Nov 21 17:08 show.log</span><br><span class="line">-rwxr--r-- 1 root root      58 Nov 21 17:07 show.sh</span><br><span class="line">drwxr-xr-x 2 root root    4096 Nov 17 10:24 size.log</span><br><span class="line">lrwxrwxrwx 1 root root       8 Nov 21 17:23 test -&gt; test.txt</span><br><span class="line">-rwxr-xr-- 1 root bigdata  198 Nov 18 11:47 test.txt</span><br><span class="line">[root@aliyun ~]#</span><br></pre></td></tr></table></figure>

<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ol>
<li><p>作为源文件的快捷方式存在，好处：升级源文件的时候只需要重新创建软连接，注意：环境变量中不能写源文件的路径，必须写软连接文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun~]# ll</span><br><span class="line">total 5</span><br><span class="line">lrwxrwxrwx 1 root root   8 Nov 21 17:23 mysql -&gt; mysql5.6</span><br><span class="line">drwxr-xr-x 2 root root   6 Nov 20 21:33 mysql5.6  #低版本部署</span><br><span class="line">drwxr-xr-x 2 root root   6 Nov 20 21:33 mysql5.7  #通过软连接来切换升级文件</span><br><span class="line">drwxr-xr-x 3 root root  44 Nov 17 23:13 ruozedata</span><br><span class="line">-rw-r--r-- 1 root root 846 Nov 17 23:12 ruozedata.zip</span><br></pre></td></tr></table></figure>
</li>
<li><p>作为数据盘在系统盘中日志写入目录的软连接，好处：日志写入和存储多个文件需要占用大量的磁盘，把日志的存储位置换到了数据盘中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /data01/log/  #创建数据盘下的日志目录</span><br><span class="line">mv  /var/log/hbase /data01/log/　　#移动系统盘的日志文件到数据盘</span><br><span class="line">ln -s /data01/log/hbase /var/log/hbase　　#数据盘的日志文件再软连接到系统盘</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>坑</code>：软连接文件创建后的文件和源为文件权限不同，必须注意和修改软连接文件和目标文件的权限</p>
<p><code>建议</code>：在创建软连接的时候，源文件路径和目标文件路径推介使用绝对路径</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/20/linux/4/">熟练使用vim、系统命令和程序管理工具</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DataWarehouse/">DataWarehouse</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span><div class="content"><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>整理 vi</li>
<li>整理 进程 端口号</li>
<li>整理 连接拒绝 (权限受限)</li>
<li>整理 高危命令</li>
<li>常用的 wget yum rpm 压缩</li>
</ol>
<h3 id="vim中的常见用法-部分"><a href="#vim中的常见用法-部分" class="headerlink" title="vim中的常见用法(部分)"></a>vim中的常见用法(部分)</h3><table>
<thead>
<tr>
<th>复制</th>
<th>yy</th>
</tr>
</thead>
<tbody><tr>
<td>复制多行</td>
<td>nyy</td>
</tr>
<tr>
<td>当前行向下粘贴</td>
<td>p</td>
</tr>
<tr>
<td>当前行下上粘贴</td>
<td>P</td>
</tr>
<tr>
<td>当前位置插入</td>
<td>i(I)</td>
</tr>
<tr>
<td>当下位置的下一个位置插入</td>
<td>a(A)</td>
</tr>
<tr>
<td>当前行的下一行插入</td>
<td>o(O)</td>
</tr>
<tr>
<td>删除当前字符</td>
<td>x</td>
</tr>
<tr>
<td>删除当前位置到行尾</td>
<td>D</td>
</tr>
<tr>
<td>删除当前行</td>
<td>dd</td>
</tr>
<tr>
<td>删除当前行到未行</td>
<td>dG</td>
</tr>
<tr>
<td>删除n行</td>
<td>ndd</td>
</tr>
<tr>
<td>删除全部</td>
<td>gg + dG</td>
</tr>
<tr>
<td>跳转行尾</td>
<td>Shift + $</td>
</tr>
<tr>
<td>跳转行首</td>
<td>Shift + ^</td>
</tr>
<tr>
<td>跳转首行</td>
<td>gg</td>
</tr>
<tr>
<td>跳转未行</td>
<td>G</td>
</tr>
<tr>
<td>跳转到n行</td>
<td>:n或者是nG或者是ngg</td>
</tr>
<tr>
<td>撤回一次</td>
<td>u</td>
</tr>
<tr>
<td>撤回多次</td>
<td>U</td>
</tr>
</tbody></table>
<p><code>vim编辑中的坑：</code>编辑或者调优配置文件前，一定要备份</p>
<h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><h4 id="查看磁盘-（df-h）"><a href="#查看磁盘-（df-h）" class="headerlink" title="查看磁盘 （df -h）"></a>查看磁盘 （df -h）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        40G   11G   27G  29% /</span><br><span class="line">devtmpfs        911M     0  911M   0% /dev</span><br><span class="line">tmpfs           920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs           920M  332K  920M   1% /run</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure>

<p>了解数据盘的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dev/vdb1        1T   10G    XXX   X% /data01 数据盘</span><br></pre></td></tr></table></figure>

<h4 id="查看内存（free-h）"><a href="#查看内存（free-h）" class="headerlink" title="查看内存（free -h）"></a>查看内存（free -h）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1.8G        853M         88M        336K        897M        792M</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<p>延伸：<a href="http://blog.itpub.net/30089851/viewspace-2131678/" target="_blank" rel="noopener">http://blog.itpub.net/30089851/viewspace-2131678/</a></p>
<h4 id="查看负载均衡（top）"><a href="#查看负载均衡（top）" class="headerlink" title="查看负载均衡（top）"></a>查看负载均衡（top）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# top</span><br><span class="line">top - 11:51:16 up 23 days, 12:56,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  65 total,   1 running,  64 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1883724 total,    90012 free,   874596 used,   919116 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   810836 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                       </span><br><span class="line">19516 root       0 -20  126596   9340   6508 S  0.3  0.5  98:38.33 AliYunDun                                     </span><br><span class="line">    1 root      20   0  125124   3344   2112 S  0.0  0.2   0:10.82 systemd                                       </span><br><span class="line">    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd                                      </span><br><span class="line">    3 root      20   0       0      0      0 S  0.0  0.0   0:02.21 ksoftirqd/0                                   </span><br><span class="line">    5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>负载均衡的数值不能超过10</li>
<li>如果某服务长期占用cpu或者men，去检查这个进程是在做什么</li>
<li>如果cpu飙升3000%以上，夯住 ，代码级别，如果不是自己编写的代码，大概率硬件级别–&gt;内存条坏了</li>
</ol>
<h4 id="查看进程（ps-ef）"><a href="#查看进程（ps-ef）" class="headerlink" title="查看进程（ps -ef）"></a>查看进程（ps -ef）</h4><p>查看进程常常和 grep 配合使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ps -ef|grep ssh</span><br><span class="line">root      4295     1  0 Oct25 ?        00:00:00 /usr/sbin/sshd -D</span><br><span class="line">root     20282  4295  0 11:34 ?        00:00:00 sshd: root@pts/0</span><br><span class="line">root     20318 20284  0 11:56 pts/0    00:00:00 grep --color=auto ssh</span><br></pre></td></tr></table></figure>

<p>最后一条是自己的进程，可以加上 grep -v grep 去掉这条记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ps -ef|grep ssh | grep -v grep进程用户　进程的pid　父id　　　　　　　　　　　　　　　　进程用户的内容(进程所属的目录)</span><br><span class="line">root      4295     1  0 Oct25 ?        00:00:00 /usr/sbin/sshd -D</span><br><span class="line">root     20282  4295  0 11:34 ?        00:00:00 sshd: root@pts/0</span><br></pre></td></tr></table></figure>

<h4 id="查看端口号（netstat-nlp）"><a href="#查看端口号（netstat-nlp）" class="headerlink" title="查看端口号（netstat -nlp）"></a>查看端口号（netstat -nlp）</h4><p>最常配合查看进程得到的pid号查看端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# netstat -nlp | grep 4295</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      4295/sshd</span><br></pre></td></tr></table></figure>

<p><code>注意：</code> 如果查询出来的端口号前面的ip是127.0.0.1或者localhost，属于本地回环ip地址，需要修改相应的配置文件</p>
<p><code>场景：</code> 在centos部署大数据组件，发现一个错误 Connection refused</p>
<p>解决思路：</p>
<ol>
<li>ping ip 测试ip</li>
<li>telnet ip port 测试ip和端口号 </li>
<li>防火墙</li>
</ol>
<h4 id="telnet命令安装"><a href="#telnet命令安装" class="headerlink" title="telnet命令安装"></a>telnet命令安装</h4><h5 id="window："><a href="#window：" class="headerlink" title="window："></a>window：</h5><p><img src="https://img2018.cnblogs.com/i-beta/1657732/201911/1657732-20191118121808051-1147850773.png" alt="win10开启telnet命令"></p>
<h5 id="linux："><a href="#linux：" class="headerlink" title="linux："></a>linux：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# yum install -y telnet</span><br><span class="line">[root@aliyun ~]# which telnet</span><br><span class="line">/usr/bin/telnet</span><br><span class="line">[root@aliyun ~]# telnet 121.196.220.143 22</span><br><span class="line">Trying 121.196.220.143...</span><br><span class="line">Connected to 121.196.220.143.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">SSH-2.0-OpenSSH_6.6.1</span><br></pre></td></tr></table></figure>

<h3 id="三个高危命令"><a href="#三个高危命令" class="headerlink" title="三个高危命令"></a>三个高危命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>rm -rf /</code></td>
<td>强制无提示删除</td>
</tr>
<tr>
<td><code>vim</code></td>
<td>编辑生产环境的配置文件不备份</td>
</tr>
<tr>
<td><code>kill -9 $(pgrep -f 匹配关键词)</code></td>
<td>杀死全部的进程</td>
</tr>
</tbody></table>
<p><code>杀进程之前，先ps 找到相关的进程，搞清楚，哪些是你要杀的，不然造成生产事故</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ps -ef | grep ssh</span><br><span class="line">root      4295     1  0 Oct25 ?        00:00:00 /usr/sbin/sshd -D</span><br><span class="line">root     20282  4295  0 11:34 ?        00:00:00 sshd: root@pts/0</span><br><span class="line">root     20329  4295  0 12:00 ?        00:00:00 sshd: root@pts/1</span><br><span class="line">root     20360  4295  0 12:01 ?        00:00:00 sshd: root@pts/2</span><br><span class="line">root     20380  4295  0 12:02 ?        00:00:00 sshd: root@pts/3</span><br><span class="line">root     20407  4295  0 12:12 ?        00:00:00 sshd: root@pts/4</span><br><span class="line">root     20474  4295  0 12:22 ?        00:00:00 sshd: root@pts/6</span><br><span class="line">root     20502 20476  0 12:30 pts/6    00:00:00 grep --color=auto ssh</span><br><span class="line">[root@aliyun ~]# kill -9 $(pgrep -f ssh)</span><br></pre></td></tr></table></figure>

<h3 id="常用的程序管理工具"><a href="#常用的程序管理工具" class="headerlink" title="常用的程序管理工具"></a>常用的程序管理工具</h3><h4 id="wget下载安装包"><a href="#wget下载安装包" class="headerlink" title="wget下载安装包"></a>wget下载安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.16.2.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="yum包管理"><a href="#yum包管理" class="headerlink" title="yum包管理"></a>yum包管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum search xxx</span><br><span class="line">yum install -y xxx</span><br><span class="line">yum remove xxx</span><br></pre></td></tr></table></figure>

<h4 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun conf]# rpm -qa | grep http　　#查看</span><br><span class="line">httpd-2.4.6-90.el7.centos.x86_64</span><br><span class="line">httpd-tools-2.4.6-90.el7.centos.x86_64</span><br><span class="line">[root@aliyun conf]# rpm -e httpd-tools-2.4.6-90.el7.centos.x86_64　　#卸载失败，有依赖文件</span><br><span class="line">error: Failed dependencies:</span><br><span class="line">        httpd-tools = 2.4.6-90.el7.centos is needed by (installed) httpd-2.4.6-90.el7.centos.x86_64</span><br><span class="line">[root@aliyun conf]# rpm -e  --nodeps     httpd-tools-2.4.6-90.el7.centos.x86_64　　#强制跳过依赖检查</span><br></pre></td></tr></table></figure>

<h4 id="zip压缩解压"><a href="#zip压缩解压" class="headerlink" title="zip压缩解压"></a>zip压缩解压</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip -r xxx.zip ./*  　　　　#在文件夹里面压缩文件 　　　　</span><br><span class="line">zip -r test.zip test/* 　　#在文件夹外卖压缩文件夹里面的文件unzip test.zip</span><br></pre></td></tr></table></figure>

<h4 id="tar压缩解压"><a href="#tar压缩解压" class="headerlink" title="tar压缩解压"></a>tar压缩解压</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzvf hadoop-2.6.0-cdh5.16.2.tar.gz　　　　#解压缩.ge的tar包</span><br><span class="line">tar -czvf hadoop-2.6.0-cdh5.16.2.tar.gz  hadoop-2.6.0-cdh5.16.2/*　　#压缩.ge的tar包</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/20/linux/3/">熟悉Linux权限相关命令</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DataWarehouse/">DataWarehouse</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span><div class="content"><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>整理 用户用户组</li>
<li>整理 <code>sudo</code>命令</li>
<li>整理 用户无法登录 <code>passwd</code>文件</li>
<li>权限 <code>rwx------ chmod chown</code> 案例</li>
<li>其他命令 <code>- su find du</code>等</li>
</ol>
<h3 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h3><p>针对用户的相关文件在：<code>/usr/sbin/user*</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ll /usr/sbin/user*</span><br><span class="line">-rwxr-x---. 1 root root 118192 Nov  6  2016 /usr/sbin/useradd</span><br><span class="line">-rwxr-x---. 1 root root  80360 Nov  6  2016 /usr/sbin/userdel</span><br><span class="line">-rwxr-x---. 1 root root 113840 Nov  6  2016 /usr/sbin/usermod</span><br><span class="line">-rwsr-xr-x  1 root root  11296 Apr 13  2017 /usr/sbin/usernetctl</span><br></pre></td></tr></table></figure>

<p>针对用户组的相关文件在：<code>/usr/sbin/group*</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ll /usr/sbin/group*</span><br><span class="line">-rwxr-x---. 1 root root 65480 Nov  6  2016 /usr/sbin/groupadd</span><br><span class="line">-rwxr-x---. 1 root root 57016 Nov  6  2016 /usr/sbin/groupdel</span><br><span class="line">-rwxr-x---. 1 root root 57064 Nov  6  2016 /usr/sbin/groupmems</span><br><span class="line">-rwxr-x---. 1 root root 76424 Nov  6  2016 /usr/sbin/groupmod</span><br></pre></td></tr></table></figure>

<p>可以打印出<code>PATH</code>路径，就会发现<code>/user/sbin</code>已经被添加在了<code>PATH</code>环境中了，可以从主机的任意位置使用这些命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# echo $PATH</span><br><span class="line">/opt/module/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p>需求：</p>
<p>​        1. 添加<code>hadoop</code>用户</p>
<p>​        2. 删除<code>hadoop</code>用户</p>
<p>​        3. 重新创建<code>hadoop</code>用户，模拟用户丢失样式，并修正样式</p>
<p>​        4. 创建<code>bigdata</code>用户组，并把<code>hadoop</code>用户添加进这个用户组</p>
<p>​        5. 修改<code>bigdata</code>为<code>hadoop</code>的主组</p>
<ol>
<li><p>添加<code>hadoop</code>用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# useradd hadoop</span><br><span class="line">[root@aliyun ~]# id hadoop</span><br><span class="line">uid=1000(hadoop) gid=1000(hadoop) groups=1000(hadoop)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除<code>hadoop</code>用户</p>
<p>使用命令帮助查看 <code>userdel</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# userdel --help</span><br><span class="line">Usage: userdel [options] LOGIN</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --force                   force some actions that would fail otherwise</span><br><span class="line">                                e.g. removal of user still logged in</span><br><span class="line">                                or files, even if not owned by the user</span><br><span class="line">  -h, --help                    display this help message and exit</span><br><span class="line">  -r, --remove                  remove home directory and mail spool</span><br><span class="line">  -R, --root CHROOT_DIR         directory to chroot into</span><br><span class="line">  -Z, --selinux-user            remove any SELinux user mapping for the user</span><br></pre></td></tr></table></figure>

<p>会发现 <code>-r</code> 选项是删除家目录</p>
<p>在这里我们选择删除用户的时候不删除家目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# userdel hadoop</span><br><span class="line">[root@aliyun ~]# id hadoop</span><br><span class="line">id: hadoop: no such user</span><br><span class="line">[root@aliyun home]# cat /etc/passwd | grep ruoze</span><br><span class="line">[root@aliyun home]# cat /etc/group | grep ruoze</span><br></pre></td></tr></table></figure>

<p>因为<code>hadoop</code>该组只有<code>hadoop</code>用户，当这个用户删除时，组会校验就他自己，会自动删除</p>
</li>
<li><p>重新创建<code>hadoop</code>用户，模拟用户丢失样式，并修正样式</p>
<p>创建<code>hadoop</code>用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# useradd hadoop</span><br><span class="line">useradd: warning: the home directory already exists.</span><br><span class="line">Not copying any file from skel directory into it.</span><br><span class="line">Creating mailbox file: File exists</span><br><span class="line">[root@aliyun ~]# id hadoop</span><br><span class="line">uid=1000(hadoop) gid=1000(hadoop) groups=1000(hadoop)</span><br></pre></td></tr></table></figure>

<p>模拟用户丢失样式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@aliyun ~]$ ll -a .bash*</span><br><span class="line">-rw-r--r-- 1 hadoop hadoop  18 Dec  7  2016 .bash_logout</span><br><span class="line">-rw-r--r-- 1 hadoop hadoop 193 Dec  7  2016 .bash_profile</span><br><span class="line">-rw-r--r-- 1 hadoop hadoop 231 Dec  7  2016 .bashrc</span><br><span class="line">[hadoop@aliyun ~]$ rm -rf .bash*</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# su - hadoop　　　　#切换用户</span><br><span class="line">Last login: Sun Nov 17 09:29:10 CST 2019 on pts/0</span><br><span class="line">-bash-4.2$ 　　　#用户样式丢失</span><br></pre></td></tr></table></figure>

<p>修正样式 (这里只有root权限才可以拷贝)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ll  -a /etc/skel/</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x.  2 root root 4096 Aug 18  2017 .</span><br><span class="line">drwxr-xr-x. 81 root root 4096 Nov 17 09:27 ..</span><br><span class="line">-rw-r--r--   1 root root   18 Dec  7  2016 .bash_logout</span><br><span class="line">-rw-r--r--   1 root root  193 Dec  7  2016 .bash_profile</span><br><span class="line">-rw-r--r--   1 root root  231 Dec  7  2016 .bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# cp /etc/skel/ .bash* /home/hadoop/</span><br><span class="line">cp: omitting directory ‘/etc/skel/’</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# su - hadoop　　#样式回来了</span><br><span class="line">Last login: Sun Nov 17 09:33:39 CST 2019 on pts/2</span><br><span class="line">[hadoop@aliyun ~]$</span><br></pre></td></tr></table></figure>

<p>创建<code>bigdata</code>用户组，并把<code>hadoop</code>用户添加进这个用户组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# groupadd bigdata</span><br><span class="line">[root@aliyun ~]# usermod -a -G bigdata hadoop</span><br><span class="line">[root@aliyun ~]# id hadoop</span><br><span class="line">uid=1000(hadoop) gid=1000(hadoop) groups=1000(hadoop),1001(bigdata)</span><br></pre></td></tr></table></figure>

<p><em>20200309更新</em>：<code>mysqladmin</code>的属组一里加入<code>hadoop</code>用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usermod -a -G hadoop mysqladmin</span><br></pre></td></tr></table></figure>

<p>修改<code>bigdata</code>为<code>hadoop</code>的属组</p>
<p>查看命令帮助发现有一条命令是改变用户的属组的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-g, --gid GROUP               force use GROUP as new primary group</span><br><span class="line">[root@aliyun ~]# usermod -g bigdata hadoop　　#强制改变属组</span><br><span class="line">[root@aliyun ~]# id hadoop</span><br><span class="line">uid=1000(hadoop) gid=1001(bigdata) groups=1001(bigdata)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p><code>sudo</code>命令是让普通用户具备<code>root</code>用户的权限</p>
<p>添加普通用户具备<code>root</code>权限的文件是：<code>/etc/sudoers</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">90 ## Allow root to run any commands anywhere </span><br><span class="line">91 root    ALL=(ALL)       ALL</span><br><span class="line">92 hadoop  ALL=(root)      NOPASSWD:ALL　　#新添加的内容</span><br></pre></td></tr></table></figure>

<h3 id="用户无法登录-修改passwd文件"><a href="#用户无法登录-修改passwd文件" class="headerlink" title="用户无法登录 修改passwd文件"></a>用户无法登录 修改<code>passwd</code>文件</h3><p>在模拟用户无法登陆之前，先说明管理用户信息的文件是：<code>/etc/passwd</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# tail -3  /etc/passwd</span><br><span class="line">redis:x:996:994:Redis Database Server:/var/lib/redis:/sbin/nologin</span><br><span class="line">mysqladmin:x:514:101::/usr/local/mysql:/bin/bash</span><br><span class="line">hadoop:x:1000:1001::/home/hadoop:/bin/bash</span><br></pre></td></tr></table></figure>

<p>需要注意的是最后一个冒号后面是用户的登陆权限</p>
<p>需求：</p>
<p>　　1. 模拟用户的登录权限是<code>/bin/false</code>，修改，并登录</p>
<p>　　2. 模拟用户的登录权限是<code>/sbin/nologin</code>，修改，并登录</p>
<p><strong>1. 模拟用户的登录权限是<code>/bin/false</code>，修改，并登录</strong></p>
<ol>
<li><p>模拟用户的登录权限是<code>/bin/false</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# cat /etc/passwd | grep hadoop</span><br><span class="line">hadoop:x:1000:1001::/home/hadoop:/bin/false</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# su - hadoop</span><br><span class="line">Last login: Sun Nov 17 09:37:25 CST 2019 on pts/2</span><br><span class="line">[root@aliyun ~]# 　　#登录失败</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看用户文件权限，并修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# cat /etc/passwd | grep 'hadoop'</span><br><span class="line">hadoop:x:1000:1001::/home/hadoop:/bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# su - hadoop</span><br><span class="line">Last login: Sun Nov 17 09:56:43 CST 2019 on pts/1</span><br><span class="line">[hadoop@aliyun ~]$     #登录成功</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>2. 模拟用户的登录权限是<code>/sbin/nologin</code>，修改，并登录</strong></p>
<ol>
<li><p>模拟用户的登录权限是<code>/sbin/nologin</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# cat /etc/passwd | grep hadoop</span><br><span class="line">hadoop:x:1000:1001::/home/hadoop:/sbin/nologin</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# su - hadoop</span><br><span class="line">Last login: Sun Nov 17 09:59:35 CST 2019 on pts/1</span><br><span class="line">This account is currently not available.</span><br><span class="line">[root@aliyun ~]# 　　#登录失败</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看用户文件权限，并修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# cat /etc/passwd | grep 'hadoop'</span><br><span class="line">hadoop:x:1000:1001::/home/hadoop:/bin/bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# su - hadoop</span><br><span class="line">Last login: Sun Nov 17 09:56:43 CST 2019 on pts/1</span><br><span class="line">[hadoop@aliyun ~]$     #登录成功</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="rwx-chmod-chown-案例"><a href="#rwx-chmod-chown-案例" class="headerlink" title="rwx------ chmod chown 案例"></a><code>rwx------</code> <code>chmod</code> <code>chown</code> 案例</h3><p>查看文件或者目录的读写执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ll test.txt</span><br><span class="line">-rw-r--r-- 1 root root 12 Nov 12 23:36 test.txt</span><br><span class="line">r: read  4</span><br><span class="line">w: write 2 </span><br><span class="line">x: 执行  1</span><br><span class="line">-: 没权限 0</span><br></pre></td></tr></table></figure>

<p>　<code>rw-</code>第一组 6 代表文件或文件夹的用户<code>root</code>，读写<br>　<code>r--</code> 第二组 4 代表文件或文件夹的用户组<code>root</code>，读<br>　<code>r--</code> 第三组 4 代表其他组的所属用户对这个文件或文件夹的权限: 读</p>
<p><code>chmod</code> 命令用来修改文件或者目录的读写执行权限，加 <code>-R</code> 表示递归修改</p>
<p><code>chown</code> 命令用来修改文件或者目录的属主和属组，加 <code>-R</code> 表示递归修改</p>
<p>需求：</p>
<p>​        1. 修改 <code>test.tx</code>t 文件的属组为<code>bigdata</code></p>
<p>​        2.  <code>test.txt</code> 文件的权限为属主读写执行，属组读执行</p>
<ol>
<li><p>修改 <code>test.txt</code> 文件的属组为<code>bigdata</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# chown -R :bigdata test.txt </span><br><span class="line">[root@aliyun ~]# ll test.txt </span><br><span class="line">-rw-r--r-- 1 root bigdata 12 Nov 12 23:36 test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>test.txt</code> 文件的权限为属主可读写执行，属组可读执行,其他可读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# chmod -R 754 test.txt </span><br><span class="line">[root@aliyun ~]# ll test.txt </span><br><span class="line">-rwxr-xr-- 1 root bigdata 12 Nov 12 23:36 test.txt</span><br></pre></td></tr></table></figure>

<p>注意： <code>-R</code> 参数，目前可认为只有<code>chown</code>和<code>chmod</code>命令有，其他都为 <code>-r</code></p>
</li>
</ol>
<h3 id="其他命令-su-find-du"><a href="#其他命令-su-find-du" class="headerlink" title="其他命令 - su find du"></a>其他命令 - <code>su</code> <code>find</code> <code>du</code></h3><p><u><code>su</code>命令用来切换用户，使用<code>su -</code> 用户名的方式，切换的时候把环境也切换了</u></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# su - hadoop　　#su - 用户名</span><br><span class="line">Last login: Sun Nov 17 10:16:08 CST 2019 on pts/2</span><br><span class="line">[hadoop@aliyun ~]$ pwd</span><br><span class="line">/home/hadoop</span><br><span class="line">[root@aliyun ~]# su hadoop　　#su 用户名</span><br><span class="line">[hadoop@aliyun root]$ pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure>

<p>需要注意 <code>.bash_profile</code> 和 <code>.bashrc</code> 两个文件中的环境生效的区别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.bash_profile文件 su ruoze不会执行，su - ruoze 都执行</span><br><span class="line">.bashrc文件       su ruoze执行   ，su - ruoze 都执行</span><br></pre></td></tr></table></figure>

<p><u><code>find</code>命令用来查找文件，在不确定文件名的情况下使用模糊匹配</u></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@aliyun root]$ find /home -name '*hadoop*'</span><br><span class="line">/home/hadoop</span><br></pre></td></tr></table></figure>

<p><u><code>du</code>命令用来查看文件或者目录大小</u></p>
<p>虽然 ls -l 也可以查看文件或者目录的大小，但是 <code>ls -l</code> 显示的目录大小并不准确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# ll -h  size.log/</span><br><span class="line">total 12K</span><br><span class="line">-rw-r--r-- 1 root root 286K Nov 17 10:24 lastlog</span><br></pre></td></tr></table></figure>

<p>再使用<code>du -sh</code> 查看一次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# du -sh size.log/</span><br><span class="line">12K    size.log/</span><br></pre></td></tr></table></figure>

<p>最后进入<code>size.log</code>文件夹查看文件的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun log]# du -sh lastlog</span><br><span class="line">12K    lastlog</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/19/linux/2/">Linux对环境变量的理解以及alias、rm、hostory的使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DataWarehouse/">DataWarehouse</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span><div class="content"><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>整理 全局环境变量 个人环境变量 <code>which</code>的理解</li>
<li>整理 别名</li>
<li>整理 删除</li>
<li>整理 <code>history</code></li>
</ol>
<h3 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h3><p>全局环境变量的配置文件是：<code>/etc/profile</code></p>
<p>全局环境变量中一般配置的是共用的程序环境 比如<code>java</code></p>
<p>下面以<code>java</code>为例子配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>java的安装路径在 <code>/usr/java</code>下，所以文件中如下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_144</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>需要注意的是 <code>$PATH</code>接在<code>$JAVA_HOME</code>的后面，即把<code>$JAVA_HOME</code>放在<code>$PATH</code>的最前面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/module/jdk1.8.0_144/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/opt/module/jdk1.8.0_144/bin:/root/bin</span><br></pre></td></tr></table></figure>

<h3 id="个人环境变量"><a href="#个人环境变量" class="headerlink" title="个人环境变量"></a>个人环境变量</h3><p>个人环境变量配置在 <code>~/.bashrc</code> 文件中，这里需要注意的是如果配置在 <code>~/.bash_profile</code>文件中，使用<code>ssh</code>远程连接的时候不会加载 <code>~/.bash_profile</code>，造成一些无法排查的<code>bug</code></p>
<p>个人环境配置一些独自使用的程序变量，如果配置在用户的个人环境中，其他用户无法访问，比如在<code>hadoop</code>用户下配置 <code>hadoop</code>的环境变量，只有<code>hadoop</code>一个用户能使用</p>
<h3 id="which的理解"><a href="#which的理解" class="headerlink" title="which的理解"></a>which的理解</h3><p>安装完程序或者配置完变量后，最好的习惯是使用<code>which</code>看一下，检查一下环境是否配置正确，否则可能遇到自以为正确的<code>bug</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# which java</span><br><span class="line">/opt/module/jdk1.8.0_144/bin/java</span><br></pre></td></tr></table></figure>

<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>别名的使用可以简写冗长且难以记忆或者难以书写的命令</p>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias [-p] [name[=value] ... ]</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# alias a='ll -a'</span><br><span class="line">[root@aliyun ~]# a</span><br><span class="line">total 80</span><br><span class="line">dr-xr-x---.  6 root root 4096 Nov 15 19:46 .</span><br><span class="line">dr-xr-xr-x. 19 root root 4096 Nov  3 17:29 ..</span><br><span class="line">-rw-------   1 root root 6453 Nov 14 11:16 .bash_history</span><br><span class="line">-rw-r--r--.  1 root root   18 Dec 29  2013 .bash_logout</span><br><span class="line">-rw-r--r--.  1 root root  176 Dec 29  2013 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root root  176 Dec 29  2013 .bashrc</span><br><span class="line">drwx------   3 root root 4096 Aug 18  2017 .cache</span><br></pre></td></tr></table></figure>

<p>查询主机中已经存在的别名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# alias</span><br><span class="line">alias cp='cp -i'</span><br><span class="line">alias egrep='egrep --color=auto'</span><br><span class="line">alias fgrep='fgrep --color=auto'</span><br><span class="line">alias grep='grep --color=auto'</span><br><span class="line">alias l.='ls -d .* --color=auto'</span><br><span class="line">alias ll='ls -l --color=auto'</span><br><span class="line">alias ls='ls --color=auto'</span><br><span class="line">alias mv='mv -i'</span><br><span class="line">alias rm='rm -i'</span><br><span class="line">alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span><br></pre></td></tr></table></figure>

<p>永久配置别名：</p>
<p>配置在环境变量中 <code>/etc/profile</code> ，<code>~/.bashrc</code>，<code>~/.bash_profile</code>中，即永久配置别名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm='rm -i'</span><br><span class="line">alias cp='cp -i'</span><br><span class="line">alias mv='mv -i'</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>mkdir</code></td>
<td>删除一个空文件</td>
</tr>
<tr>
<td><code>rm -f</code></td>
<td>直接删除文件</td>
</tr>
<tr>
<td><code>rm -rf</code></td>
<td>直接删除文件夹</td>
</tr>
<tr>
<td><code>rm -rf</code></td>
<td>是一个高危的命令</td>
</tr>
</tbody></table>
<p>场景：</p>
<p><code>shell</code>脚本中，定义变量<code>k = &quot;&quot;</code> 然后<code>rm -rf $k</code> 会默认指定根目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">K=&quot;&quot;rm -rf $K 实际上是rm -rf /</span><br></pre></td></tr></table></figure>

<p>解决办法是先判断k是否为空</p>
<h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p><code>history</code>命令用来查询历史记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# history | head -10</span><br><span class="line">    1  passwd </span><br><span class="line">    2  ls</span><br><span class="line">    3  cat /etc/hosts</span><br><span class="line">    4  yum install redis</span><br><span class="line">    5  yum install epel-release</span><br><span class="line">    6  yum install redis</span><br><span class="line">    7  df -hT</span><br><span class="line">    8  service redis start</span><br><span class="line">    9  service redis stop</span><br><span class="line">   10  service redis status</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<p>莫名其妙的发现主机中的数据没了，可以查看一下历史记录用了哪些命令</p>
<p>使用 <code>!n</code> 来快速使用一条历史命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# !7</span><br><span class="line">df -hT</span><br><span class="line">Filesystem     Type      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1      ext4       40G   11G   27G  29% /</span><br><span class="line">devtmpfs       devtmpfs  911M     0  911M   0% /dev</span><br><span class="line">tmpfs          tmpfs     920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs          tmpfs     920M  332K  920M   1% /run</span><br><span class="line">tmpfs          tmpfs     920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs          tmpfs     184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure>

<p><code>history -c</code> 命令可以清空当前窗口的历史输出命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# history -c</span><br><span class="line">[root@aliyun ~]# history</span><br><span class="line">1  history</span><br></pre></td></tr></table></figure>

<p>但是历史记录实际上保存在 <code>~/.bash_history</code>中的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# cat .bash_history | head -10</span><br><span class="line">passwd </span><br><span class="line">ls</span><br><span class="line">cat /etc/hosts</span><br><span class="line">yum install redis</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install redis</span><br><span class="line">df -hT</span><br><span class="line">service redis start</span><br><span class="line">service redis stop</span><br><span class="line">service redis status</span><br></pre></td></tr></table></figure>

<p>彻底清空该文件夹的方式为：<code>cat /dell/null &gt; .bash_history</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# cat /dev/null &gt; .bash_history </span><br><span class="line">[root@aliyun ~]# cat .bash_history</span><br><span class="line">[root@aliyun ~]#</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/09/18/linux/1/">Linux操作文件和定位错误</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/DataWarehouse/">DataWarehouse</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span><div class="content"><h3 id="置空文件的一些坑"><a href="#置空文件的一些坑" class="headerlink" title="置空文件的一些坑"></a>置空文件的一些坑</h3><ol>
<li><p>最简单的是直接创建一个空文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun var]# touch test.txt | ll test.txt</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 11 22:29 test.txt</span><br><span class="line">[root@aliyun var]#</span><br></pre></td></tr></table></figure>
</li>
<li><p>慎用 <code>echo &quot;&quot; &gt; test.txt</code> 这种方式置空文件</p>
<p>如果我们使用这种方法置空文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun var]# echo "" &gt; test.txt</span><br><span class="line">[root@aliyun var]#  ll -h test.txt</span><br><span class="line">-rw-r--r-- 1 root root 1 Nov 11 22:31 test.txt</span><br></pre></td></tr></table></figure>

<p>它不是绝对意义上的为空，文件占有一个字节的大小</p>
</li>
<li><p>可以更换为<code>cat /dev/null &gt; test.txt</code> 这种方式置空文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun var]# cat /dev/null &gt; test.txt | ll -h test.txt</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 11 22:34 test.txt</span><br></pre></td></tr></table></figure>

<p>真正意义上把文件置空为0个字节</p>
</li>
</ol>
<h3 id="如何定位ERROR"><a href="#如何定位ERROR" class="headerlink" title="如何定位ERROR"></a>如何定位ERROR</h3><ul>
<li><p>文件内容很小 几十兆<br>上传给<code>windows</code>，用<code>editplus</code>工具打开，在<code>editplus</code>中搜索，定位</p>
<p>上传下载  <code>yum install -y lrzsz</code></p>
</li>
<li><p>文件内容很大 至少几百兆</p>
<p> 直接定位到<code>ERROR</code>行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun var]# cat test.log | grep ERROR</span><br><span class="line">10 ERROR : 模拟错误</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用grep定位REEOR上下文"><a href="#使用grep定位REEOR上下文" class="headerlink" title="使用grep定位REEOR上下文"></a>使用<code>grep</code>定位<code>REEOR</code>上下文</h3><ol>
<li><p>查看<code>ERROR</code>行的前十行（<code>before</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun var]# cat test.log | grep -B 10 ERROR</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">9</span><br><span class="line">10 ERROR : 模拟错误</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看<code>ERROR</code>行的后十行（<code>after</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun var]# cat test.log | grep -A 10 ERROR</span><br><span class="line">10 ERROR : 模拟错误</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看<code>ERROR</code>行的前后二十行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@aliyun var]# cat test.log | grep -C 10 ERROR</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">9</span><br><span class="line">10 ERROR : 模拟错误</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure></li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/12/">&lt;&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>