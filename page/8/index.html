<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BigData Developer"><meta name="keywords" content="yerias,TUNANのBlog,BigData"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">133</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">TUNANのBlog</div><div id="site-sub-title">感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/08/java/8/">IO流&amp;比较器&amp;内部类&amp;Random</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>IO流</li>
<li>比较器</li>
<li>内部类</li>
<li>Random</li>
</ol>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>Java中的流根据传输方向分为输入输出流，根据操作数据的不同又可以分为字节流和字符流</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>所有的字节流都继承自InputStream接口和OutputStream接口</p>
<p>用于文件传输的是FileInputStream类和FileOutputStream类，传输的是字节，使用FileInputStream读取文件时，可以使用byte字节数组建立一个字节数组缓冲区，读取数据时read方法中传入一个字节数组，每次读取一个字节数组的数据，即可实现缓冲区读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">in.read(buff)  <span class="comment">//数据读进buff中</span></span><br><span class="line">out.write(buff) <span class="comment">//write中传入buff写出数据</span></span><br></pre></td></tr></table></figure>

<p>在字节流的IO包中提供了两个带缓冲的字节流，分别是BufferedInputStream和BufferedOutputStream，他们的构造方法中分别接受InputStream和OutputStream，类型的参数作为对象，这两</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> InputStream(filePath));</span><br></pre></td></tr></table></figure>

<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/05/java/6/">JAVA.UTIL包下的TreeSet和迭代器快速失败的的源码解析以及多线程下故障现象、导致原因、以及解决办法和优化建议</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><hr>
<p>该篇博客不适合小白，只做针对性的api源码解析，以及适合我自身的案例研究</p>
<hr>
<ol>
<li><p>使用多个线程往<code>ArrayList</code>中添加元素</p>
</li>
<li><p>故障现象</p>
</li>
<li><p>故障原因</p>
</li>
<li><p>解决方法</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/04/java/4/">HashMap多线程问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><hr>
<p>该篇博客不适合小白，只做针对性的api源码解析，以及适合我自身的案例研究</p>
<h2 id="jdk1-7中的HashMap"><a href="#jdk1-7中的HashMap" class="headerlink" title="jdk1.7中的HashMap"></a>jdk1.7中的HashMap</h2><p>在jdk1.8中对HashMap做了很多优化，这里先分析在jdk1.7中的问题，相信大家都知道在jdk1.7多线程环境下HashMap容易出现死循环，这里我们先用代码来模拟出现死循环的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="number">4</span>         HashMapThread thread0 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line"> <span class="number">5</span>         HashMapThread thread1 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line"> <span class="number">6</span>         HashMapThread thread2 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line"> <span class="number">7</span>         HashMapThread thread3 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line"> <span class="number">8</span>         HashMapThread thread4 = <span class="keyword">new</span> HashMapThread();</span><br><span class="line"> <span class="number">9</span>         thread0.start();</span><br><span class="line"><span class="number">10</span>         thread1.start();</span><br><span class="line"><span class="number">11</span>         thread2.start();</span><br><span class="line"><span class="number">12</span>         thread3.start();</span><br><span class="line"><span class="number">13</span>         thread4.start();</span><br><span class="line"><span class="number">14</span>     &#125;</span><br><span class="line"><span class="number">15</span> &#125;</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="number">18</span>     <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="number">19</span>     <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">22</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">23</span>         <span class="keyword">while</span> (ai.get() &lt; <span class="number">1000000</span>) &#123;</span><br><span class="line"><span class="number">24</span>             map.put(ai.get(), ai.get());</span><br><span class="line"><span class="number">25</span>             ai.incrementAndGet();</span><br><span class="line"><span class="number">26</span>         &#125;</span><br><span class="line"><span class="number">27</span>     &#125;</span><br><span class="line"><span class="number">28</span> &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码比较简单，就是开多个线程不断进行put操作，并且HashMap与AtomicInteger都是全局共享的。在多运行几次该代码后，出现如下死循环情形：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_1.jpg" alt=""></p>
<p>其中有几次还会出现数组越界的情况：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_2.jpg" alt=""></p>
<p>这里我们着重分析为什么会出现死循环的情况，通过jps和jstack命名查看死循环情况，结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_3.jpg" alt=""></p>
<p>从堆栈信息中可以看到出现死循环的位置，通过该信息可明确知道死循环发生在HashMap的扩容函数中，根源在<strong>transfer函数</strong>中，jdk1.7中HashMap的transfer函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>         <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"> <span class="number">3</span>         <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line"> <span class="number">4</span>             <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line"> <span class="number">5</span>                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"> <span class="number">6</span>                 <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line"> <span class="number">7</span>                     e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line"> <span class="number">8</span>                 &#125;</span><br><span class="line"> <span class="number">9</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line"><span class="number">10</span>                 e.next = newTable[i];</span><br><span class="line"><span class="number">11</span>                 newTable[i] = e;</span><br><span class="line"><span class="number">12</span>                 e = next;</span><br><span class="line"><span class="number">13</span>             &#125;</span><br><span class="line"><span class="number">14</span>         &#125;</span><br><span class="line"><span class="number">15</span>     &#125;</span><br></pre></td></tr></table></figure>

<p>总结下该函数的主要作用：</p>
<p>在对table进行扩容到newTable后，需要将原来数据转移到newTable中，注意10-12行代码，这里可以看出在转移元素的过程中，使用的是头插法，也就是<strong>链表的顺序会翻转</strong>，这里也是形成死循环的关键点。下面进行详细分析。</p>
<h2 id="扩容造成死循环分析过程"><a href="#扩容造成死循环分析过程" class="headerlink" title="扩容造成死循环分析过程"></a>扩容造成死循环分析过程</h2><p>这里假设</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#1.hash算法为简单的用key mod链表的大小。</span><br><span class="line"></span><br><span class="line">#2.最开始hash表size=2，key=3,7,5，则都在table[1]中。</span><br><span class="line"></span><br><span class="line">#3.然后进行resize，使size变成4。</span><br></pre></td></tr></table></figure>

<p>未resize前的数据结构如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_4.jpg" alt=""></p>
<p>如果在单线程环境下，最后的结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_5.jpg" alt=""></p>
<p>这里的转移过程，不再进行详述，只要理解transfer函数在做什么，其转移过程以及如何对链表进行反转应该不难。</p>
<p>然后在多线程环境下，假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中第11行代码处挂起，因为该函数在这里分析的地位非常重要，因此再次贴出来。</p>
<p><img src="https://yerias.github.io/java_img/hashmap_6.jpg" alt=""></p>
<p>此时线程A中运行结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_7.jpg" alt=""></p>
<p>线程A挂起后，此时线程B正常执行，并完成resize操作，结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_8.jpg" alt=""></p>
<p><strong>这里需要特别注意的点：由于线程B已经执行完毕，根据Java内存模型，现在newTable和table中的Entry都是主存中最新值：7.next=3，3.next=null。</strong></p>
<p>此时切换到线程A上，在线程A挂起时内存中值如下：e=3，next=7，newTable[3]=null，代码执行过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newTable[<span class="number">3</span>]=e ----&gt; newTable[<span class="number">3</span>]=<span class="number">3</span></span><br><span class="line">e=next ----&gt; e=<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>此时结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_9.jpg" alt=""></p>
<p>继续循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e=<span class="number">7</span></span><br><span class="line">next=e.next ----&gt; next=<span class="number">3</span>【从主存中取值】</span><br><span class="line">e.next=newTable[<span class="number">3</span>] ----&gt; e.next=<span class="number">3</span>【从主存中取值】</span><br><span class="line">newTable[<span class="number">3</span>]=e ----&gt; newTable[<span class="number">3</span>]=<span class="number">7</span></span><br><span class="line">e=next ----&gt; e=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_10.jpg" alt=""></p>
<p>再次进行循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e=<span class="number">3</span></span><br><span class="line">next=e.next ----&gt; next=<span class="keyword">null</span></span><br><span class="line">e.next=newTable[<span class="number">3</span>] ----&gt; e.next=<span class="number">7</span> 即：<span class="number">3</span>.next=<span class="number">7</span></span><br><span class="line">newTable[<span class="number">3</span>]=e ----&gt; newTable[<span class="number">3</span>]=<span class="number">3</span></span><br><span class="line">e=next ----&gt; e=<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>注意此次循环：e.next=7，而在上次循环中7.next=3，出现环形链表，并且此时e=null循环结束。</p>
<p>结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_11.jpg" alt=""></p>
<p>在后续操作中只要涉及轮询hashmap的数据结构，就会在这里发生死循环，造成悲剧。</p>
<h2 id="扩容造成数据丢失分析过程"><a href="#扩容造成数据丢失分析过程" class="headerlink" title="扩容造成数据丢失分析过程"></a>扩容造成数据丢失分析过程</h2><p>遵照上述分析过程，初始时：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_12.jpg" alt=""></p>
<p>线程A和线程B进行put操作，同样线程A挂起：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_13.jpg" alt=""></p>
<p>此时线程A的运行结果如下：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_14.jpg" alt=""></p>
<p>此时线程B已获得CPU时间片，并完成resize操作：</p>
<p><img src="https://yerias.github.io/java_img/hashmap_15.jpg" alt=""></p>
<p>同样注意由于线程B执行完成，newTable和table都为最新值：<strong>5.next=null</strong>。</p>
<p>此时切换到线程A，在线程A挂起时：<strong>e=7，next=5，newTable[3]=null。</strong></p>
<p>执行newtable[i]=e，就将<strong>7放在了table[3]</strong>的位置，此时next=5。接着进行下一次循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e=<span class="number">5</span></span><br><span class="line">next=e.next ----&gt; next=<span class="keyword">null</span>，从主存中取值</span><br><span class="line">e.next=newTable[<span class="number">1</span>] ----&gt; e.next=<span class="number">5</span>，从主存中取值</span><br><span class="line">newTable[<span class="number">1</span>]=e ----&gt; newTable[<span class="number">1</span>]=<span class="number">5</span></span><br><span class="line">e=next ----&gt; e=<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>将5放置在table[1]位置，此时e=null循环结束，<strong>3元素丢失</strong>，并形成<strong>环形链表</strong>。并在后续操作hashmap时造成死循环。</p>
<p><img src="https://yerias.github.io/java_img/hashmap_16.jpg" alt=""></p>
<h2 id="jdk1-8中HashMap"><a href="#jdk1-8中HashMap" class="headerlink" title="jdk1.8中HashMap"></a>jdk1.8中HashMap</h2><p>在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全，这里我们看jdk1.8中HashMap的put操作源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="number">2</span>                    <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"> <span class="number">3</span>         Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"> <span class="number">4</span>         <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line"> <span class="number">5</span>             n = (tab = resize()).length;</span><br><span class="line"> <span class="number">6</span>         <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 如果没有hash碰撞则直接插入元素</span></span><br><span class="line"> <span class="number">7</span>             tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"> <span class="number">8</span>         <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="number">9</span>             Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="number">10</span>             <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">11</span>                 ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">12</span>                 e = p;</span><br><span class="line"><span class="number">13</span>             <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line"><span class="number">14</span>                 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="number">15</span>             <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">16</span>                 <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="number">17</span>                     <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">18</span>                         p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">19</span>                         <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line"><span class="number">20</span>                             treeifyBin(tab, hash);</span><br><span class="line"><span class="number">21</span>                         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">22</span>                     &#125;</span><br><span class="line"><span class="number">23</span>                     <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line"><span class="number">24</span>                         ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="number">25</span>                         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">26</span>                     p = e;</span><br><span class="line"><span class="number">27</span>                 &#125;</span><br><span class="line"><span class="number">28</span>             &#125;</span><br><span class="line"><span class="number">29</span>             <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="number">30</span>                 V oldValue = e.value;</span><br><span class="line"><span class="number">31</span>                 <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="number">32</span>                     e.value = value;</span><br><span class="line"><span class="number">33</span>                 afterNodeAccess(e);</span><br><span class="line"><span class="number">34</span>                 <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="number">35</span>             &#125;</span><br><span class="line"><span class="number">36</span>         &#125;</span><br><span class="line"><span class="number">37</span>         ++modCount;</span><br><span class="line"><span class="number">38</span>         <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line"><span class="number">39</span>             resize();</span><br><span class="line"><span class="number">40</span>         afterNodeInsertion(evict);</span><br><span class="line"><span class="number">41</span>         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="number">42</span>     &#125;</span><br></pre></td></tr></table></figure>

<p>这是jdk1.8中HashMap中put操作的主函数， 注意第6行代码，如果没有hash碰撞则会直接插入元素。如果线程A和线程B同时进行put操作，刚好这两条不同的数据hash值一样，并且该位置数据为null，所以这线程A、B都会进入第6行代码中。假设一种情况，线程A进入后还未进行数据插入时挂起，而线程B正常执行，从而正常插入数据，然后线程A获取CPU时间片，此时线程A不用再进行hash判断了，问题出现：线程A会把线程B插入的数据给<strong>覆盖</strong>，发生线程不安全。</p>
<p>这里只是简要分析下jdk1.8中HashMap出现的线程不安全问题的体现，后续将会对java的集合框架进行总结，到时再进行具体分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先HashMap是不安全的，其主要体现:</p>
<ol>
<li>在jdk1.7中，多线程环境下，扩容时会造成环形链表或丢失数据</li>
<li>在jdk18中，多线程环境下，会发生数据覆盖的情况</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/04/java/5/">HashMap1.8源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><hr>
<p>该篇博客不适合小白，只做针对性的api源码解析，以及适合我自身的案例研究</p>
<hr>
<h3 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最大容量2的30次方</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 链表转树的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 树转链表的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 树最小的子节点数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认初始容量是16，负载因子是0.75</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只传入初始容量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传入初始容量和负载因子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 传入一个map集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// hash值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// key值</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// value值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 下一个Node的指针</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到key值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="comment">// 得到vaue值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="comment">// 重写toString</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// hashCode值等于key和value的hash值取反</span></span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断内容相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重温jdk1-7中如何触发死循环的"><a href="#重温jdk1-7中如何触发死循环的" class="headerlink" title="重温jdk1.7中如何触发死循环的"></a>重温jdk1.7中如何触发死循环的</h3><p>单线程情况下，rehash无问题。下图演示了单线程条件下的rehash过程</p>
<p><img src="https://yerias.github.io/java_img/java_1.png" alt="单线程rehash"></p>
<p>多线程并发下的rehash</p>
<p>这里假设有两个线程同时执行了put操作并引发了rehash，执行了transfer方法，并假设线程一进入transfer方法并执行完next = e.next后，因为线程调度所分配时间片用完而“暂停”，此时线程二完成了transfer方法的执行。此时状态如下。</p>
<p><img src="https://yerias.github.io/java_img/java_2.png" alt="多线程rehash"></p>
<p>接着线程1被唤醒，继续执行第一轮循环的剩余部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.next = newTable[<span class="number">1</span>] = <span class="keyword">null</span></span><br><span class="line">newTable[<span class="number">1</span>] = e = key(<span class="number">5</span>)</span><br><span class="line">e = next = key(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下图所示</p>
<p><img src="https://yerias.github.io/java_img/java_3.png" alt="多线程rehash"></p>
<p>接着线程1被唤醒，继续执行第一轮循环的剩余部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.next = newTable[<span class="number">1</span>] = <span class="keyword">null</span></span><br><span class="line">newTable[<span class="number">1</span>] = e = key(<span class="number">5</span>)</span><br><span class="line">e = next = key(<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>结果如下图所示</p>
<p><img src="https://yerias.github.io/java_img/java_5.png" alt="多线程rehash"></p>
<p>接着执行下一轮循环，结果状态图如下所示</p>
<p><img src="https://yerias.github.io/java_img/java_4.png" alt="多线程rehash"></p>
<p>此时循环链表形成，并且key(11)无法加入到线程1的新数组。在下一次访问该链表时会出现死循环。</p>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><p>初始化容量16，负载因子0.75，尾插法，扩容2倍，8个节点转树，6个节点转链表，不会产生死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">	<span class="comment">// 理解为node/hashmap</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">	<span class="comment">// 拿到旧的hashmapnode的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">	<span class="comment">// 旧hashmap的扩容阈值</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">	<span class="comment">// 新hashmap的容量和阈值初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 拿到新hashmap的容量</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 旧的hashmap容量大于最大值，则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 旧的hashmap扩容为原来的两倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 旧的hashmap长度等于0，但是阈值大于0，则把阈值赋值为hashmap的长度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">	<span class="comment">// 如果旧的hashmap的长度和阈值都为0，则赋初始值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 拿到新阈值的值 =&gt; 新容量*0.75</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 赋值给threshold</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">	<span class="comment">// 创建一个新的容量的Node</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">	<span class="comment">// 赋值给table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">	<span class="comment">// 尾插法，将旧的table的数据查询出来再插入新的table</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回新的Node</span></span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h3><p>使用时异或求hash值，比取余更快更均匀</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// '^' 异或操作，相同则为0，不同则为1</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p>如果插入的位置为空则直接插入，如果有值但是key的hash或者内容相等，则覆盖，如果能转树则转树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果当前数组table为null，进行resize()初始化，n = resize的长度</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果table[i]为空，那就把这个键值对放在table[i]</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 当另一个key的hash值已经存在时</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果节点的key的hash值和容量都相同，则覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// Node转成树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 遍历table[i]所对应的链表，直到最后一个节点的next为null或者有重复的key值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key重复，替换value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 触发扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>首先通过<code>hash</code>函数找到索引，然后判断map为null，再判断table[i]是否等于key，然后在找与table相连的链表的key是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt; e;</span><br><span class="line">	<span class="comment">// 如果拿出来的不为null，就返回value</span></span><br><span class="line">	<span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果是第一个元素就返回</span></span><br><span class="line">	<span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">		((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//// 从树中拿</span></span><br><span class="line">		<span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">			<span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">// 循环链表，key的hash值或者key的内容相同，则返回</span></span><br><span class="line">			<span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">				((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">				<span class="keyword">return</span> e;</span><br><span class="line">			&#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没找到 返回null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试题：如果new HashMap(19)，bucket数组多大？</p>
<ul>
<li>HashMap的bucket 数组大小一定是2的幂，如果new的时候指定了容量且不是2的幂，实际容量会是最接近(大于)指定容量的2的幂，比如 new HashMap&lt;&gt;(19)，比19大且最接近的2的幂是32，实际容量就是32。</li>
</ul>
<p>基础知识</p>
<p><img src="https://yerias.github.io/java_img/%E4%BD%8D%E8%BF%90%E7%AE%97.png" alt="位运算"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/03/java/3/">JAVA.UTIL包下的LINKEDLIST和迭代器快速失败的源码解析以及多线程下故障现象、导致原因、以及解决办法和优化建议</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><hr>
<p>该篇博客不适合小白，只做针对性的api源码解析，以及适合我自身的案例研究</p>
<hr>
<ol>
<li><p>使用多个线程往<code>LinkedList</code>中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;,String.valueOf(i)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>故障现象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"3"</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<p>我们知道<code>LinkedList</code>是线程不安全的，当多线程操作时，线程操作迭代器的同时其他线程改变了元素的值就会产生<code>ConcurrentModificationException</code>异常，<code>ConcurrentModificationException</code>是在操作<code>Iterator</code>时抛出的异常</p>
</li>
<li><p>故障原因</p>
<p>从前一篇的<code>ArrayList</code>中的解析中得出，我们最终都会经过迭代器中的代码检查<code>modCount</code> 和 <code>expectedModCount</code>的值相不相等</p>
<p>所以我们这里就不追踪栈异常信息，而直接看看源码中的操作是如何让<code>modCount</code> 和<code>expectedModCount</code>不相等的</p>
<ol>
<li><p>首先找出问题的关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">private</span> Node&lt;E&gt; lastReturned;	<span class="comment">//最近一次返回的节点，也是当前持有的节点</span></span><br><span class="line">      <span class="keyword">private</span> Node&lt;E&gt; next;			<span class="comment">//对下一个元素的引用</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> nextIndex;			<span class="comment">//下一个节点的索引</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          checkForComodification();	<span class="comment">//每次添加元素前，都检查一次modCount和expectedModCount是否相等，如果不相等就直接返回ConcurrentModificationException异常，产生快速失败,多线程环境下这里通不过</span></span><br><span class="line">          <span class="keyword">if</span> (!hasNext())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">      </span><br><span class="line">          lastReturned = next;	<span class="comment">//当前节点--&gt;下一个节点</span></span><br><span class="line">          next = next.next;	<span class="comment">//下下个节点的指正往前移一个节点</span></span><br><span class="line">          nextIndex++;	<span class="comment">//index++</span></span><br><span class="line">          <span class="keyword">return</span> lastReturned.item; <span class="comment">//返回移动后的节点的数据</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在解析如何修改<code>modCount</code> 值之前我们应该弄明白，<code>LinkedList</code>中的<code>Node</code>节点是如何实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//私有节点类Node，在1.8版本之前叫做Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       E item;		<span class="comment">//存储的元素</span></span><br><span class="line">       Node&lt;E&gt; next;	<span class="comment">//后继结点</span></span><br><span class="line">       Node&lt;E&gt; prev;	<span class="comment">//前驱结点</span></span><br><span class="line">      </span><br><span class="line">       <span class="comment">// 前驱结点、存储的元素和后继结点作为参数的构造方法</span></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.item = element;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">           <span class="keyword">this</span>.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码中是如何修改<code>modCount</code> 的值的(不包括作为队列和双端队列的方法)(开始怼源码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;	  <span class="comment">//元素数量</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;  <span class="comment">//首节点引用，为null</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;	  <span class="comment">//尾结点引用，为null</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//追加一个元素到列表的末尾</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//把元素存放到链表的末尾</span></span><br><span class="line">       linkLast(e);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//尾部添加元素</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取当前尾节点的引用</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">       <span class="comment">//构建一个新节点，prev的值为l(尾节点)、节点数据为e、next的值为null</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//新节点作为尾结点</span></span><br><span class="line">       last = newNode;</span><br><span class="line">       <span class="comment">//如果原尾节点为null</span></span><br><span class="line">       <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">//即原链表为null，链表的首节点也是newNode</span></span><br><span class="line">           first = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//否则，原节点的next设置为newNode</span></span><br><span class="line">           l.next = newNode;</span><br><span class="line">       <span class="comment">//数量+1</span></span><br><span class="line">       size++;</span><br><span class="line">       <span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//将指定元素插入到列表中的指定位置。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index是否在有效范围内</span></span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//如果index==size，说明添加的位置是末尾</span></span><br><span class="line">       <span class="keyword">if</span> (index == size)</span><br><span class="line">           <span class="comment">//在末尾添加元素</span></span><br><span class="line">           linkLast(element);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//把element元素插入到index指定的节点位置</span></span><br><span class="line">           linkBefore(element, node(index));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//检查index是否在有效范围内</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//返回指定元素索引处的(非空)节点。(注意这里有技巧)</span></span><br><span class="line">   <span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果index小于size的1/2长度</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">           <span class="comment">//获取头结点的引用</span></span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           <span class="comment">//从前到后遍历index个节点，最后返回</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  			<span class="comment">//否则获取最后一个节点的引用</span></span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           <span class="comment">//从后到前遍历index个节点，最后返回</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//在非空节点succ之前插入元素e。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取succ节点(index)的前一个节点的引用</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">       <span class="comment">//创建一个新的节点，维护的新节点的前一个节点是pred、元素本身、和元素的下一个节点succ</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">       <span class="comment">//succ节点的上一个节点指向newNode</span></span><br><span class="line">       succ.prev = newNode;</span><br><span class="line">       <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">//如果pred节点为null，则说明没有值，则newNode就是第一个节点</span></span><br><span class="line">           first = newNode;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//否则pred的下一个节点指向newNode</span></span><br><span class="line">           pred.next = newNode;</span><br><span class="line">       <span class="comment">//数量+1</span></span><br><span class="line">       size++;</span><br><span class="line">       <span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//将指定集合中的所有元素追加到这个列表</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用了插入集合元素的方法，指定了index=size</span></span><br><span class="line">       <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将指定集合中的所有元素插入其中列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index是否有效</span></span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line">	<span class="comment">//先把集合转换成数组，这也就限定了集合必须是List下的实现类</span></span><br><span class="line">       Object[] a = c.toArray();</span><br><span class="line">       <span class="comment">//获取集合的长度</span></span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">       <span class="comment">//如果集合的长度为0，即为空</span></span><br><span class="line">       <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">	<span class="comment">//定义两个节点，succ指向当前需要插入节点的位置，pred指向其前一个节点</span></span><br><span class="line">    	Node&lt;E&gt; pred, succ;</span><br><span class="line">       <span class="comment">//如果在尾部插入元素</span></span><br><span class="line">       <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">           <span class="comment">//当前节点为空</span></span><br><span class="line">           succ = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//当前节点的上一个节点就是最后一个节点</span></span><br><span class="line">           pred = last;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//否则获取index位置的节点指向succ</span></span><br><span class="line">           succ = node(index);</span><br><span class="line">           <span class="comment">//index位置节点的前一个引用指向pred</span></span><br><span class="line">           pred = succ.prev;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//遍历集合，每一个节点都做重复创建，添加引用</span></span><br><span class="line">       <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">           <span class="comment">//创建节点，该节点的pred指向pred节点(最初的index节点的前一个节点)，元素本身e，下一个节点指向null。</span></span><br><span class="line">           Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//判断是否为链表头</span></span><br><span class="line">           <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">               first = newNode;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">//pred节点的next也指向新节点</span></span><br><span class="line">               pred.next = newNode;</span><br><span class="line">           <span class="comment">//新节点又继续作为pred节点存在</span></span><br><span class="line">           pred = newNode;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//集合遍历完成后，如果当前节点为空节点，即在链表的末尾添加元素，就把pred指向尾结点，succ节点不存在</span></span><br><span class="line">       <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">           last = pred;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果是在链表中间插入的集合，当前节点succ是作位pred的next元素存在</span></span><br><span class="line">           pred.next = succ;</span><br><span class="line">           <span class="comment">//同时pred指向succ的上一个节点引用，相互引用</span></span><br><span class="line">           succ.prev = pred;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//size+numNew个数</span></span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除列表中指定位置的元素。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index是否有效</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//删除index节点的元素</span></span><br><span class="line">       <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">   <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//获取节点的元素</span></span><br><span class="line">       <span class="keyword">final</span> E element = x.item;</span><br><span class="line">       <span class="comment">//获取元素的下一个节点的引用</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">       <span class="comment">//获取元素的上一个节点的引用</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//如果上一个节点等于null，则说明前面没有节点，把next节点的下一个节点引用为第一个节点</span></span><br><span class="line">       <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">           first = next;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//否则把next节点引用为prev节点的next指向的节点</span></span><br><span class="line">           prev.next = next;</span><br><span class="line">           <span class="comment">//x节点的上一个节点置空</span></span><br><span class="line">           x.prev = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//如果next节点等于null，为空值，就直接把prev赋值为last节点</span></span><br><span class="line">       <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">           last = prev;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//否则把next节点的上一个节点指向prev</span></span><br><span class="line">           next.prev = prev;</span><br><span class="line">           <span class="comment">//x节点的下一个节点置空</span></span><br><span class="line">           x.next = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//最后把x的数据置空</span></span><br><span class="line">       x.item = <span class="keyword">null</span>;</span><br><span class="line">       size--;</span><br><span class="line">       <span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//返回已经删除的元素值</span></span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//从列表中删除指定元素的第一个匹配项</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果对象o等于null(这里说明linkedList允许存放null值)</span></span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//从头到尾遍历找出第一个符合数据为null的节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">//删除节点</span></span><br><span class="line">                   unlink(x);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//否则 从头到尾遍历找出第一个符合数据为null的节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">               <span class="comment">//找出符合qeuals条件的对象</span></span><br><span class="line">               <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                   <span class="comment">//删除</span></span><br><span class="line">                   unlink(x);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//从列表中删除所有元素。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//注意使用的是for循环遍历全部节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">               <span class="comment">//每个节点的所有信息全部置空</span></span><br><span class="line">               Node&lt;E&gt; next = x.next;</span><br><span class="line">               x.item = <span class="keyword">null</span>;</span><br><span class="line">               x.next = <span class="keyword">null</span>;</span><br><span class="line">               x.prev = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//循环赋值</span></span><br><span class="line">               x = next;</span><br><span class="line">           &#125;</span><br><span class="line">      		<span class="comment">//首节点和尾结点赋值为null</span></span><br><span class="line">           first = last = <span class="keyword">null</span>;</span><br><span class="line">           size = <span class="number">0</span>;</span><br><span class="line">           modCount++;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//获取指定位置节点元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index是否有效</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//返回index节点的数据</span></span><br><span class="line">       <span class="keyword">return</span> node(index).item;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//将列表中指定位置的元素替换为指定元素。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index是否有效</span></span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       <span class="comment">//获取index的节点</span></span><br><span class="line">       Node&lt;E&gt; x = node(index);</span><br><span class="line">       <span class="comment">//获取节点的item</span></span><br><span class="line">       E oldVal = x.item;</span><br><span class="line">		<span class="comment">//新的元素替换旧的元素</span></span><br><span class="line">       x.item = element;</span><br><span class="line">       <span class="comment">//返回旧元素</span></span><br><span class="line">       <span class="keyword">return</span> oldVal;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//将双向链表转换成数组</span></span><br><span class="line">   <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">       <span class="comment">//创建一个Size大小的数组</span></span><br><span class="line">       Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//循环遍历所有节点</span></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">           <span class="comment">//将节点数据存入数组</span></span><br><span class="line">           result[i++] = x.item;</span><br><span class="line">       <span class="comment">//返回数组</span></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>和<code>ArrayList</code>一样，无论<code>add()</code>、<code>remove()</code>，还是<code>clear()</code>，只要涉及到修改集合中的元素个数时，都会改变<code>modCount</code>(全局)的值。由此回到<code>next()</code>方法中我们发现当 ‘A’ 线程正在做迭代器遍历操作时，<code>modCount</code>赋值给了<code>expectedModCount</code>，每次调用<code>next()</code>方法都会做一次<code>modCount != expectedModCount</code>的校验，此时线程 ’B‘ 进来了调用了add方法修改了<code>modCount</code>的值，此时<code>modCount</code>变成了N+1，判断为false，抛出<code>ConcurrentModificationException</code>异常，产生fail-fast事件 。</p>
</li>
</ol>
</li>
<li><p>fail-fast`事件</p>
<p>当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过<code>add</code>、<code>remove</code>、<code>clear</code>等方法，改变了<code>modCount</code>的值)；这时，就会抛出<code>ConcurrentModificationException</code>异常。与此对应的安全失败，在后面再解析。</p>
</li>
<li><p>解决方法</p>
<p>使用<code>Collections.synchronizedList()</code>方法包装，但是效率低下，这种方法实际上只是将原来非线程安全的<code>LinkedList</code>中的方法加上一个<code>synchronized</code>同步代码块 (哭了。。。)</p>
</li>
<li><p>优化建议</p>
<p>在多线程下如果有按数据索引访问元素的情形，采用<code>Collections.synchronizedList(new LinkedList&lt;&gt;())</code>方法</p>
</li>
<li><p>LinkedList的常用API</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(E e)</code></td>
<td>将指定的元素添加到列表的末尾。</td>
</tr>
<tr>
<td><code>addFirst(E e)</code></td>
<td>在此列表的开始处插入指定的元素。</td>
</tr>
<tr>
<td><code>addLast(E e)</code></td>
<td>将指定的元素列表的结束。</td>
</tr>
<tr>
<td><code>get(int index)</code></td>
<td>返回此列表中指定位置的元素。</td>
</tr>
<tr>
<td><code>remove(int index)</code></td>
<td>移除此列表中指定位置的元素。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回此列表中元素的数目。</td>
</tr>
<tr>
<td><code>toArray()</code></td>
<td>返回一个数组，包含在这个列表中的所有元素在适当的顺序（从第一个到最后一个元素）。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>从这个列表中移除所有的元素。</td>
</tr>
<tr>
<td><code>indexOf(Object o)</code></td>
<td>返回此列表中指定元素的第一个出现的索引</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>检索，但不删除，此列表的头（第一个元素）。</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>检索并删除此列表的头（第一个元素）。</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>从这个列表所表示的堆栈中弹出一个元素。</td>
</tr>
<tr>
<td><code>push(E e)</code></td>
<td>将一个元素推到由该列表所表示的堆栈上。</td>
</tr>
<tr>
<td><code>offer(E e)</code></td>
<td>将指定的元素添加到列表的尾部（最后一个元素）。</td>
</tr>
</tbody></table>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/02/java/2/">JAVA.UTIL包下的ARRAYLIST和迭代器快速失败的源码解析以及多线程下故障现象、导致原因、以及解决办法和优化建议</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><hr>
<p>该篇博客不适合小白，只做针对性的api源码解析，以及适合我自身的案例研究</p>
<hr>
<ol>
<li><p>使用多个线程往<code>ArrayList</code>中添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建资源集合</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建30个线程添加元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>故障现象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">"2"</span> java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<p>我们知道<code>ArrayList</code>是线程不安全的，当多线程操作时，线程操作迭代器的同时其他线程改变了元素的值就会产生<code>ConcurrentModificationException</code>异常，<code>ConcurrentModificationException</code>是在操作<code>Iterator</code>时抛出的异常</p>
</li>
<li><p>故障原因</p>
<p>java中的<code>java.util</code>包下的类全部都是快速失败的，那么为什么在多线程操作ArrayList的时候会出现<code>ConcurrentModificationException</code>异常呢？</p>
<p>在我们的案例中，每个线程添加一次元素我们就打印一次集合中的元素，通过源码追踪，得出下面的内容</p>
<ol>
<li><p>打印内容，经过第二行代码，String调用了valueOf(x)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ValueOf(Object x)方法是把Object类型的对象x转换成String类型，判断不为null，进入obj也就是我们的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合中的toString方法定义在了AbstractCollection类中，我们的错误出现在了 <code>E e = it.next();</code>获取元素这里，继续追踪错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();	<span class="comment">//创建迭代器对象</span></span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())		<span class="comment">//判断集合是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[]"</span>;</span><br><span class="line">      </span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();	<span class="comment">//创建StringBuilder动态构造字符串</span></span><br><span class="line">    sb.append(<span class="string">'['</span>);	</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;		<span class="comment">//死循环</span></span><br><span class="line">        E e = it.next();	<span class="comment">//获取元素 E ==&gt; String 是传进来的泛型</span></span><br><span class="line">        sb.append(e == <span class="keyword">this</span> ? <span class="string">"(this Collection)"</span> : e);	<span class="comment">//添加元素</span></span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())	<span class="comment">//循环换了就返回集合的字符串类型</span></span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">']'</span>).toString();</span><br><span class="line">        sb.append(<span class="string">','</span>).append(<span class="string">' '</span>); <span class="comment">//这里是没有return之前会进来，添加分隔符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是迭代器中的next()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    	<span class="comment">// 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1</span></span><br><span class="line">    	<span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">int</span> cursor;       <span class="comment">// 下一个要返回的元素的索引</span></span><br><span class="line">      <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 最后一个返回元素的索引;-1:没有</span></span><br><span class="line">      <span class="keyword">int</span> expectedModCount = modCount;	<span class="comment">//这是非常关键的一步，把modCount赋值给expectedModCount，用来在迭代器遍历时next()和remove()方法中做校验</span></span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          checkForComodification();	<span class="comment">//每次添加元素前，都检查一次modCount和expectedModCount是否相等，如果不相等就直接返回ConcurrentModificationException异常，产生快速失败,多线程环境下这里通不过</span></span><br><span class="line">          <span class="keyword">int</span> i = cursor;	</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">          Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">          <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">          cursor = i + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)	<span class="comment">//多线程环境下，modCount和expectedModCount不相等</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么在多线程环境下是如何让<code>modCount</code> != <code>expectedModCount</code>的呢？</p>
<p>我们先看源码中是如何修改<code>modCount</code> 的值的(开始怼源码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// list中容量变化时，对应的同步函数</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// 保存了添加到ArrayList中的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;	<span class="comment">//默认是空元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;	<span class="comment">//初始容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">           <span class="comment">//元素列表不等于默认列表</span></span><br><span class="line">           ? <span class="number">0</span></span><br><span class="line">           <span class="comment">//元素列表等于默认列表，返回默认初始值10</span></span><br><span class="line">           : DEFAULT_CAPACITY;</span><br><span class="line">	</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;	<span class="comment">//传入的容量大于最小扩展容量(minExpand)，则调用ensureExplicitCapacity()方法传入minCapacity</span></span><br><span class="line">           ensureExplicitCapacity(minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//判断元素列表是否为初始的元素列表，返回默认容量10和传入的容量中较大的值</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> minCapacity;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//JDK1.8 中，add、addAll方法会先调用者方法判断是否需要扩容</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//把元素列表和扩展的容量传入到calculateCapacity方法，做一个判断</span></span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//list中容量变化时，modCount+1</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">      </span><br><span class="line">       <span class="comment">// 如果minCapacity大于elementData的长度，则进行扩容</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//调用grow扩容</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//旧容量</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//新容量=旧容量+旧容量的1/2 ==&gt;扩容1.5倍</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//如果计算出来的新容量比传进来的容量小，则以传入的容量为准</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="comment">//如果新容量大于MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8)，则把新容量交给hugeCapacity方法</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);	<span class="comment">//hugeCapacity实际上是做了一次内存溢出的判断，因为MAX_ARRAY_SIZE的容量已经接近溢出的边缘</span></span><br><span class="line">       <span class="comment">//Arrays.copyOf()方法放入elementData的元素，并把容量扩容为newCapacity</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">//主要检查内存是否溢出</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 内存溢出</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 添加元素到队列最后</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断是否需要扩容和modCount+1,以及判断内存溢出</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">       <span class="comment">//将元素添加到数组末尾</span></span><br><span class="line">       elementData[size++] = e;	</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 添加元素到指定的位置</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查index的范围</span></span><br><span class="line">       rangeCheckForAdd(index);	</span><br><span class="line">	<span class="comment">//判断是否需要扩容和modCount+1,以及判断内存溢出</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  </span><br><span class="line">       <span class="comment">//把原数组的index位置移动到目标数组的index+1的位置,长度=数组长度-插入位置，这样就把index位置空出来了，涉及到内存操作，贼慢</span></span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">       <span class="comment">//把元素插入到数组中的index位置</span></span><br><span class="line">       elementData[index] = element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//指定位置的范围检查，适用于add和addAll.</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//throw new 下标越界异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 添加集合</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//把集合转换成一个Object类型的数组</span></span><br><span class="line">       Object[] a = c.toArray();	</span><br><span class="line">       <span class="comment">//获集合的长度，用作扩容和复制</span></span><br><span class="line">       <span class="keyword">int</span> numNew = a.length;	</span><br><span class="line">       <span class="comment">//判断是否需要扩容和modCount+1,以及判断内存溢出</span></span><br><span class="line">       ensureCapacityInternal(size + numNew);</span><br><span class="line">       <span class="comment">//把集合从0位置开始移动到目标数组的size位置,长度就等于集合的长度</span></span><br><span class="line">       System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">       <span class="comment">//计算size</span></span><br><span class="line">       size += numNew;</span><br><span class="line">       <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//类似于addAll，插入的位置变了而已</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 删除指定位置的元素 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查范围</span></span><br><span class="line">       rangeCheck(index);</span><br><span class="line">	<span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//找出index位置的元素</span></span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line">	<span class="comment">//计算数组从index到size的长度，-1是为了减去index的位置</span></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//如果计算后的长度大于0，则使用System.arraycopy复制index后的元素向前移动一位，内存操作，贼慢</span></span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,numMoved);</span><br><span class="line">        <span class="comment">//size--,并赋值为null</span></span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">	<span class="comment">//返回删除元素后的数组</span></span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//检查索引的范围</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 快速删除指定位置的元素,和remove(int index)类似，省去了范围校验</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,numMoved);</span><br><span class="line">       <span class="comment">//原来这里也会有GC回收</span></span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 清空集合</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//修改modCount</span></span><br><span class="line">       modCount++;</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">           <span class="comment">//这里也会有GC回收</span></span><br><span class="line">           elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>一遍源码读下来，发现无论是<code>add()</code>、<code>remove()</code>，还是<code>clear()</code>，只要涉及到修改集合中的元素个数时，都会改变<code>modCount</code>(全局)的值。</p>
<p>由此回到<code>next()</code>方法中我们发现当 ‘A’ 线程正在做迭代器遍历操作时，<code>modCount</code>赋值给了<code>expectedModCount</code>，每次调用<code>next()</code>方法都会做一次<code>modCount != expectedModCount</code>的校验，此时线程 ’B‘ 进来了调用了add方法修改了<code>modCount</code>的值，此时<code>modCount</code>变成了N+1，判断为false，抛出<code>ConcurrentModificationException</code>异常，产生fail-fast事件 。</p>
</li>
</ol>
</li>
<li><p><code>fail-fast</code>事件</p>
<p>当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过<code>add</code>、<code>remove</code>、<code>clear</code>等方法，改变了<code>modCount</code>的值)；这时，就会抛出<code>ConcurrentModificationException</code>异常。与此对应的安全失败，在后面再解析。</p>
</li>
<li><p>解决方法</p>
<p>经过源码解析<code>ConcurrentModificationException</code>异常是因为多个线程同时调用add()方法导致的，解决的办法有一下三种:</p>
<ol>
<li><p>使用<code>Vector()</code>替代<code>ArrayList()</code>，但是这种方法效率低下，因为<code>Vector()</code>的几乎所有方法都加上了<code>synchronized</code>修饰符，<code>synchronized</code>保证了在同一时刻最多只有一个线程访问该段代码，虽然jdk1.5引入了自旋锁、锁粗化、轻量级锁和偏向锁，但还是太重，效率很低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> Vector&lt;String&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Collections.synchronizedList()</code>包装<code>ArrayList</code>，但是这种方法实际上只是将原来非线程安全的<code>ArrayList</code>中的方法加上一个<code>synchronized</code>同步代码块 (哭了。。。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Object mutex;     <span class="comment">// 对象锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (mutex) &#123;	<span class="comment">//同步代码块</span></span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (mutex) &#123;	<span class="comment">//同步代码块</span></span><br><span class="line">        <span class="keyword">return</span> list.set(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种也是推介的一种方法就是使用java.util.concurrent包下的CopyOnWriteArrayList解决，俗称写时复制机制，是读写分离的一种实现，这种方法在后面将详细源码解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>优化建议</p>
<p>在多线程下如果有按数据索引访问元素的情形，采用<code>CopyOnWriteArrayList()</code>方法</p>
</li>
<li><p>ArrayList的常用API</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>add(E e)</td>
<td>将指定的元素列表的结束。</td>
</tr>
<tr>
<td>addAll(Collection c)</td>
<td>追加指定集合的所有元素到这个列表的末尾，按他们的指定集合的迭代器返回。</td>
</tr>
<tr>
<td>clear()</td>
<td>从这个列表中移除所有的元素。</td>
</tr>
<tr>
<td>contains(Object o)</td>
<td>返回 <code>true</code>如果这个列表包含指定元素。</td>
</tr>
<tr>
<td>get(int index)</td>
<td>返回此列表中指定位置的元素。</td>
</tr>
<tr>
<td>iterator()</td>
<td>在这个列表中的元素上返回一个正确的顺序。</td>
</tr>
<tr>
<td>remove(int index)</td>
<td>移除此列表中指定位置的元素。</td>
</tr>
<tr>
<td>set(int index, E element)</td>
<td>用指定元素替换此列表中指定位置的元素。</td>
</tr>
<tr>
<td>size()</td>
<td>返回此列表中元素的数目</td>
</tr>
<tr>
<td>toArray()</td>
<td>返回一个数组，包含在这个列表中的所有元素在适当的顺序</td>
</tr>
</tbody></table>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/01/01/java/1/">Lock可重入锁与函数式接口Runnable接口的lambda编程方式</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-01-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h2 id="多线程企业级Demo"><a href="#多线程企业级Demo" class="headerlink" title="多线程企业级Demo"></a>多线程企业级Demo</h2><ol>
<li><p>前提</p>
<p>所有的多线程开开发遵循一个规则:</p>
<p><code>在高内聚低耦合的前提下，线程--&gt;操作--&gt;资源类</code></p>
<p>在这个条件下我们写一个卖票的Demo，三个售票员卖出30张票</p>
</li>
<li><p>资源类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个可重入的lock锁</span></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//总30张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();	<span class="comment">//上锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t卖出第"</span> + (number--) + <span class="string">"\t张票，还剩下"</span> + number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();	<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//待操作的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"a"</span>).start();</span><br></pre></td></tr></table></figure>

<p><code>注意:</code> 我们查看Runnable()接口的源代码发现，这是一个函数式接口，下面提供源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以使用lambda表达式简化操作</p>
</li>
<li><p>操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new资源类</span></span><br><span class="line">Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();&#125;,<span class="string">"A卖票员"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();&#125;,<span class="string">"B卖票员"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) ticket.sale();&#125;,<span class="string">"C卖票员"</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A卖票员	卖出第<span class="number">30</span>	张票，还剩下<span class="number">29</span></span><br><span class="line">A卖票员	卖出第<span class="number">29</span>	张票，还剩下<span class="number">28</span></span><br><span class="line">A卖票员	卖出第<span class="number">28</span>	张票，还剩下<span class="number">27</span></span><br><span class="line">...</span><br><span class="line">A卖票员	卖出第<span class="number">1</span>	张票，还剩下<span class="number">0</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Lambda表达式与函数式接口"><a href="#Lambda表达式与函数式接口" class="headerlink" title="Lambda表达式与函数式接口"></a>Lambda表达式与函数式接口</h2><p>在jdk1.8中，引入了函数式接口，函数式接口中只能声明一个抽象方法，lambda表达式可以直接使用这个接口</p>
<ol>
<li><p>定义函数式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>	<span class="comment">//显式指定 当接口中只有一条抽象方法时，默认是函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用lambda表达式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//指定接口的实现</span></span><br><span class="line">    Foo foo = () -&gt; System.out.println(<span class="string">"hello FunctionInterface.."</span>);</span><br><span class="line">    foo.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>还需要知道的是在jdk1.8中，引入了default方法修饰接口，并且可以在接口中声明static方法，但是必须实现方法，这里和我们印象中的java接口有点不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@FunctionalInterface  //声明函数式接口 只有一条抽象方法时可以省略</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x-y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类，没有实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FuncitonInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Foo对象接收实现的接口</span></span><br><span class="line">        Foo foo = () -&gt; System.out.println(<span class="string">"hello FunctionInterface.."</span>);</span><br><span class="line">        foo.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Foo对象的引用调用add方法</span></span><br><span class="line">        System.out.println(foo.add(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接口名直接调用static修饰的dec方法</span></span><br><span class="line">        System.out.println(Foo.dec(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/05/flume/5/">Flume源代码二次开发Source&amp;Sink&amp;Interceptor&amp;Channel的事物保证</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Flume/">Flume</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Flume/">Flume</a></span><div class="content"><ol>
<li>Agent架构</li>
<li>自定义Source</li>
<li>自定义Sink</li>
<li>自定义Interceptor</li>
<li>Channel的事物保证</li>
</ol>
<h2 id="Agent架构"><a href="#Agent架构" class="headerlink" title="Agent架构"></a>Agent架构</h2><p><img src="https://yerias.github.io/flume_img/Agent.jpg" alt="Agent"></p>
<h2 id="自定义Source"><a href="#自定义Source" class="headerlink" title="自定义Source"></a>自定义Source</h2><p>提示：当不会写的时候，看源码是个不错的选择</p>
<p>在自定义Flume的组件之前， IDEA需要引入Flume的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flume<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flume-ng-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Source的目的是从外部客户端接收数据并将其存储到配置的Channels中。一个Source可以获得它自己的ChannelProcessor的一个实例来连续处理一个Event，该Event在一个Channel本地事务中被提交。</p>
<p>在异常的情况下，所需的Channel将传播异常，所有Channel将回滚它们的Event，但之前在其他Channel上处理的Event将保持提交。</p>
<p>自定义Source可以在数据源里直接产生数据，产生的数据你可以定制化(前缀、后缀)</p>
<p>自定义Source类，参考官网<a href="http://flume.apache.org/releases/content/1.9.0/FlumeDeveloperGuide.html#source" target="_blank" rel="noopener">demo/github</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tunan.hadoop.flume.sources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.EventDeliveryException;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.PollableSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.event.SimpleEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.source.AbstractSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> <span class="keyword">extends</span> <span class="title">AbstractSource</span> <span class="keyword">implements</span> <span class="title">Configurable</span>, <span class="title">PollableSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义属性，前缀和后缀</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理Event</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义状态属性</span></span><br><span class="line">        Status status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟产生数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建Event</span></span><br><span class="line">            SimpleEvent event = <span class="keyword">new</span> SimpleEvent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把数据设置到Body中去，注意header为空</span></span><br><span class="line">            event.setBody((prefix + i + suffix).getBytes());</span><br><span class="line">            <span class="comment">// 开始处理Evetn</span></span><br><span class="line">            getChannelProcessor().processEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 成功</span></span><br><span class="line">            status = Status.READY;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 失败，回退</span></span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回状态的结果</span></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Agent中传入的参数信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = context.getString(<span class="string">"prefix"</span>,<span class="string">"TUNAN"</span>);</span><br><span class="line">        <span class="keyword">this</span>.suffix = context.getString(<span class="string">"suffix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将jar包上传到$FLUME_HOME/lib下，并修改配置文件中的Source，修改Type、添加类中自定义的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们在类中自定义的Source参数和类的全限定名</span></span><br><span class="line">a1.sources.r1.type = tunan.hadoop.flume.sources.MySource</span><br><span class="line">a1.sources.r1.prefix = tunan:</span><br><span class="line">a1.sources.r1.suffix = -6639</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--conf /home/hadoop/app/flume/conf \</span><br><span class="line">--conf-file /home/hadoop/app/flume/script/MySource.conf \</span><br><span class="line">--name a1 \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>

<p>查看结果</p>
<p><img src="https://yerias.github.io/flume_img/mysource.jpg" alt="mysource"></p>
<h2 id="自定义Sink"><a href="#自定义Sink" class="headerlink" title="自定义Sink"></a>自定义Sink</h2><p>提示：当不会写的时候，看源码是个不错的选择</p>
<p>Sink的目的是从Channel中提取Event并将它们转发到流中的下一个Flume Agent或将它们存储在外部存储库中。</p>
<p>正如在Flume属性文件中配置的那样，一个Sink仅与一个Channel相关联。</p>
<p>有一个与每个配置的Sink相关联的SinkRunner实例，当Flume框架调用SinkRunner.start()时，会创建一个新线程来驱动Sink(使用SinkRunner)。这个线程管理Sink的生命周期。Sink需要实现start()和stop()方法，它们是生命周期感知接口的一部分。start()方法应该初始化Sink，并使其处于可以将Event转发到下一个目的地的状态。process()方法应该执行从Channel中提取Event并转发Event的核心处理。stop()方法应该做必要的清理工作(例如释放资源)。</p>
<p>从Channel拿到数据(Event)，把数据输出我们自定义的Sink中去，架构为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc source ==&gt; memory channel ==&gt; MySink</span><br></pre></td></tr></table></figure>

<p>注意： nc可以保证消息有序，telnet不能保证消息有序</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tunan.hadoop.flume.sink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.conf.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.sink.AbstractSink;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySink</span> <span class="keyword">extends</span> <span class="title">AbstractSink</span> <span class="keyword">implements</span> <span class="title">Configurable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger =  LoggerFactory.getLogger(MySink<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性作为参数的前缀和后缀</span></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从channel中获取数据发送到目的地</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">process</span><span class="params">()</span> <span class="keyword">throws</span> EventDeliveryException </span>&#123;</span><br><span class="line">        Status status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Channel ch = getChannel();</span><br><span class="line">        <span class="comment">// 获取事物</span></span><br><span class="line">        Transaction txn = ch.getTransaction();</span><br><span class="line">        <span class="comment">// 开启事物</span></span><br><span class="line">        txn.begin();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 拿到event</span></span><br><span class="line">            Event event;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;   <span class="comment">// 一直等待，直到拿到不为空的Event</span></span><br><span class="line">                event = ch.take();</span><br><span class="line">            &#125; <span class="keyword">while</span> ((event == <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// body是个字节数组转换成字符串</span></span><br><span class="line">            String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 控制台打印</span></span><br><span class="line">            logger.error(prefix + body + suffix);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            txn.commit();</span><br><span class="line">            status = Status.READY;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            txn.rollback();</span><br><span class="line">            status = Status.BACKOFF;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error)t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            txn.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Agent中拿到参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = context.getString(<span class="string">"prefix"</span>,<span class="string">"Tunan"</span>);</span><br><span class="line">        <span class="keyword">this</span>.suffix = context.getString(<span class="string">"suffix"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jar包上传到$FLUME_HOME\lib下，并修改配置文件中的Sink，修改Type、添加类中自定义的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 我们在类中自定义的Sink参数和类的全限定名</span></span></span><br><span class="line">a1.sinks.k1.type = tunan.hadoop.flume.sink.MySink</span><br><span class="line">a1.sinks.k1.prefix = tunan-sink:</span><br><span class="line">a1.sinks.k1.suffix = -flie</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>发送消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop ~]$ nc localhost 44444</span><br><span class="line">1</span><br><span class="line">OK</span><br><span class="line">2</span><br><span class="line">OK</span><br><span class="line">3</span><br><span class="line">OK</span><br><span class="line">..</span><br><span class="line">0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>查看结果</p>
<p><img src="https://yerias.github.io/flume_img/image-20200502115329892.png" alt=""></p>
<h2 id="自定义Interceptor"><a href="#自定义Interceptor" class="headerlink" title="自定义Interceptor"></a>自定义Interceptor</h2><p>提示：当不会写的时候，看源码是个不错的选择</p>
<p>Flume具有修改/删除运行中的Event的能力。这是在拦截器的帮助下完成的。拦截器是实现<code>org.apache.flum .interceptor. interceptor</code>接口的类。拦截器可以根据拦截器开发人员选择的任何标准修改甚至删除Event。</p>
<p>Flume支持链式的拦截器。这是通过在配置中指定拦截器builder类名列表来实现的。截取程序被指定为source配置中的空白分隔列表。指定拦截器的顺序与调用它们的顺序相同。一个拦截器返回的Event列表被传递到链中的下一个拦截器。</p>
<p>拦截器可以修改或删除Event。如果拦截器需要删除Event，它只会在其返回的列表中不返回该Event。如果它要删除所有Event，那么它只返回一个空列表。</p>
<p>需求：Flume接进来的数据都在一起，有些业务线的数据比较重要，单独拉出来，这里自定义拦截器，并配合<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#multiplexing-channel-selector" target="_blank" rel="noopener">Multiplexing Channel Selector</a>将body包含<code>gifshow</code>的数据单独拿出来</p>
<p><img src="https://yerias.github.io/flume_img/Flume%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8.jpg" alt="Flume自定义拦截器"></p>
<p>代码实现自定义拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tunan.hadoop.flume.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.Event;</span><br><span class="line"><span class="keyword">import</span> org.apache.flume.interceptor.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 自定义List用来处理批量Event</span></span><br><span class="line">    <span class="keyword">private</span>  List&lt;Event&gt; newEvents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化设置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        newEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截单个Event</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">intercept</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; headers = event.getHeaders();</span><br><span class="line">        String body = <span class="keyword">new</span> String(event.getBody());</span><br><span class="line">        <span class="keyword">if</span> (body.contains(<span class="string">"gifshow"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 自定义头信息</span></span><br><span class="line">            headers.put(<span class="string">"type"</span>, <span class="string">"gifshow"</span>);</span><br><span class="line">        	<span class="comment">// 自定义头信息</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            headers.put(<span class="string">"type"</span>, <span class="string">"other"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拦截多个Event处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Event&gt; <span class="title">intercept</span><span class="params">(List&lt;Event&gt; events)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次进来初始化List</span></span><br><span class="line">        newEvents.clear();</span><br><span class="line">        Iterator&lt;Event&gt; iter = events.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            Event next = iter.next();</span><br><span class="line">            <span class="comment">// event传递给单个处理，并添加到新的List</span></span><br><span class="line">            newEvents.add(intercept(next));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回拦截后的Event</span></span><br><span class="line">        <span class="keyword">return</span> newEvents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 源码在 HostInterceptor，需要添加一个静态内部类，并且名为Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Interceptor <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyInterceptor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置第一个Agent</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1 k2</span><br><span class="line">a1.channels = c1 c2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = localhost</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自定义拦截器</span></span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line">a1.sources.r1.interceptors.i1.type = tunan.hadoop.flume.interceptor.MyIntercepto$Builder</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> multiplexing selector</span></span><br><span class="line">a1.sources.r1.selector.type = multiplexing</span><br><span class="line">a1.sources.r1.selector.header = type</span><br><span class="line"><span class="meta">#</span><span class="bash"> 与自定义拦截器中设置的头信息对应</span></span><br><span class="line">a1.sources.r1.selector.mapping.figshow = c1</span><br><span class="line">a1.sources.r1.selector.mapping.other = c2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = hadoop</span><br><span class="line">a1.sinks.k1.port = 4441</span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type = avro</span><br><span class="line">a1.sinks.k2.hostname = hadoop</span><br><span class="line">a1.sinks.k2.port = 4442</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line">a1.channels.c2.type = memory</span><br><span class="line">a1.channels.c2.capacity = 1000</span><br><span class="line">a1.channels.c2.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1 c2</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c2</span><br></pre></td></tr></table></figure>

<p>配置第二个Agent</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = hadoop</span><br><span class="line">a1.sources.r1.port = 4441</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>配置第三个Agent</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = hadoop</span><br><span class="line">a1.sources.r1.port = 4442</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.capacity = 1000</span><br><span class="line">a1.channels.c1.transactionCapacity = 100</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>启动Agent，先启动Agent2和Agent3，不然会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--conf /home/hadoop/app/flume/conf \</span><br><span class="line">--conf-file /home/hadoop/app/flume/script/Interceptor_3.conf \</span><br><span class="line">--name a1 \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--conf /home/hadoop/app/flume/conf \</span><br><span class="line">--conf-file /home/hadoop/app/flume/script/Interceptor_2.conf \</span><br><span class="line">--name a1 \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--conf /home/hadoop/app/flume/conf \</span><br><span class="line">--conf-file /home/hadoop/app/flume/script/Interceptor_1.conf \</span><br><span class="line">--name a1 \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>

<p>发送消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop ~]$ nc localhost 44444</span><br><span class="line">gifshow</span><br><span class="line">OK</span><br><span class="line">aaaaa</span><br><span class="line">OK</span><br><span class="line">aaaagifshow</span><br><span class="line">OK</span><br><span class="line">figshow</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>查看结果</p>
<p><img src="https://yerias.github.io/flume_img/other.jpg" alt=""></p>
<p><img src="https://yerias.github.io/flume_img/gifshow.jpg" alt=""></p>
<h2 id="Channel的事物保证"><a href="#Channel的事物保证" class="headerlink" title="Channel的事物保证"></a>Channel的事物保证</h2><p>Transaction interface 是Flume可靠性的基础，所有主要组件(即Source、Sink、Channel)必须使用Flume Transaction。</p>
<p>Transaction 在连接Channel中实现，连接到Channel的每个Source和Sink都必须获得一个Transaction 对象。</p>
<p>Source使用ChannelProcessor来管理Transaction ，而Sinks 通过其配置的Channel显式地管理Transaction。</p>
<p>每个阶段的操作Event(将其放入Channel中)或提取Event(将其从Channel中取出)的操作在活动必须在Transaction中完成。</p>
<p>![Channel Trancastion](<a href="https://yerias.github.io/flume_img/Channel">https://yerias.github.io/flume_img/Channel</a> Trancastion.jpg)</p>
<p>所有的事物管理由MemoryChannel类来做，具体可以查看源码</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/04/flume/4/">Flume源代码二次开发debug</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Flume/">Flume</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Flume/">Flume</a></span><div class="content"><h3 id="1-下载安装Flume，配置flume"><a href="#1-下载安装Flume，配置flume" class="headerlink" title="1.下载安装Flume，配置flume"></a>1.下载安装Flume，配置flume</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop conf]$ cat exec_memory_kafka.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the custom <span class="built_in">exec</span> <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = com.ruozedata.prewarning.ExecSourceJSON</span><br><span class="line">a1.sources.r1.command = tail -F /home/hadoop/flume-test-log hadoop-cmf-hdfs-NAMENODE-ruozedata001.log.out</span><br><span class="line">a1.sources.r1.hostname = hadoop</span><br><span class="line">a1.sources.r1.servicename = namenode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink</span><br><span class="line">a1.sinks.k1.kafka.topic = PREWARNING</span><br><span class="line">a1.sinks.k1.kafka.bootstrap.servers = hadoop:9090,hadoop:9091,hadoop:9092</span><br><span class="line">a1.sinks.k1.kafka.flumeBatchSize = 6000</span><br><span class="line">a1.sinks.k1.kafka.producer.acks = all</span><br><span class="line">a1.sinks.k1.kafka.producer.linger.ms = 1</span><br><span class="line">a1.sinks.ki.kafka.producer.compression.type = snappy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c1.keep-alive = 90</span><br><span class="line">a1.channels.c1.capacity = 2000000</span><br><span class="line">a1.channels.c1.transactionCapacity = 6000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<h3 id="2-拉取源码拉取源码到idea"><a href="#2-拉取源码拉取源码到idea" class="headerlink" title="2.拉取源码拉取源码到idea"></a>2.拉取源码拉取源码到idea</h3><p>地址：<a href="https://github.com/apache/flume" target="_blank" rel="noopener">https://github.com/apache/flume</a></p>
<h3 id="3-将自己写的代码放入到源码中"><a href="#3-将自己写的代码放入到源码中" class="headerlink" title="3.将自己写的代码放入到源码中"></a>3.将自己写的代码放入到源码中</h3><p><img src="https://yerias.github.io/flume_img/flume-debug.png" alt="flume-debug"></p>
<h3 id="4-自己写的代码打包后放到远端服务器的lib目录下"><a href="#4-自己写的代码打包后放到远端服务器的lib目录下" class="headerlink" title="4.自己写的代码打包后放到远端服务器的lib目录下"></a>4.自己写的代码打包后放到远端服务器的lib目录下</h3><p><img src="https://yerias.github.io/flume_img/flume-jar.png" alt="flume-jar"></p>
<p>注意：除了这种方法，还可以直接修改源码，然后一起打包上传到服务器上</p>
<h3 id="5-启动flume服务"><a href="#5-启动flume服务" class="headerlink" title="5.启动flume服务"></a>5.启动flume服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup  /home/hadoop/app/apache-flume-1.7.0-bin/bin/flume-ng agent \</span><br><span class="line">-c /home/hadoop/app/apache-flume-1.7.0-bin/conf \</span><br><span class="line">-f /home/hadoop/MonitoringProject/exec_memory_kafka.properties \</span><br><span class="line">-n a1 \</span><br><span class="line">-Dflume.root.logger=DEBUG,console -Xmx20m -Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=y</span><br></pre></td></tr></table></figure>

<h3 id="6-配置启动应用"><a href="#6-配置启动应用" class="headerlink" title="6.配置启动应用"></a>6.配置启动应用</h3><p><img src="https://yerias.github.io/flume_img/%E9%85%8D%E7%BD%AE.png" alt="配置"></p>
<p>打上断点，启动后即可进入断点</p>
<p><img src="https://yerias.github.io/flume_img/%E6%9F%A5%E7%9C%8B.png" alt="查看"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2018/12/03/flume/3/">Flume的Channel选择器&amp;Flume的Sink选择器&amp;Channel的两种类型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Flume/">Flume</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Flume/">Flume</a></span><div class="content"><h2 id="Flume的Channel选择器"><a href="#Flume的Channel选择器" class="headerlink" title="Flume的Channel选择器"></a>Flume的Channel选择器</h2><p>Flume的Channel选择器有<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#replicating-channel-selector-default" target="_blank" rel="noopener">Replicating Channel Selector (default)</a>和<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#multiplexing-channel-selector" target="_blank" rel="noopener">Multiplexing Channel Selector</a>，作用分别是复制和多路分发，默认用的复制</p>
<p>下面我们用两个案例分别实现Replicating Channel Selector和Multiplexing Channel Selector</p>
<h3 id="Replicating-Channel-Selector"><a href="#Replicating-Channel-Selector" class="headerlink" title="Replicating Channel Selector"></a>Replicating Channel Selector</h3><ol>
<li><p>需要实现的功能</p>
<p><img src="https://yerias.github.io/flume_img/ReplicatingChannel.png" alt="ReplicatingChannel"></p>
</li>
<li><p>代码实现</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1 k2	#两个sink</span><br><span class="line">a1.channels = c1 c2 	#两个channel</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = netcat	#nc输入</span><br><span class="line">a1.sources.r1.bind = 0.0.0.0</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k2.type = logger	#第一个sink</span><br><span class="line"></span><br><span class="line">a1.sinks.k1.type = hdfs		#第二个sink</span><br><span class="line">a1.sinks.k1.hdfs.path = /flume/%y-%m-%d/%H/%M</span><br><span class="line">a1.sinks.k1.hdfs.filePrefix = replicating-</span><br><span class="line">a1.sinks.k1.hdfs.useLocalTimeStamp = true</span><br><span class="line">a1.sinks.k1.hdfs.fileType=DataStream</span><br><span class="line"></span><br><span class="line">a1.sources.r1.selector.type = replicating	#选择器</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory	#第一个memory</span><br><span class="line"></span><br><span class="line">a1.channels.c2.type = memory	#第二个memory</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1 c2	//source连上两个channel</span><br><span class="line">a1.sinks.k1.channel = c1	//channel1连上sink1</span><br><span class="line">a1.sinks.k2.channel = c2	//channel2连上sink2</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/nc-replicating-logger_and_hdfs.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>发送消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet localhost 44444</span><br></pre></td></tr></table></figure>

<p>结果：成功</p>
</li>
</ol>
<h3 id="Multiplexing-Channel-Selector"><a href="#Multiplexing-Channel-Selector" class="headerlink" title="Multiplexing Channel Selector"></a>Multiplexing Channel Selector</h3><ol>
<li><p>需要实现的功能</p>
<p><img src="https://yerias.github.io/flume_img/multiplexingChannel.jpg" alt="multiplexingChannel"></p>
<p>数据从Source到Channel中间会经过一个<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#static-interceptor" target="_blank" rel="noopener">拦截器</a>，拦截器中的Key和Value参数被添加到了所有的Event上，在经过<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#multiplexing-channel-selector" target="_blank" rel="noopener">选择器</a>的时候，会根据拦截器中的Event所带的Value值的不同发送到不同的Sink</p>
</li>
<li><p>代码实现</p>
<p>nc-memory-arvo1.conf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">a1.sources.r1.port = <span class="number">44441</span></span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = aliyun</span><br><span class="line">a1.sinks.k1.port = <span class="number">55555</span></span><br><span class="line"></span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line">a1.sources.r1.interceptors.i1.type = <span class="keyword">static</span></span><br><span class="line">a1.sources.r1.interceptors.i1.key = state</span><br><span class="line">a1.sources.r1.interceptors.i1.value = UA</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>nc-memory-arvo2.conf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">a1.sources.r1.port = <span class="number">44442</span></span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = aliyun</span><br><span class="line">a1.sinks.k1.port = <span class="number">55555</span></span><br><span class="line"></span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line">a1.sources.r1.interceptors.i1.type = <span class="keyword">static</span></span><br><span class="line">a1.sources.r1.interceptors.i1.key = state</span><br><span class="line">a1.sources.r1.interceptors.i1.value = UB</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>vim nc-memory-arvo3.conf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">a1.sources.r1.port = <span class="number">44443</span></span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = aliyun</span><br><span class="line">a1.sinks.k1.port = <span class="number">55555</span></span><br><span class="line"></span><br><span class="line">a1.sources.r1.interceptors = i1</span><br><span class="line">a1.sources.r1.interceptors.i1.type = <span class="keyword">static</span></span><br><span class="line">a1.sources.r1.interceptors.i1.key = state</span><br><span class="line">a1.sources.r1.interceptors.i1.value = UC</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>vim avro-memory-multi.conf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1 k2 k3</span><br><span class="line">a1.channels = c1 c2 c3</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = aliyun</span><br><span class="line">a1.sources.r1.port = <span class="number">55555</span></span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line">a1.sinks.k2.type = logger</span><br><span class="line"></span><br><span class="line">a1.sinks.k3.type = hdfs</span><br><span class="line">a1.sinks.k3.hdfs.path = /flume/%y-%m-%d/%H/%M</span><br><span class="line">a1.sinks.k3.hdfs.filePrefix = multiplexing-</span><br><span class="line">a1.sinks.k3.hdfs.useLocalTimeStamp = <span class="keyword">true</span></span><br><span class="line">a1.sinks.k3.hdfs.fileType=DataStream</span><br><span class="line">a1.sinks.k3.hdfs.writeFormat=Text</span><br><span class="line"></span><br><span class="line">a1.sources.r1.selector.type = multiplexing</span><br><span class="line">a1.sources.r1.selector.header = state</span><br><span class="line">a1.sources.r1.selector.mapping.UA = c1</span><br><span class="line">a1.sources.r1.selector.mapping.UB = c2</span><br><span class="line">a1.sources.r1.selector.<span class="keyword">default</span> = c3</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line">a1.channels.c2.type = memory</span><br><span class="line">a1.channels.c3.type = memory</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1 c2 c3</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c2</span><br><span class="line">a1.sinks.k3.channel = c3</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/nc-memory-arvo1.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/nc-memory-arvo2.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/nc-memory-arvo3.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/avro-memory-multi.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">telnet aliyun <span class="number">44441</span></span><br><span class="line">telnet aliyun <span class="number">44442</span></span><br><span class="line">telnet aliyun <span class="number">44443</span></span><br></pre></td></tr></table></figure>

<p>结果：成功</p>
</li>
</ol>
<h2 id="Flume的Sink选择器"><a href="#Flume的Sink选择器" class="headerlink" title="Flume的Sink选择器"></a>Flume的Sink选择器</h2><p>Flume的Sink选择器常用的有两种：<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#failover-sink-processor" target="_blank" rel="noopener">Failover Sink Processor</a>和<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#load-balancing-sink-processor" target="_blank" rel="noopener">Load balancing Sink Processor</a></p>
<h3 id="Failover-Sink-Processor"><a href="#Failover-Sink-Processor" class="headerlink" title="Failover Sink Processor"></a>Failover Sink Processor</h3><p>Failover Sink Processor可以在Agent中的Sink端做一个类似于灾备的Sink组，官方文档中介绍Failover Sink Processor维护一个按优先级排序的Sink列表，确保只要有一个可用的Sink，就会处理Event。</p>
<p>Failover Sink Processor的工作方式是将多个Sink组成Sinks组，他们有一个优先级的顺序关系，优先级大的先被激活。如果Sink在发送Event时失败，则下一个具有最高优先级的Sink将会用于发送Event。例如，优先级为100的接收器在优先级为80的接收器之前被激活。如果没有指定优先级，则根据在配置中指定Sink的顺序确定优先级。</p>
<table>
<thead>
<tr>
<th align="left">Property Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>sinks</strong></td>
<td align="left">–</td>
<td align="left">Space-separated list of sinks that are participating in the group</td>
</tr>
<tr>
<td align="left"><strong>processor.type</strong></td>
<td align="left"><code>default</code></td>
<td align="left">The component type name, needs to be <code>failover</code></td>
</tr>
<tr>
<td align="left"><strong>processor.priority.</strong></td>
<td align="left">–</td>
<td align="left">Priority value. <sinkName> must be one of the sink instances associated with the current sink group A higher priority value Sink gets activated earlier. A larger absolute value indicates higher priority</td>
</tr>
<tr>
<td align="left">processor.maxpenalty</td>
<td align="left">30000</td>
<td align="left">The maximum backoff period for the failed Sink (in millis)</td>
</tr>
</tbody></table>
<ol>
<li><p>需要实现的功能</p>
<p>​    ![Failover Sink Processor](<a href="https://yerias.github.io/flume_img/Failover">https://yerias.github.io/flume_img/Failover</a> Sink Processor.jpg)</p>
<p>Agent1发送Event，如果Sink组中的任意一个Sink接收Event失败，其他的Sink激活继续接收</p>
</li>
<li><p>代码实现</p>
<p>nc-memory-avro.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1 k2</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = aliyun</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line">a1.sinkgroups = g1</span><br><span class="line">a1.sinkgroups.g1.sinks = k1 k2</span><br><span class="line">a1.sinkgroups.g1.processor.type = failover</span><br><span class="line">a1.sinkgroups.g1.processor.priority.k1 = 5</span><br><span class="line">a1.sinkgroups.g1.processor.priority.k2 = 10</span><br><span class="line">a1.sinkgroups.g1.processor.maxpenalty = 10000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = aliyun</span><br><span class="line">a1.sinks.k1.port = 55551</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k2.type = avro</span><br><span class="line">a1.sinks.k2.hostname = aliyun</span><br><span class="line">a1.sinks.k2.port = 55552</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c1</span><br></pre></td></tr></table></figure>

<p>avro1-memory-logger.conf </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = aliyun</span><br><span class="line">a1.sources.r1.port = 55551</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>avro2-memory-logger.conf </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = aliyun</span><br><span class="line">a1.sources.r1.port = 55552</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/failover/nc-memory-avro.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/failover/avro1-memory-logger.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/failover/avro2-memory-logger.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet aliyun 44444</span><br></pre></td></tr></table></figure>

<p>结果：成功</p>
</li>
</ol>
<h3 id="Load-balancing-Sink-Processor"><a href="#Load-balancing-Sink-Processor" class="headerlink" title="Load balancing Sink Processor"></a>Load balancing Sink Processor</h3><p>Load balancing Sink Processor提供了在多个Sink 上实现负载均衡的能力。它维护一个活动Sink的索引列表，发送的Event必须分布在这个列表上。实现支持通过round_robin或random分配负载。默认为round_robin类型，但是可以通过配置覆盖。自定义选择机制是通过继承AbstractSinkSelector的自定义类来支持的。</p>
<p>调用时，选择器使用其配置的选择机制选择下一个Sink 调用它。对于round_robin和random，如果选择的Sink 不能传递Event，处理器将通过其配置的选择机制选择下一个可用的Sink 。这种方法不会将失败的Sink加入黑名单，而是继续乐观地尝试每个可用的Sink。如果所有的Sink调用都导致失败，则整个程序运行失败</p>
<p>如果启用了backoff，Sink处理器将把失败的Sink列入黑名单，超过给定的时间后删除他们。当超时结束时，如果Sink仍然没有响应，超时将以指数方式增加，以避免在没有响应的Sink上陷入长时间的等待。禁用此功能后，在循环中，所有失败的Sink负载将按行传递到下一个Sink，因此不是均匀的。</p>
<table>
<thead>
<tr>
<th align="left">Property Name</th>
<th align="left">Default</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>processor.sinks</strong></td>
<td align="left">–</td>
<td align="left">Space-separated list of sinks that are participating in the group</td>
</tr>
<tr>
<td align="left"><strong>processor.type</strong></td>
<td align="left"><code>default</code></td>
<td align="left">The component type name, needs to be <code>load_balance</code></td>
</tr>
<tr>
<td align="left">processor.backoff</td>
<td align="left">false</td>
<td align="left">Should failed sinks be backed off exponentially.</td>
</tr>
<tr>
<td align="left">processor.selector</td>
<td align="left"><code>round_robin</code></td>
<td align="left">Selection mechanism. Must be either <code>round_robin</code>, <code>random</code> or FQCN of custom class that inherits from <code>AbstractSinkSelector</code></td>
</tr>
<tr>
<td align="left">processor.selector.maxTimeOut</td>
<td align="left">30000</td>
<td align="left">Used by backoff selectors to limit exponential backoff (in milliseconds)</td>
</tr>
</tbody></table>
<ol>
<li><p>需要实现的功能</p>
<p>![Load balancing Sink Processor](<a href="https://yerias.github.io/flume_img/flume_img/Load">https://yerias.github.io/flume_img/flume_img/Load</a> balancing Sink Processor.jpg)</p>
<p>Agent1发送Event，Sink组中的每个Sink根据配置的选择器机制选择发送到哪一个Sink</p>
</li>
<li><p>代码实现</p>
<p>nc-memory-avro.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1 k2</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = netcat</span><br><span class="line">a1.sources.r1.bind = aliyun</span><br><span class="line">a1.sources.r1.port = 44444</span><br><span class="line"></span><br><span class="line">a1.sinkgroups = g1</span><br><span class="line">a1.sinkgroups.g1.sinks = k1 k2</span><br><span class="line">a1.sinkgroups.g1.processor.type = load_balance</span><br><span class="line">a1.sinkgroups.g1.processor.backoff = true</span><br><span class="line">a1.sinkgroups.g1.processor.selector = random</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = avro</span><br><span class="line">a1.sinks.k1.hostname = aliyun</span><br><span class="line">a1.sinks.k1.port = 55551</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k2.type = avro</span><br><span class="line">a1.sinks.k2.hostname = aliyun</span><br><span class="line">a1.sinks.k2.port = 55552</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br><span class="line">a1.sinks.k2.channel = c1</span><br></pre></td></tr></table></figure>

<p>avro1-memory-logger.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Name the components on this agent</span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"># Describe/configure the source</span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = aliyun</span><br><span class="line">a1.sources.r1.port = 55551</span><br><span class="line"></span><br><span class="line"># Describe the sink</span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"># Use a channel which buffers events in memory</span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"># Bind the source and sink to the channel</span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>

<p>avro2-memory-logger.conf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Name the components on this agent</span></span><br><span class="line">a1.sources = r1</span><br><span class="line">a1.sinks = k1</span><br><span class="line">a1.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe/configure the <span class="built_in">source</span></span></span><br><span class="line">a1.sources.r1.type = avro</span><br><span class="line">a1.sources.r1.bind = aliyun</span><br><span class="line">a1.sources.r1.port = 55552</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Describe the sink</span></span><br><span class="line">a1.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use a channel <span class="built_in">which</span> buffers events <span class="keyword">in</span> memory</span></span><br><span class="line">a1.channels.c1.type = memory</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bind the <span class="built_in">source</span> and sink to the channel</span></span><br><span class="line">a1.sources.r1.channels = c1</span><br><span class="line">a1.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/load_balancing/nc-memory-avro.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/load_balancing/avro1-memory-logger.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flume-ng agent \</span><br><span class="line">--name a1 \</span><br><span class="line">--conf $FLUME_HOME/conf \</span><br><span class="line">--conf-file $FLUME_HOME/script/load_balancing/avro2-memory-logger.conf \</span><br><span class="line">-Dflume.root.logger=INFO,console</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet aliyun 44444</span><br></pre></td></tr></table></figure>

<p>结果：成功</p>
</li>
</ol>
<h2 id="Channel的两种类型"><a href="#Channel的两种类型" class="headerlink" title="Channel的两种类型"></a>Channel的两种类型</h2><p>Channel有File和Memory两种类型，Memory的特点是使用内存，速度快，但是安全性没有保障；File的特点是数据都会写进文件，速度慢，但是安全性高。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/7/">&lt;&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/9/">&gt;&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>