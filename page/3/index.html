<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BigData Developer"><meta name="keywords" content="yerias,TUNANのBlog,BigData"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">129</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">TUNANのBlog</div><div id="site-sub-title">感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/16/spark/17/">数据列自动推导&amp;数据错误执行模式&amp;UDAF&amp;UDTF&amp;解读Spark SQL执行计划优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>数据列自动推导</li>
<li>数据错误执行模式</li>
<li>UDAF</li>
<li>UDTF</li>
<li>解读Spark SQL执行计划优化</li>
</ol>
<h2 id="数据列自动推导"><a href="#数据列自动推导" class="headerlink" title="数据列自动推导"></a>数据列自动推导</h2><ol>
<li><p>源数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">a|b|c</span><br><span class="line"><span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span></span><br><span class="line"><span class="number">4</span>|tunan|<span class="number">6</span></span><br><span class="line"><span class="number">7</span>|<span class="number">8</span>|<span class="number">9.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码处理</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">    .builder()</span><br><span class="line">    .master(<span class="string">"local[2]"</span>)</span><br><span class="line">    .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    .getOrCreate()</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">val</span> csvDF: <span class="type">DataFrame</span> = spark.read</span><br><span class="line">    .format(<span class="string">"csv"</span>)</span><br><span class="line">    .option(<span class="string">"header"</span>,<span class="string">"true"</span>)</span><br><span class="line">    .option(<span class="string">"sep"</span>,<span class="string">"|"</span>)</span><br><span class="line">    .option(<span class="string">"interSchema"</span>,<span class="string">"true"</span>)</span><br><span class="line">    .load(<span class="string">"tunan-spark-sql/data/test.csv"</span>)</span><br><span class="line">   </span><br><span class="line">  csvDF.printSchema()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印数据Schema信息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- a: integer (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- b: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- c: double (nullable = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数据错误执行模式"><a href="#数据错误执行模式" class="headerlink" title="数据错误执行模式"></a>数据错误执行模式</h2><p>在Spark中，读取数据时，遇到错误数据或者脏数据时，我们可以使用option设置mode，区分将错误数据是默认处理<code>PERMISSIVE</code>，还是丢弃数据<code>DROPMALFORMED</code>，还是快速失败<code>FAILFAST</code>，这些方法可以在ParseMode.scala</p>
<ol>
<li><p>源数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="string">"a"</span>:<span class="number">4</span>,:<span class="number">5</span>,<span class="string">"c"</span>:<span class="number">6</span>&#125;</span><br><span class="line">&#123;<span class="string">"a"</span>:<span class="number">7</span>,<span class="string">"b"</span>:<span class="number">8</span>,<span class="string">"c"</span>:<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jsonDF: <span class="type">DataFrame</span> = spark.read.json(<span class="string">"tunan-spark-sql/data/test.json"</span>)</span><br><span class="line">jsonDF.show()</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+----------------+----+----+----+</span><br><span class="line">| _corrupt_record|   a|   b|   c|</span><br><span class="line">+----------------+----+----+----+</span><br><span class="line">|            <span class="literal">null</span>|   <span class="number">1</span>|   <span class="number">2</span>|   <span class="number">3</span>|</span><br><span class="line">|&#123;<span class="string">"a"</span>:<span class="number">4</span>,:<span class="number">5</span>,<span class="string">"c"</span>:<span class="number">6</span>&#125;|<span class="literal">null</span>|<span class="literal">null</span>|<span class="literal">null</span>|</span><br><span class="line">|            <span class="literal">null</span>|   <span class="number">7</span>|   <span class="number">8</span>|   <span class="number">9</span>|</span><br><span class="line">+----------------+----+----+----+</span><br></pre></td></tr></table></figure>

<p>如果没有在option中设置mode选项，默认为<code>PERMISSIVE</code>，通过_corrupt_record列打印出错误信息</p>
</li>
<li><p>使用option设置mode为<code>DROPMALFORMED</code>，如果碰到错误的数据，则自动丢弃</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jsonDF: <span class="type">DataFrame</span> = spark.read.option(<span class="string">"mode"</span>,<span class="string">"DROPMALFORMED"</span>).json(<span class="string">"tunan-spark-sql/data/test.json"</span>)</span><br><span class="line">jsonDF.show()</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+---+---+---+</span><br><span class="line">|  a|  b|  c|</span><br><span class="line">+---+---+---+</span><br><span class="line">|  <span class="number">1</span>|  <span class="number">2</span>|  <span class="number">3</span>|</span><br><span class="line">|  <span class="number">7</span>|  <span class="number">8</span>|  <span class="number">9</span>|</span><br><span class="line">+---+---+---+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="UDAF"><a href="#UDAF" class="headerlink" title="UDAF"></a>UDAF</h2><ol>
<li><p>自定义一个UDAF的class或者object，作为具体的逻辑实现，需要继承<code>UserDefinedAggregateFunction</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AgeAvgUDAF</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span></span>&#123;</span><br><span class="line">    <span class="comment">//输入类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"input"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>)::<span class="type">Nil</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//聚合内部中的buffer类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"sums"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>)::</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"num"</span>,<span class="type">LongType</span>,<span class="literal">true</span>)::<span class="type">Nil</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入数据类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">DoubleType</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入数据类型是否和输出数据类型相等</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚合内部buffer的初始化</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      buffer(<span class="number">0</span>) = <span class="number">0.0</span></span><br><span class="line">      buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分区内更新聚合buffer</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>, input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      buffer.update(<span class="number">0</span>,buffer.getDouble(<span class="number">0</span>)+input.getDouble(<span class="number">0</span>))</span><br><span class="line">      buffer.update(<span class="number">1</span>,buffer.getLong(<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分区间合并</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>, buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      buffer1.update(<span class="number">0</span>,buffer1.getDouble(<span class="number">0</span>)+buffer2.getDouble(<span class="number">0</span>))</span><br><span class="line">      buffer1.update(<span class="number">1</span>,buffer1.getLong(<span class="number">1</span>)+buffer2.getLong(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终计算</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">      buffer.getDouble(<span class="number">0</span>)/buffer.getLong(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册并使用UDAF</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">     .builder()</span><br><span class="line">     .master(<span class="string">"local[2]"</span>)</span><br><span class="line">     .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">     .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据源</span></span><br><span class="line">   <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">Row</span>]()</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"zhangsan"</span>,<span class="number">18</span>,<span class="string">"男"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"lisi"</span>,<span class="number">20</span>,<span class="string">"男"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"wangwu"</span>,<span class="number">26</span>,<span class="string">"女"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"翠翠"</span>,<span class="number">18</span>,<span class="string">"女"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"闰土"</span>,<span class="number">8</span>,<span class="string">"男"</span>))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自定义Schema</span></span><br><span class="line">   <span class="keyword">val</span> schema = <span class="type">StructType</span>(</span><br><span class="line">     <span class="type">StructField</span>(<span class="string">"name"</span>, <span class="type">StringType</span>, <span class="literal">true</span>)::</span><br><span class="line">     <span class="type">StructField</span>(<span class="string">"age"</span>, <span class="type">IntegerType</span>, <span class="literal">true</span>)::</span><br><span class="line">     <span class="type">StructField</span>(<span class="string">"sex"</span>, <span class="type">StringType</span>, <span class="literal">true</span>)::<span class="type">Nil</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="comment">//创建df</span></span><br><span class="line">   <span class="keyword">val</span> df = spark.createDataFrame(list, schema)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建视图</span></span><br><span class="line">   df.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//注册UDAF</span></span><br><span class="line">   spark.udf.register(<span class="string">"age_avg_udaf"</span>,<span class="type">AgeAvgUDAF</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//使用UDAF</span></span><br><span class="line">   spark.sql(<span class="string">"select sex,age_avg_udaf(age) as ave_age from people group by sex"</span>).show()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+---+---------+</span><br><span class="line">|sex|  ave_age|</span><br><span class="line">+---+---------+</span><br><span class="line">| 男|    <span class="number">15.33</span>|</span><br><span class="line">| 女|     <span class="number">22.0</span>|</span><br><span class="line">+---+---------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="UDTF"><a href="#UDTF" class="headerlink" title="UDTF"></a>UDTF</h2><p>UDTF还在研究，先搞个简单的案例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ExplodeUDTF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .master(<span class="string">"local[2]"</span>)</span><br><span class="line">      .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义schema  </span></span><br><span class="line">    <span class="keyword">val</span> schema = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"teacher"</span>, <span class="type">StringType</span>, <span class="literal">true</span>) ::</span><br><span class="line">        <span class="type">StructField</span>(<span class="string">"sources"</span>, <span class="type">StringType</span>, <span class="literal">true</span>) :: <span class="type">Nil</span></span><br><span class="line">    )</span><br><span class="line">	<span class="comment">// 自定义数据源</span></span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">Row</span>]()</span><br><span class="line">    list.add(<span class="type">Row</span>(<span class="string">"tunan"</span>, <span class="string">"hive,spark,flink"</span>))</span><br><span class="line">    list.add(<span class="type">Row</span>(<span class="string">"xiaoqi"</span>, <span class="string">"cdh,kafka,hbase"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建临时视图</span></span><br><span class="line">    <span class="keyword">val</span> df = spark.createDataFrame(list, schema)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="comment">// 使用flatMap拆分</span></span><br><span class="line">    df.flatMap(x =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> line = <span class="keyword">new</span> <span class="type">ListBuffer</span>[(<span class="type">String</span>, <span class="type">String</span>)]()</span><br><span class="line">      <span class="keyword">val</span> sources = x.getString(<span class="number">1</span>).split(<span class="string">","</span>)</span><br><span class="line">      <span class="keyword">for</span> (source &lt;- sources)&#123;</span><br><span class="line">        line.append((x.getString(<span class="number">0</span>),source))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回</span></span><br><span class="line">      line</span><br><span class="line">    &#125;).toDF(<span class="string">"teacher"</span>,<span class="string">"source"</span>).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">|teacher|source|</span><br><span class="line">+-------+------+</span><br><span class="line">|  tunan|  hive|</span><br><span class="line">|  tunan| spark|</span><br><span class="line">|  tunan| flink|</span><br><span class="line">| xiaoqi|   cdh|</span><br><span class="line">| xiaoqi| kafka|</span><br><span class="line">| xiaoqi| hbase|</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure>

<h2 id="解读Spark-SQL执行计划优化"><a href="#解读Spark-SQL执行计划优化" class="headerlink" title="解读Spark SQL执行计划优化"></a>解读Spark SQL执行计划优化</h2><ol>
<li><p>建空表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sqltest (<span class="keyword">key</span> <span class="keyword">string</span>,<span class="keyword">value</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">extended</span> <span class="keyword">select</span> a.key*(<span class="number">3</span>*<span class="number">5</span>),b.value <span class="keyword">from</span> sqltest a <span class="keyword">join</span> sqltest b <span class="keyword">on</span> a.key=b.key <span class="keyword">and</span> a.key &gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解读执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 解析逻辑计划，做些简单的解析</span><br><span class="line">== Parsed Logical Plan ==</span><br><span class="line">'Project [unresolvedalias(('a.key * (3 * 5)), None), 'b.value]</span><br><span class="line">+- 'Join Inner, (('a.key = 'b.key) &amp;&amp; ('a.key &gt; 3))</span><br><span class="line">   :- 'SubqueryAlias `a`</span><br><span class="line">   :  +- 'UnresolvedRelation `sqltest`</span><br><span class="line">   +- 'SubqueryAlias `b`</span><br><span class="line">      +- 'UnresolvedRelation `sqltest`</span><br><span class="line"></span><br><span class="line">// 分析逻辑计划，解析出了数据类型，拿到数据库和表，拿到了序列化方式                           </span><br><span class="line">== Analyzed Logical Plan ==</span><br><span class="line">(CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE)): double, value: string</span><br><span class="line">Project [(cast(key<span class="comment">#2 as double) * cast((3 * 5) as double)) AS (CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE))#6, value#5]</span></span><br><span class="line">+- Join Inner, ((key<span class="comment">#2 = key#4) &amp;&amp; (cast(key#2 as int) &gt; 3))</span></span><br><span class="line">   :- SubqueryAlias `a`</span><br><span class="line">   :  +- SubqueryAlias `default`.`sqltest`</span><br><span class="line">   :     +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#2, value#3]</span></span><br><span class="line">   +- SubqueryAlias `b`</span><br><span class="line">      +- SubqueryAlias `default`.`sqltest`</span><br><span class="line">         +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#4, value#5]</span></span><br><span class="line"></span><br><span class="line">// 优化逻辑计划，数值类型的运算直接拿到结果，解析过滤条件</span><br><span class="line">== Optimized Logical Plan ==</span><br><span class="line">Project [(cast(key<span class="comment">#2 as double) * 15.0) AS (CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE))#6, value#5]</span></span><br><span class="line">+- Join Inner, (key<span class="comment">#2 = key#4)</span></span><br><span class="line">   :- Project [key<span class="comment">#2]</span></span><br><span class="line">   :  +- Filter (isnotnull(key<span class="comment">#2) &amp;&amp; (cast(key#2 as int) &gt; 3))</span></span><br><span class="line">   :     +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#2, value#3]</span></span><br><span class="line">   +- Filter ((cast(key<span class="comment">#4 as int) &gt; 3) &amp;&amp; isnotnull(key#4))</span></span><br><span class="line">      +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#4, value#5]</span></span><br><span class="line"></span><br><span class="line">//物理计划，join方式为SortMergeJoin，数据使用hashpartitioning保存，扫描表的方式是HiveTableRelation</span><br><span class="line">== Physical Plan ==</span><br><span class="line">*(5) Project [(cast(key#2 as double) * 15.0) AS (CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE))#6, value#5]</span><br><span class="line">+- *(5) SortMergeJoin [key#2], [key#4], Inner</span><br><span class="line">   :- *(2) Sort [key#2 ASC NULLS FIRST], false, 0</span><br><span class="line">   :  +- Exchange hashpartitioning(key<span class="comment">#2, 200)</span></span><br><span class="line">   :     +- *(1) Filter (isnotnull(key#2) &amp;&amp; (cast(key#2 as int) &gt; 3))</span><br><span class="line">   :        +- Scan hive default.sqltest [key<span class="comment">#2], HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key#2, value#3]</span></span><br><span class="line">   +- *(4) Sort [key#4 ASC NULLS FIRST], false, 0</span><br><span class="line">      +- Exchange hashpartitioning(key<span class="comment">#4, 200)</span></span><br><span class="line">         +- *(3) Filter ((cast(key#4 as int) &gt; 3) &amp;&amp; isnotnull(key#4))</span><br><span class="line">            +- Scan hive default.sqltest [key<span class="comment">#4, value#5], HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key#4, value#5]</span></span><br></pre></td></tr></table></figure>

<p>可以简单的看做四步，分别是解析逻辑计划、分析逻辑计划、优化逻辑计划、物理执行计划</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/15/jvm/1/">JVM之运行时数据区</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>jvm命令</li>
<li>jvm的运行时数据区</li>
<li>jvm会发生哪些ERROR</li>
<li>从一个class出发理解数据区</li>
</ol>
<h2 id="jvm命令"><a href="#jvm命令" class="headerlink" title="jvm命令"></a>jvm命令</h2><h3 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h3><ol>
<li>标准: 稳定的，长期没有变化</li>
<li>X: 相对变化较少的</li>
<li>XX: 变化较大，JVM调优重点</li>
</ol>
<p>设置参数时，idea指定在VM options里面，命令行直接加在java命令后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xss10m -XX:+PrintGCDetails JVMParams</span><br></pre></td></tr></table></figure>

<h3 id="常见的XX类型的参数"><a href="#常见的XX类型的参数" class="headerlink" title="常见的XX类型的参数"></a>常见的XX类型的参数</h3><ol>
<li><p>-XX:+PrintGCDetails: 打印GC日志</p>
</li>
<li><p>-XX:+PrintFlagsInitial: 打印所有初始的参数信息</p>
</li>
<li><p>-XX:+PrintFlagsFinal: 打印所有最终的参数信息</p>
</li>
<li><p>-Xms设置堆的最小空间大小。</p>
</li>
<li><p>-Xmx设置堆的最大空间大小。</p>
</li>
<li><p>-XX:NewSize设置新生代最小空间大小。</p>
</li>
<li><p>-XX:MaxNewSize设置新生代最大空间大小。</p>
</li>
<li><p>-XX:PermSize设置永久代最小空间大小。</p>
</li>
<li><p>-XX:MaxPermSize设置永久代最大空间大小。</p>
</li>
<li><p>-Xss设置每个线程的堆栈大小。</p>
</li>
<li><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制</p>
<p> <strong>老年代空间大小=堆空间大小-年轻代大空间大小</strong></p>
</li>
</ol>
<p>例如：</p>
<p>java -XX:+PrintFlagsFinal -version </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">uintx MaxHeapSize             := <span class="number">2048917504</span>     &#123;product&#125;</span><br><span class="line">intx MaxInlineLevel            = <span class="number">9</span>              &#123;product&#125;</span><br><span class="line">intx MaxInlineSize    		   = <span class="number">35</span>             &#123;product&#125;</span><br><span class="line">bool ParGCTrimOverflow   	   = <span class="keyword">true</span>           &#123;product&#125;</span><br><span class="line">bool ParGCUseLocalOverflow     = <span class="keyword">false</span>          &#123;product&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面只显示部分参数，但是能够说明我们需要理解的内容，即 ‘=’ 表示默认值，‘:=’ 表示被修改过的值。同时还有数值类型和布尔类型。</p>
<h3 id="几个特殊的XX类型参数"><a href="#几个特殊的XX类型参数" class="headerlink" title="几个特殊的XX类型参数"></a>几个特殊的XX类型参数</h3><p>-Xms、-Xmx、-Xss 实际上是XX类型的缩写</p>
<p>-Xms ==&gt; -XX:InitialHeapSize: 表示为: -Xms10m<br>-Xmx ==&gt; -XX:MaxHeapSize: 表示为: -Xmx10m<br>-Xss ==&gt; -XX:ThreadStackSize</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><p>查看java进程：jps</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jps</span><br><span class="line"><span class="number">13612</span> JVMParams</span><br><span class="line"><span class="number">13644</span> Jps</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看java进程的参数信息<br>jinfo -flag name pid </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag MaxHeapSize <span class="number">13612</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">2048917504</span></span><br><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag InitialHeapSize <span class="number">13612</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">130023424</span></span><br><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag ThreadStackSize <span class="number">13612</span></span><br><span class="line">-XX:ThreadStackSize=<span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>怎么理解-XX:MaxHeapSize=2048917504，-XX:InitialHeapSize=130023424 ?</p>
<p>分析：</p>
<p>我主机的物理内存为8G，2048917504k = 1.9G，130023424  = 124M</p>
<p>理论上heap的最大值为物理内存的1/4，最小值为物理内存的1/64</p>
<p>但是一般情况下，我们会把MaxHeapSize和InitialHeapSize设置相同的值，防止内存抖动</p>
</li>
<li><p>查看java进程的默认和设置的参数</p>
<p>jinfo -flags pid </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flags  <span class="number">13612</span></span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount=<span class="number">2</span> ...</span><br><span class="line">Command line:  -Xss10m -XX:+PrintGCDetails ...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jvm的运行时数据区"><a href="#jvm的运行时数据区" class="headerlink" title="jvm的运行时数据区"></a>jvm的运行时数据区</h2><p><img src="https://yerias.github.io/java_img/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="运行时数据区"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是每个线程私有的</p>
<p>程序计数器是一块较小的内存空间，它可以看做是当前线程的行号指示器，这在多线程环境下非常有用。使得线程切换后能够恢复到正确的执行位置。</p>
<p>在java虚拟机规范中，这是唯一一个没有规定任何OutOfMemoryError的地方</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>java虚拟机栈也是每个线程私有的，它的生命周期和线程相同</p>
<p>虚拟机栈描述的是java方法执行的线程内存模型: 每个方法被执行的时候，java虚拟机栈都会同步创建一个Frame(栈帧)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>最常用的就是局部变量表，局部变量表存放了编译期可知的各种java虚拟机的基本数据类型(boolean、byte、char、sort、int、long、float、double)、对象引用(reference类型)和returnAddress类型，这部分在后面讲有详细的解释。</p>
<p>在java虚拟机规范中，这个区域可能存在两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverflowError异常，常见的有循环调用方法名；如果java虚拟机栈容量可以动态扩展，当栈无法申请到足够的内存时就会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈是线程私有的</p>
<p>本地方法栈与虚拟机栈所发挥的作用是非常类似的，其区别只是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为本地(native)方法服务</p>
<p>常见的本地方法有getClass、hashCode、clone、notify、notifyAll、wait、sleep等</p>
<p>与java虚拟机栈一样，本地方法栈也会在栈深度溢出的时候或者栈扩展失败的时候抛出StackOutflowError和OutOfMemoryError异常。</p>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>java堆是所有线程共享的，是虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。</p>
<p>此内存区域的唯一目的是存放对象实例，对象实例包括对象和数组。</p>
<p>如果在java堆中没有内存完成实例分配，并且堆也无法扩展，java虚拟机将会抛出OutOfMemoryError异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是所有线程共享的</p>
<p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，简单点说就是Class。</p>
<p>方法区只是java虚拟机的规范，它属于堆的一个逻辑部分，为了和堆区分开，也叫非堆。在jdk8之前，方法区的具体实现叫做永久代，</p>
<ol>
<li>由于类及方法的信息大小很难确定，所以内存设置小了会发生OOM，设置大了又浪费</li>
<li>GC复杂度高，回收效率低</li>
<li>合并 HotSpot 与 JRockit </li>
</ol>
<p>所以在jdk8完全用元空间替换了永久代，元空间直接使用的系统内存。</p>
<p>在java虚拟机规范中，如果方法区无法满足内存分配需求时，会抛出OouOfMemoryError</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是java虚拟机规范中定义的内存区域，但是这部分也会被频繁使用，所以也可能会抛出OutOfMemoryError。</p>
<h2 id="jvm会发生哪些ERROR"><a href="#jvm会发生哪些ERROR" class="headerlink" title="jvm会发生哪些ERROR"></a>jvm会发生哪些ERROR</h2><h3 id="java堆内存OOM异常测试"><a href="#java堆内存OOM异常测试" class="headerlink" title="java堆内存OOM异常测试"></a>java堆内存OOM异常测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx10m -Xms10m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid184.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">10209413</span> bytes in <span class="number">0.080</span> secs]</span><br></pre></td></tr></table></figure>

<h3 id="java虚拟机栈和本地方法栈SOF测试"><a href="#java虚拟机栈和本地方法栈SOF测试" class="headerlink" title="java虚拟机栈和本地方法栈SOF测试"></a>java虚拟机栈和本地方法栈SOF测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss2M</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF stackSOF = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackSOF.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈深度："</span>+stackSOF.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">栈深度：<span class="number">41075</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>

<h3 id="java虚拟机栈和本地方法栈OOM测试"><a href="#java虚拟机栈和本地方法栈OOM测试" class="headerlink" title="java虚拟机栈和本地方法栈OOM测试"></a>java虚拟机栈和本地方法栈OOM测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss4m</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackleakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackleakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>死机</p>
<h3 id="方法区和运行时常量池OOM"><a href="#方法区和运行时常量池OOM" class="headerlink" title="方法区和运行时常量池OOM"></a>方法区和运行时常量池OOM</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:PerSize=<span class="number">6</span>m -XX:MaxPermSize=<span class="number">6</span>M</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>jdk8没有测试出来</p>
<h2 id="从一个class出发理解数据区"><a href="#从一个class出发理解数据区" class="headerlink" title="从一个class出发理解数据区"></a>从一个class出发理解数据区</h2><p><img src="https://yerias.github.io/java_img/class%E7%B1%BB%E5%AF%B9%E6%AF%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="class类对比运行时数据区"></p>
<p>如图所示，很容易的理解各区分别保存java代码中的哪些部分</p>
<p>堆区: 保存的People对象</p>
<p>栈区: 保存的栈帧，栈帧中保存了引用name和age和引用people</p>
<p>方法区: 保存的People.class相关的，包括类型信息、常量、静态变量sss</p>
<p>运行时常量池: 保存name和age字符串内容</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/15/spark/16/">从jdbc的角度解读外部数据源</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>首先了解三个trait，分别是BaseRelation、TableScan/PrunedScan/PrunedFilteredScan、<del>InsertableRelation</del>、RelationProvider，他们的功能在源码中解读。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代表了一个抽象的数据源。该数据源由一行行有着已知schema的数据组成（关系表）。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRelation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schema</span></span>: <span class="type">StructType</span>	<span class="comment">//schema *</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sizeInBytes</span></span>: <span class="type">Long</span> = sqlContext.conf.defaultSizeInBytes</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">needConversion</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unhandledFilters</span></span>(filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">Array</span>[<span class="type">Filter</span>] = filters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于扫描整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TableScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于裁剪整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrunedScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于裁剪并过滤整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrunedFilteredScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>], filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据的时候实现，设置overwrite是否为true</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertableRelation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">DataFrame</span>, overwrite: <span class="type">Boolean</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为自定义的数据源类型生成一个新的Relation对象</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RelationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个新的Relation</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(sqlContext: <span class="type">SQLContext</span>, parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jdbc实现"><a href="#jdbc实现" class="headerlink" title="jdbc实现"></a>jdbc实现</h2><p>JdbcRelationProvider (最初也是最终的地方)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdbcRelationProvider</span> <span class="keyword">extends</span> <span class="title">CreatableRelationProvider</span></span></span><br><span class="line"><span class="class"><span class="keyword">with</span> <span class="title">RelationProvider</span> <span class="keyword">with</span> <span class="title">DataSourceRegister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">shortName</span></span>(): <span class="type">String</span> = <span class="string">"jdbc"</span> <span class="comment">//简称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(</span><br><span class="line">        sqlContext: <span class="type">SQLContext</span>,</span><br><span class="line">        parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span> = &#123;	<span class="comment">//所有options参数以map形式传入</span></span><br><span class="line">        <span class="keyword">val</span> jdbcOptions = <span class="keyword">new</span> <span class="type">JDBCOptions</span>(parameters) <span class="comment">//把参数传入和系统参数匹配</span></span><br><span class="line">        <span class="keyword">val</span> resolver = sqlContext.conf.resolver 	<span class="comment">//忽略大小写</span></span><br><span class="line">        <span class="keyword">val</span> timeZoneId = sqlContext.conf.sessionLocalTimeZone 	<span class="comment">//拿到时区</span></span><br><span class="line">        <span class="keyword">val</span> schema = <span class="type">JDBCRelation</span>.getSchema(resolver, jdbcOptions) 	<span class="comment">//传入参数，拿到schema</span></span><br><span class="line">        <span class="keyword">val</span> parts = <span class="type">JDBCRelation</span>.columnPartition(schema, resolver, timeZoneId,  jdbcOptions) <span class="comment">//拿到分区</span></span><br><span class="line">        <span class="type">JDBCRelation</span>(schema, parts, jdbcOptions)(sqlContext.sparkSession)  <span class="comment">//拿到RDD[R]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getSchema </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSchema</span></span>(resolver: <span class="type">Resolver</span>, jdbcOptions: <span class="type">JDBCOptions</span>): <span class="type">StructType</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tableSchema = <span class="type">JDBCRDD</span>.resolveTable(jdbcOptions)   <span class="comment">//传入参数，解析table，拿到Schame</span></span><br><span class="line">    jdbcOptions.customSchema <span class="keyword">match</span> &#123; <span class="comment">//模式匹配</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(customSchema) =&gt; <span class="type">JdbcUtils</span>.getCustomSchema( </span><br><span class="line">            tableSchema, customSchema, resolver)	<span class="comment">// 返回定制的Schema</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; tableSchema 	<span class="comment">//返回直接的Schema</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolveTable (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolveTable</span></span>(options: <span class="type">JDBCOptions</span>): <span class="type">StructType</span> = &#123; 	<span class="comment">//传入参数，拿到Schame</span></span><br><span class="line">    <span class="keyword">val</span> url = options.url 	<span class="comment">//拿到url：jdbc:mysql://hadoop:3306/</span></span><br><span class="line">    <span class="keyword">val</span> table = options.tableOrQuery	<span class="comment">//拿到table：access_dw.dws_ad_phone_type_dist</span></span><br><span class="line">    <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url) <span class="comment">//拿到方言：MySQLDialect</span></span><br><span class="line">    <span class="keyword">val</span> conn: <span class="type">Connection</span> = <span class="type">JdbcUtils</span>.createConnectionFactory(options)() <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> statement = conn.prepareStatement(dialect.getSchemaQuery(table)) <span class="comment">//拿到sql：com.mysql.jdbc.JDBC42PreparedStatement@5bda157e: SELECT * FROM access_dw.dws_ad_phone_type_dist WHERE 1=0</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement.setQueryTimeout(options.queryTimeout) <span class="comment">//设置超时时间</span></span><br><span class="line">            <span class="keyword">val</span> rs = statement.executeQuery() <span class="comment">//执行查询，返回一个查询产生的数据的ResultSet对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">JdbcUtils</span>.getSchema(rs, dialect, alwaysNullable = <span class="literal">true</span>)  <span class="comment">//传入数据rs，拿到schema，接着下面的内容</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rs.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            statement.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        conn.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getSchema (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSchema</span></span>(</span><br><span class="line">    resultSet: <span class="type">ResultSet</span>, <span class="comment">//查询表返回的rs(表结构)</span></span><br><span class="line">    dialect: <span class="type">JdbcDialect</span>, <span class="comment">//MySQL方言</span></span><br><span class="line">    alwaysNullable: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">StructType</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> rsmd = resultSet.getMetaData <span class="comment">//拿到表的元数据</span></span><br><span class="line">  <span class="keyword">val</span> ncols = rsmd.getColumnCount  <span class="comment">//拿到需要的字段的列的数量</span></span><br><span class="line">  <span class="keyword">val</span> fields = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">StructField</span>](ncols) <span class="comment">//创建一个StructField类型的数组，拼接fields</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; ncols) &#123; <span class="comment">//循环出每个column</span></span><br><span class="line">    <span class="keyword">val</span> columnName = rsmd.getColumnLabel(i + <span class="number">1</span>) <span class="comment">//返回列名：phoneSystemType</span></span><br><span class="line">    <span class="keyword">val</span> dataType = rsmd.getColumnType(i + <span class="number">1</span>) 	<span class="comment">//返回数据类型：12</span></span><br><span class="line">    <span class="keyword">val</span> typeName = rsmd.getColumnTypeName(i + <span class="number">1</span>) 	<span class="comment">//返回数据类型的名称：VARCHAR</span></span><br><span class="line">    <span class="keyword">val</span> fieldSize = rsmd.getPrecision(i + <span class="number">1</span>)  <span class="comment">//返回字段大小：64</span></span><br><span class="line">    <span class="keyword">val</span> fieldScale = rsmd.getScale(i + <span class="number">1</span>)	<span class="comment">//返回scale：0</span></span><br><span class="line">    <span class="keyword">val</span> isSigned = &#123; <span class="comment">//判断是否有符号</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rsmd.isSigned(i + <span class="number">1</span>) <span class="comment">//是否有符号：false</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// Workaround for HIVE-14684:</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">SQLException</span> <span class="keyword">if</span></span><br><span class="line">        e.getMessage == <span class="string">"Method not supported"</span> &amp;&amp;</span><br><span class="line">          rsmd.getClass.getName == <span class="string">"org.apache.hive.jdbc.HiveResultSetMetaData"</span> =&gt; <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nullable = <span class="keyword">if</span> (alwaysNullable) &#123; 	<span class="comment">//判断是否可为空</span></span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rsmd.isNullable(i + <span class="number">1</span>) != <span class="type">ResultSetMetaData</span>.columnNoNulls</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> metadata = <span class="keyword">new</span> <span class="type">MetadataBuilder</span>().putLong(<span class="string">"scale"</span>, fieldScale)</span><br><span class="line">    <span class="keyword">val</span> columnType =</span><br><span class="line">      dialect.getCatalystType(dataType, typeName, fieldSize, metadata).getOrElse(</span><br><span class="line">        getCatalystType(dataType, fieldSize, fieldScale, isSigned)) <span class="comment">// 传入参数拿到类型：StringType</span></span><br><span class="line">    fields(i) = <span class="type">StructField</span>(columnName, columnType, nullable) <span class="comment">//传入列名，数据类型，是否可为空，创建StructField，并加入到fields中</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">StructType</span>(fields) <span class="comment">//传入所有的StructField构建StructType，并返回，到这里拿到最终的Schema</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBCRelation (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>[sql] <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCRelation</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    override val schema: <span class="type">StructType</span>, //拿到<span class="type">Schema</span></span></span></span><br><span class="line"><span class="class"><span class="params">    parts: <span class="type">Array</span>[<span class="type">Partition</span>], //得到分区</span></span></span><br><span class="line"><span class="class"><span class="params">    jdbcOptions: <span class="type">JDBCOptions</span></span>)(<span class="params">@transient val sparkSession: <span class="type">SparkSession</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">BaseRelation</span> <span class="title">//实现BaseRelation，必然拿到了Schema</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">PrunedFilteredScan</span> <span class="title">//实现裁剪并且过滤的扫描表</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">InsertableRelation</span> </span>&#123; <span class="comment">//实现插入的模式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span> = sparkSession.sqlContext</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> needConversion: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查JDBCRDD.compileFilter是否可以接受输入过滤器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unhandledFilters</span></span>(filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">Array</span>[<span class="type">Filter</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (jdbcOptions.pushDownPredicate) &#123;</span><br><span class="line">      filters.filter(<span class="type">JDBCRDD</span>.compileFilter(_, <span class="type">JdbcDialects</span>.get(jdbcOptions.url)).isEmpty)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      filters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建Scan</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>], filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;	<span class="comment">//requiredColumns：需要的列，filters：过滤条件</span></span><br><span class="line">    <span class="comment">// 依赖类型擦除：将RDD[InternalRow]传递回RDD[Row]</span></span><br><span class="line">    <span class="type">JDBCRDD</span>.scanTable(</span><br><span class="line">      sparkSession.sparkContext, <span class="comment">//上下文环境</span></span><br><span class="line">      schema, 	<span class="comment">//Schema</span></span><br><span class="line">      requiredColumns, <span class="comment">//需要的列</span></span><br><span class="line">      filters, <span class="comment">//过滤条件</span></span><br><span class="line">      parts,   <span class="comment">//分区</span></span><br><span class="line">      jdbcOptions).asInstanceOf[<span class="type">RDD</span>[<span class="type">Row</span>]] <span class="comment">//最终的结果转换成RDD[Row]类型</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">DataFrame</span>, overwrite: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    data.write</span><br><span class="line">      .mode(<span class="keyword">if</span> (overwrite) <span class="type">SaveMode</span>.<span class="type">Overwrite</span> <span class="keyword">else</span> <span class="type">SaveMode</span>.<span class="type">Append</span>)</span><br><span class="line">      .jdbc(jdbcOptions.url, jdbcOptions.tableOrQuery, jdbcOptions.asProperties)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> partitioningInfo = <span class="keyword">if</span> (parts.nonEmpty) <span class="string">s" [numPartitions=<span class="subst">$&#123;parts.length&#125;</span>]"</span> <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">    <span class="comment">// 计划输出中不应包含凭据，表信息就足够了。</span></span><br><span class="line">    <span class="string">s"JDBCRelation(<span class="subst">$&#123;jdbcOptions.tableOrQuery&#125;</span>)"</span> + partitioningInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanTable (阶段二: 拿RDD[Row])</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanTable</span></span>(</span><br><span class="line">    sc: <span class="type">SparkContext</span>, </span><br><span class="line">    schema: <span class="type">StructType</span>,</span><br><span class="line">    requiredColumns: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">    filters: <span class="type">Array</span>[<span class="type">Filter</span>],</span><br><span class="line">    parts: <span class="type">Array</span>[<span class="type">Partition</span>],</span><br><span class="line">    options: <span class="type">JDBCOptions</span>): <span class="type">RDD</span>[<span class="type">InternalRow</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> url = options.url <span class="comment">//拿到客户端传入的rul</span></span><br><span class="line">    <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url) <span class="comment">//拿到方言</span></span><br><span class="line">    <span class="keyword">val</span> quotedColumns = requiredColumns.map(colName =&gt; dialect.quoteIdentifier(colName)) <span class="comment">//拿到需要的列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">JDBCRDD</span>(	<span class="comment">//传入参数，返回RDD[InternalRow]</span></span><br><span class="line">        sc,</span><br><span class="line">        <span class="type">JdbcUtils</span>.createConnectionFactory(options),</span><br><span class="line">        pruneSchema(schema, requiredColumns),</span><br><span class="line">        quotedColumns,</span><br><span class="line">        filters,</span><br><span class="line">        parts,</span><br><span class="line">        url,</span><br><span class="line">        options)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBCRDD(阶段二: 拿RDD[Row])</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示通过JDBC访问的数据库中的表的RDD。</span></span><br><span class="line"><span class="keyword">private</span>[jdbc] <span class="class"><span class="keyword">class</span> <span class="title">JDBCRDD</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    sc: <span class="type">SparkContext</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    getConnection: (</span>) <span class="title">=&gt;</span> <span class="title">Connection</span>,</span></span><br><span class="line"><span class="class">    <span class="title">schema</span></span>: <span class="type">StructType</span>,</span><br><span class="line">    columns: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">    filters: <span class="type">Array</span>[<span class="type">Filter</span>],</span><br><span class="line">    partitions: <span class="type">Array</span>[<span class="type">Partition</span>],</span><br><span class="line">    url: <span class="type">String</span>,</span><br><span class="line">    options: <span class="type">JDBCOptions</span>)</span><br><span class="line"><span class="keyword">extends</span> <span class="type">RDD</span>[<span class="type">InternalRow</span>](sc, <span class="type">Nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引与此RDD对应的分区列表。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartitions</span></span>: <span class="type">Array</span>[<span class="type">Partition</span>] = partitions</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `columns` 作为一个字符串注入到SQL查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> columnList: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sb = <span class="keyword">new</span> <span class="type">StringBuilder</span>()</span><br><span class="line">        columns.foreach(x =&gt; sb.append(<span class="string">","</span>).append(x))</span><br><span class="line">        <span class="keyword">if</span> (sb.isEmpty) <span class="string">"1"</span> <span class="keyword">else</span> sb.substring(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `filters`, 作为一个where语句注入到SQL查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> filterWhereClause: <span class="type">String</span> =</span><br><span class="line">    filters</span><br><span class="line">    .flatMap(<span class="type">JDBCRDD</span>.compileFilter(_, <span class="type">JdbcDialects</span>.get(url)))</span><br><span class="line">    .map(p =&gt; <span class="string">s"(<span class="subst">$p</span>)"</span>).mkString(<span class="string">" AND "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前分区有where语句，那么就拼接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getWhereClause</span></span>(part: <span class="type">JDBCPartition</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (part.whereClause != <span class="literal">null</span> &amp;&amp; filterWhereClause.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + <span class="string">s"(<span class="subst">$filterWhereClause</span>)"</span> + <span class="string">" AND "</span> + <span class="string">s"(<span class="subst">$&#123;part.whereClause&#125;</span>)"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.whereClause != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + part.whereClause</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filterWhereClause.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + filterWhereClause</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对JDBC驱动程序运行SQL查询。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(thePart: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">InternalRow</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> closed = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> rs: <span class="type">ResultSet</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> stmt: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> conn: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != rs) &#123;</span><br><span class="line">                    rs.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing resultset"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != stmt) &#123;</span><br><span class="line">                    stmt.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing statement"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != conn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!conn.isClosed &amp;&amp; !conn.getAutoCommit) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            conn.commit()</span><br><span class="line">                        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logWarning(<span class="string">"Exception committing transaction"</span>, e)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    conn.close()</span><br><span class="line">                &#125;</span><br><span class="line">                logInfo(<span class="string">"closed connection"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing connection"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.addTaskCompletionListener[<span class="type">Unit</span>]&#123; context =&gt; close() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> inputMetrics = context.taskMetrics().inputMetrics</span><br><span class="line">        <span class="keyword">val</span> part = thePart.asInstanceOf[<span class="type">JDBCPartition</span>]</span><br><span class="line">        conn = getConnection()</span><br><span class="line">        <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url)</span><br><span class="line">        <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line">        dialect.beforeFetch(conn, options.asProperties.asScala.toMap)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这在通过JDBC读取表/查询之前执行一个通用的SQL语句(或PL/SQL块)。</span></span><br><span class="line">        <span class="comment">// 使用此功能初始化数据库会话环境，例如用于优化和/或故障排除。</span></span><br><span class="line">        options.sessionInitStatement <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(sql) =&gt;</span><br><span class="line">            <span class="keyword">val</span> statement = conn.prepareStatement(sql)</span><br><span class="line">            logInfo(<span class="string">s"Executing sessionInitStatement: <span class="subst">$sql</span>"</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.setQueryTimeout(options.queryTimeout)</span><br><span class="line">                statement.execute() <span class="comment">//最终执行的就是jdbc</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                statement.close()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回RDD[InternalRow]</span></span><br><span class="line">        <span class="type">CompletionIterator</span>[<span class="type">InternalRow</span>, <span class="type">Iterator</span>[<span class="type">InternalRow</span>]](</span><br><span class="line">            <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, rowsIterator), close())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终一套debug走下来，其实就是两步</p>
<ol>
<li>第二步通过jdbc查元数据，拿到Schema</li>
<li>第二步通过jdbc查数据拿到RDD[Row]</li>
</ol>
<p><strong>最终的创建DataFrame由框架解决</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/13/spark/15/">RDD转换DadaFrame&amp;使用SQL操作数据源&amp;跨数据源join&amp;SQL与DF与DS的比较&amp;Spark元数据管理: catalog</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>RDD转换DadaFrame</li>
<li>使用SQL操作数据源</li>
<li>跨数据源join</li>
<li>SQL与DF与DS的比较</li>
<li>Spark元数据管理: catalog</li>
</ol>
<h2 id="RDD转换DadaFrame"><a href="#RDD转换DadaFrame" class="headerlink" title="RDD转换DadaFrame"></a>RDD转换DadaFrame</h2><ol>
<li><p>第一种方式是使用反射来推断包含特定对象类型的RDD的模式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/top.txt"</span></span><br><span class="line">        <span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = spark.sparkContext.textFile(in)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            people(words(<span class="number">0</span>), words(<span class="number">1</span>), words(<span class="number">2</span>).toInt)</span><br><span class="line">        &#125;)</span><br><span class="line">        mapRDD.toDF().show()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">people</span>(<span class="params">name:<span class="type">String</span>,subject:<span class="type">String</span>,grade:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过反射class的这种方式可以获得Schema创建DataFrame，简单通用，但是在<strong>创建外部数据源的场景下不适用</strong></p>
</li>
<li><p>第二种方法是通过编程接口，通过StructType可以构造Schema，然后将其应用于现有的RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/top.txt"</span></span><br><span class="line">        <span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = spark.sparkContext.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在原RDD上创建rowRDD</span></span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            <span class="type">Row</span>(words(<span class="number">0</span>), words(<span class="number">1</span>), words(<span class="number">2</span>).toDouble)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建和上一步对应的行结构类型的StructType</span></span><br><span class="line">        <span class="keyword">val</span> innerStruct =</span><br><span class="line">            <span class="type">StructType</span>(</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"name"</span>, <span class="type">StringType</span>, <span class="literal">false</span>) ::</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"subject"</span>, <span class="type">StringType</span>, <span class="literal">false</span>) ::</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"grade"</span>, <span class="type">DoubleType</span>, <span class="literal">false</span>) :: <span class="type">Nil</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将schema和Rows结合，创建出DF</span></span><br><span class="line">        <span class="keyword">val</span> df = spark.createDataFrame(mapRDD, innerStruct)</span><br><span class="line"></span><br><span class="line">        df.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>在原RDD上创建rowRDD</li>
<li>创建和上一步对应的行结构类型的StructType</li>
<li>将schema和Rows结合，创建出DF</li>
</ol>
</li>
</ol>
<h2 id="使用SQL操作数据源"><a href="#使用SQL操作数据源" class="headerlink" title="使用SQL操作数据源"></a>使用SQL操作数据源</h2><p>在官网的<a href="http://spark.apache.org/docs/latest/sql-data-sources.html" target="_blank" rel="noopener">Data Sources</a> 下，每个数据源下都有一个Sql选项卡，其中就是对应的SQL采集源数据，并生成对应的SQL视图的代码，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">spark-sql (default)&gt; CREATE TEMPORARY VIEW jsonTable</span><br><span class="line">                   &gt; USING org.apache.spark.sql.json</span><br><span class="line">                   &gt; OPTIONS (</span><br><span class="line">                   &gt;   path "file:///home/hadoop/data/people.json"</span><br><span class="line">                   &gt; );</span><br><span class="line">Response code</span><br><span class="line"></span><br><span class="line">spark-sql (default)&gt; SELECT * FROM jsonTable;</span><br><span class="line">age	name</span><br><span class="line">NULL	Michael</span><br><span class="line">30	Andy</span><br><span class="line">19	Justin</span><br></pre></td></tr></table></figure>

<h2 id="跨数据源join"><a href="#跨数据源join" class="headerlink" title="跨数据源join"></a>跨数据源join</h2><p>跨数据源join是Spark非常好用的一个特性，从不同的数据源拿到spark中，再从spark写出去，简直轻而易举。</p>
<p>下面我们将验证从hive和mysql中分别拿出一个表join(在idea中操作时，需要先连上hive)</p>
<ol>
<li><p>jdbc</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jdbcDF = spark.read</span><br><span class="line">    .format(<span class="string">"jdbc"</span>)</span><br><span class="line">    .option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://hadoop/?characterEncoding=utf-8&amp;useSSL=false"</span>)</span><br><span class="line">    .option(<span class="string">"dbtable"</span>, <span class="string">"tunan.dept"</span>)</span><br><span class="line">    .option(<span class="string">"user"</span>, <span class="string">"root"</span>)</span><br><span class="line">    .option(<span class="string">"password"</span>, <span class="string">"root"</span>)</span><br><span class="line">    .load()</span><br></pre></td></tr></table></figure>
</li>
<li><p>hive</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> hiveDF = spark.sql(<span class="string">"select * from default.emp"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>join</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> joinDF: <span class="type">DataFrame</span> = jdbcDF.join(hiveDF, <span class="string">"deptno"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&gt;&gt; joinDF.show(<span class="literal">false</span>)</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br><span class="line">|deptno|     dname|level|empno| ename|      job| jno|      date|   sal| prize|</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br><span class="line">|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">1700</span>| <span class="number">7566</span>| <span class="type">JONES</span>|  <span class="type">MANAGER</span>|<span class="number">7839</span>|  <span class="number">1981</span><span class="number">-4</span><span class="number">-2</span>|<span class="number">2975.0</span>|  <span class="literal">null</span>|</span><br><span class="line">|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">1700</span>| <span class="number">7521</span>|  <span class="type">WARD</span>| <span class="type">SALESMAN</span>|<span class="number">7698</span>| <span class="number">1981</span><span class="number">-2</span><span class="number">-22</span>|<span class="number">1250.0</span>| <span class="number">500.0</span>|</span><br><span class="line">|    <span class="number">20</span>|  <span class="type">RESEARCH</span>| <span class="number">1800</span>| <span class="number">7934</span>|<span class="type">MILLER</span>|    <span class="type">CLERK</span>|<span class="number">7782</span>| <span class="number">1982</span><span class="number">-1</span><span class="number">-23</span>|<span class="number">1300.0</span>|  <span class="literal">null</span>|</span><br><span class="line">|    <span class="number">20</span>|  <span class="type">RESEARCH</span>| <span class="number">1800</span>| <span class="number">7902</span>|  <span class="type">FORD</span>|  <span class="type">ANALYST</span>|<span class="number">7566</span>| <span class="number">1981</span><span class="number">-12</span><span class="number">-3</span>|<span class="number">3000.0</span>|  <span class="literal">null</span>|</span><br><span class="line">....</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们并不需要全部的数据，下面我们将经过处理选择我们需要的数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义视实体类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDept</span>(<span class="params">deptno:<span class="type">String</span>,dname:<span class="type">String</span>,level:<span class="type">Int</span>,empno:<span class="type">String</span>,ename:<span class="type">String</span>,job:<span class="type">String</span>,jno:<span class="type">String</span>,date:<span class="type">String</span>,sal:<span class="type">Double</span>,prize:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Result</span>(<span class="params">empno:<span class="type">String</span>,ename:<span class="type">String</span>,deptno:<span class="type">String</span>,dname:<span class="type">String</span>,prize:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//DF转换成DS</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">joinDS</span></span>: <span class="type">Dataset</span>[<span class="type">EmpDept</span>] = joinDF.as[<span class="type">EmpDept</span>]</span><br><span class="line"><span class="comment">//从DS中拿到数据，反射的方式拿到Schema信息</span></span><br><span class="line"><span class="keyword">val</span> mapDS = joinDS.map(x =&gt; <span class="type">Result</span>(x.empno, x.ename, x.deptno, x.dname,x.prize))</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存到文件</span></span><br><span class="line">mapDS.write.format(<span class="string">"orc"</span>).save(<span class="string">"tunan-spark-sql/out"</span>)</span><br><span class="line"><span class="comment">// 保存到MySQL数据库</span></span><br><span class="line">mapDS.write.format(<span class="string">"jdbc"</span>)</span><br><span class="line">.option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://hadoop/?characterEncoding=utf-8&amp;useSSL=false"</span>)</span><br><span class="line">.option(<span class="string">"dbtable"</span>, <span class="string">"tunan.join_result"</span>)</span><br><span class="line">.option(<span class="string">"user"</span>, <span class="string">"root"</span>)</span><br><span class="line">.option(<span class="string">"password"</span>, <span class="string">"root"</span>)</span><br><span class="line">.mode(<span class="string">"overwrite"</span>)</span><br><span class="line">.save()</span><br></pre></td></tr></table></figure>

<p>查看结果:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+-----+------+------+----------+------+</span><br><span class="line">|empno| ename|deptno|     dname| prize|</span><br><span class="line">+-----+------+------+----------+------+</span><br><span class="line">| <span class="number">7566</span>| <span class="type">JONES</span>|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>|  <span class="literal">null</span>|</span><br><span class="line">| <span class="number">7521</span>|  <span class="type">WARD</span>|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">500.0</span>|</span><br><span class="line">| <span class="number">7934</span>|<span class="type">MILLER</span>|    <span class="number">20</span>|  <span class="type">RESEARCH</span>|  <span class="literal">null</span>|</span><br><span class="line">| <span class="number">7902</span>|  <span class="type">FORD</span>|    <span class="number">20</span>|  <span class="type">RESEARCH</span>|  <span class="literal">null</span>|</span><br><span class="line">...</span><br><span class="line">+-----+------+------+----------+------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SQL与DF与DS的比较"><a href="#SQL与DF与DS的比较" class="headerlink" title="SQL与DF与DS的比较"></a>SQL与DF与DS的比较</h2><p>小问题：spark.read.load()   这句代码没用指定读取格式，那么它的默认格式是什么？</p>
<p>现在我们需要对比的是SQL、DF、DS三者对Syntax Errors和Analysis Errors的不同程度的响应</p>
<p>在上一步中，我们将joinDF转化成了joinDS，现在我们就看看他们在选择需要的列的时候，做了什么样的执行计划</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectDF: <span class="type">DataFrame</span> = joinDF.select(<span class="string">"ename"</span>)</span><br><span class="line"><span class="keyword">val</span> selectDS: <span class="type">Dataset</span>[<span class="type">String</span>] = joinDS.map(_.ename)</span><br><span class="line"></span><br><span class="line">println(selectDF.queryExecution.optimizedPlan.numberedTreeString)</span><br><span class="line">println(<span class="string">"-------------"</span>)</span><br><span class="line">println(selectDS.queryExecution.optimizedPlan.numberedTreeString)</span><br></pre></td></tr></table></figure>

<p>很明显selectDS做出了优化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="type">Project</span> [ename#<span class="number">7</span>]</span><br><span class="line"><span class="number">01</span> +- <span class="type">Join</span> <span class="type">Inner</span>, (deptno#<span class="number">0</span> = deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">02</span>    :- <span class="type">Project</span> [deptno#<span class="number">0</span>]</span><br><span class="line"><span class="number">03</span>    :  +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">0</span>)</span><br><span class="line"><span class="number">04</span>    :     +- <span class="type">Relation</span>[deptno#<span class="number">0</span>,dname#<span class="number">1</span>,level#<span class="number">2</span>] <span class="type">JDBCRelation</span>(tunan.dept) [numPartitions=<span class="number">1</span>]</span><br><span class="line"><span class="number">05</span>    +- <span class="type">Project</span> [ename#<span class="number">7</span>, deptno#<span class="number">13</span>]</span><br><span class="line"><span class="number">06</span>       +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">07</span>          +- <span class="type">HiveTableRelation</span> `<span class="keyword">default</span>`.`emp`, org.apache.hadoop.hive.serde2.<span class="keyword">lazy</span>.<span class="type">LazySimpleSerDe</span>, [empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>, deptno#<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="type">SerializeFromObject</span> [staticinvoke(<span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">spark</span>.<span class="title">unsafe</span>.<span class="title">types</span>.<span class="title">UTF8String</span>, <span class="title">StringType</span>, <span class="title">fromString</span>, <span class="title">input</span>[0, java.lang.<span class="type">String</span>, true], <span class="title">true</span>, <span class="title">false</span>) <span class="title">AS</span> <span class="title">value#47</span>]</span></span><br><span class="line"><span class="class">01 <span class="title">+-</span> <span class="title">MapElements</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$$$Lambda$1097/374205056@10f8e2d2</span>, <span class="title">class</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$EmpDept</span>, [<span class="type">StructField</span>(deptno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(dname,<span class="type">StringType</span>,true), <span class="type">StructField</span>(level,<span class="type">StringType</span>,true), <span class="type">StructField</span>(empno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(ename,<span class="type">StringType</span>,true), <span class="type">StructField</span>(job,<span class="type">StringType</span>,true), <span class="type">StructField</span>(jno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(date,<span class="type">StringType</span>,true), <span class="type">StructField</span>(sal,<span class="type">DoubleType</span>,false), <span class="type">StructField</span>(prize,<span class="type">StringType</span>,true)], <span class="title">obj#46</span></span>: java.lang.<span class="type">String</span></span><br><span class="line"><span class="number">02</span>    +- <span class="type">DeserializeToObject</span> newInstance(<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$EmpDept</span>), <span class="title">obj#45</span></span>: com.tunan.spark.sql.join.<span class="type">JdbcJoinHive</span>$<span class="type">EmpDept</span></span><br><span class="line"><span class="number">03</span>       +- <span class="type">Project</span> [deptno#<span class="number">0</span>, dname#<span class="number">1</span>, level#<span class="number">2</span>, empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>]</span><br><span class="line"><span class="number">04</span>          +- <span class="type">Join</span> <span class="type">Inner</span>, (deptno#<span class="number">0</span> = deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">05</span>             :- <span class="type">Filter</span> isnotnull(deptno#<span class="number">0</span>)</span><br><span class="line"><span class="number">06</span>             :  +- <span class="type">Relation</span>[deptno#<span class="number">0</span>,dname#<span class="number">1</span>,level#<span class="number">2</span>] <span class="type">JDBCRelation</span>(tunan.dept) [numPartitions=<span class="number">1</span>]</span><br><span class="line"><span class="number">07</span>             +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">08</span>                +- <span class="type">HiveTableRelation</span> `<span class="keyword">default</span>`.`emp`, org.apache.hadoop.hive.serde2.<span class="keyword">lazy</span>.<span class="type">LazySimpleSerDe</span>, [empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>, deptno#<span class="number">13</span>]</span><br></pre></td></tr></table></figure>

<p>由此我们可以根据在Spark SQL应用中，选择列的时候，SQL、DF、DS三者做一个比较</p>
<table>
<thead>
<tr>
<th></th>
<th>SQL</th>
<th>DF</th>
<th>DS</th>
</tr>
</thead>
<tbody><tr>
<td>Syntax Errors</td>
<td>runtime</td>
<td>compile</td>
<td>compile</td>
</tr>
<tr>
<td>Analysis Errors</td>
<td>runtime</td>
<td>runtime</td>
<td>compile</td>
</tr>
</tbody></table>
<p>在执行SQL的时候，无论是语法错误还是运行错误，都无法在编译时就提前暴露出来</p>
<p>在执行DF的时候，算子如果写错了，会提前暴露出来，但是写的列名只有在运行的时候才会检查是否正确</p>
<p>在执行DS的时候，由于case class反射的机制，算子和列名都可以提前到代码编写时就检测到错误</p>
<p><strong>所以最优的执行顺序为 DS &gt; DF &gt; SQL</strong></p>
<h3 id="面试题：RDD、DS、DF的区别"><a href="#面试题：RDD、DS、DF的区别" class="headerlink" title="面试题：RDD、DS、DF的区别"></a>面试题：RDD、DS、DF的区别</h3><ol>
<li>RDD不支持SQL</li>
<li>DF每一行都是Row类型，不能直接访问字段，必须解析才行</li>
<li>DS每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获 得每一行的信息</li>
<li>DataFrame与Dataset均支持spark sql的操作，比如select，group by之类，还 能注册临时表/视窗，进行sql语句操作</li>
<li>可以看出，Dataset在需要访问列中的某个字段时是非常方便的，然而，如果要 写一些适配性很强的函数时，如果使用Dataset，行的类型又不确定，可能是各种case class，无法实现适配，这时候用DataFrame即Dataset[Row]就能比较好的解决问题。</li>
</ol>
<h3 id="面试题：RDD和Dataset-DataFrame中的Persist的默认缓存级别"><a href="#面试题：RDD和Dataset-DataFrame中的Persist的默认缓存级别" class="headerlink" title="面试题：RDD和Dataset/DataFrame中的Persist的默认缓存级别"></a>面试题：RDD和Dataset/DataFrame中的Persist的默认缓存级别</h3><ul>
<li>Dataset 中的缓存级别是 MEMORY_AND_DISK</li>
<li>RDD 中的缓存级别是 MEMORY_ONLY</li>
</ul>
<h3 id="面试题：Spark-RDD和Spark-SQL的的cache有什么区别"><a href="#面试题：Spark-RDD和Spark-SQL的的cache有什么区别" class="headerlink" title="面试题：Spark RDD和Spark SQL的的cache有什么区别"></a>面试题：Spark RDD和Spark SQL的的cache有什么区别</h3><ul>
<li><p>Spark RDD的cache是lazy的，需要action才会执行cache操作</p>
</li>
<li><p>Spark SQL的cache是egaer的，马上就cache了</p>
</li>
</ul>
<h2 id="Spark元数据管理-catalog"><a href="#Spark元数据管理-catalog" class="headerlink" title="Spark元数据管理: catalog"></a>Spark元数据管理: catalog</h2><p>拿到catalog</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).enableHiveSupport().getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> catalog: <span class="type">Catalog</span> = spark.catalog</span><br></pre></td></tr></table></figure>

<ol>
<li><p>展示所有数据库</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dbList: <span class="type">Dataset</span>[<span class="type">Database</span>] = catalog.listDatabases()</span><br><span class="line">dbList.show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前数据库</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.currentDatabase</span><br></pre></td></tr></table></figure>
</li>
<li><p>只展示名字</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line">dbList.map(_.name).show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>展示指定库的所有表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.setCurrentDatabase(<span class="string">"offline_dw"</span>)</span><br><span class="line">catalog.listTables().show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listTable = catalog.listTables()</span><br><span class="line">listTable.filter(<span class="symbol">'name</span> === <span class="string">"dws_country_traffic"</span>).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断某个表是否缓存</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.isCached(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.cacheTable(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.isCached(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.uncacheTable(<span class="string">"dws_country_traffic"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：catalog的cacheTable是lazy的</strong></p>
</li>
<li><p>展示所有函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.listFunctions().show(<span class="number">1000</span>，<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册函数，再次展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">spark.udf.register(<span class="string">"udf_string_length"</span>,(word:<span class="type">String</span>) =&gt; &#123;</span><br><span class="line">    word.split(<span class="string">","</span>).length</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">catalog.listFunctions().filter(<span class="symbol">'name</span> === <span class="string">"udf_string_length"</span>).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>





</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/13/">Spark源码之解读spark-shell脚本</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>该篇文章主要分析一下Spark源码中启动spark-shell脚本的处理逻辑，从spark-shell一步步深入进去看看任务提交的整体流程</p>
<ol>
<li><p>spark-shell脚本解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化cygwin=<span class="literal">false</span></span></span><br><span class="line">cygwin=false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查你的系统是否属于cygwin</span></span><br><span class="line">case "$(uname)" in</span><br><span class="line">  CYGWIN*) cygwin=true;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置shell的模式为POSIX标准模式</span></span><br><span class="line">set -o posix</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测是否设置过SPARK_HOME环境变量</span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export _SPARK_CMD_USAGE="Usage: ./bin/spark-shell [options]</span><br><span class="line">Scala REPL options:</span><br><span class="line">  -I &lt;file&gt;                   preload &lt;file&gt;, enforcing line-by-line interpretation"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">scala默认不会使用java classpath，需要手动设置一下让scala使用java</span></span><br><span class="line">SPARK_SUBMIT_OPTS="$SPARK_SUBMIT_OPTS -Dscala.usejavacp=true"</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 判断是否是cygwin</span></span><br><span class="line">  if $cygwin; then</span><br><span class="line">    # 关闭echo回显，设置读操作最少1个字符</span><br><span class="line">    stty -icanon min 1 -echo &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    export SPARK_SUBMIT_OPTS="$SPARK_SUBMIT_OPTS -Djline.terminal=unix"</span><br><span class="line">    # 启动spark-submit 执行org.apache.spark.repl.Main类，并设置应用的名字，传递参数</span><br><span class="line">    "$&#123;SPARK_HOME&#125;"/bin/spark-submit --class org.apache.spark.repl.Main --name "Spark shell" "$@"</span><br><span class="line">    # 开启echo回显</span><br><span class="line">    stty icanon echo &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  else</span><br><span class="line">    export SPARK_SUBMIT_OPTS</span><br><span class="line">    # 启动spark-submit 执行org.apache.spark.repl.Main类，并设置应用的名字，传递参数</span><br><span class="line">    "$&#123;SPARK_HOME&#125;"/bin/spark-submit --class org.apache.spark.repl.Main --name "Spark shell" "$@"</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit_status=127</span><br><span class="line">saved_stty=""</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> restore stty settings (<span class="built_in">echo</span> <span class="keyword">in</span> particular)</span></span><br><span class="line">function restoreSttySettings() &#123;</span><br><span class="line">  stty $saved_stty</span><br><span class="line">  saved_stty=""</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断是否恢复终端设置</span></span><br><span class="line">function onExit() &#123;</span><br><span class="line">  if [[ "$saved_stty" != "" ]]; then</span><br><span class="line">    restoreSttySettings</span><br><span class="line">  fi</span><br><span class="line">  exit $exit_status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕获INT中断信号，然就执行onExit方法</span></span><br><span class="line">trap onExit INT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存了当前的终端配置</span></span><br><span class="line">saved_stty=$(stty -g 2&gt;/dev/null)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果收到退出命令，就恢复stty状态</span></span><br><span class="line">if [[ ! $? ]]; then</span><br><span class="line">  saved_stty=""</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用main方法，并传递所有的参数</span></span><br><span class="line">main "$@"</span><br><span class="line"></span><br><span class="line">exit_status=$?</span><br><span class="line">onExit</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面启动了spark-submit，接下来我们解读该脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查是否设置了<span class="variable">$&#123;SPARK_HOME&#125;</span></span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在Python 3.3+中禁用字符串的随机哈希</span></span><br><span class="line">export PYTHONHASHSEED=0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动spark-class，并传递了org.apache.spark.deploy.SparkSubmit作为第一个参数，然后把前面Spark-shell的参数都传给spark-class</span></span><br><span class="line">exec "$&#123;SPARK_HOME&#125;"/bin/spark-class org.apache.spark.deploy.SparkSubmit "$@"</span><br></pre></td></tr></table></figure>
</li>
<li><p>在spark-submit中又启动了spark-class，继续解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查/设置SPARK_HOME</span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置一些环境变量</span></span><br><span class="line">. "$&#123;SPARK_HOME&#125;"/bin/load-spark-env.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到bin/java,并赋值给RUNNER变量</span></span><br><span class="line">if [ -n "$&#123;JAVA_HOME&#125;" ]; then</span><br><span class="line">  RUNNER="$&#123;JAVA_HOME&#125;/bin/java"</span><br><span class="line">else</span><br><span class="line">  if [ "$(command -v java)" ]; then</span><br><span class="line">    RUNNER="java"</span><br><span class="line">  else</span><br><span class="line">    echo "JAVA_HOME is not set" &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">  fi  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到Spark的Jar包</span></span><br><span class="line">if [ -d "$&#123;SPARK_HOME&#125;/jars" ]; then</span><br><span class="line">  SPARK_JARS_DIR="$&#123;SPARK_HOME&#125;/jars"</span><br><span class="line">else</span><br><span class="line">  SPARK_JARS_DIR="$&#123;SPARK_HOME&#125;/assembly/target/scala-$SPARK_SCALA_VERSION/jars"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -d "$SPARK_JARS_DIR" ] &amp;&amp; [ -z "$SPARK_TESTING$SPARK_SQL_TESTING" ]; then</span><br><span class="line">  echo "Failed to find Spark jars directory ($SPARK_JARS_DIR)." 1&gt;&amp;2</span><br><span class="line">  echo "You need to build Spark with the target \"package\" before running this program." 1&gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">else</span><br><span class="line">  LAUNCH_CLASSPATH="$SPARK_JARS_DIR/*"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要，将启动程序构建目录添加到类路径。</span></span><br><span class="line">if [ -n "$SPARK_PREPEND_CLASSES" ]; then</span><br><span class="line">  LAUNCH_CLASSPATH="$&#123;SPARK_HOME&#125;/launcher/target/scala-$SPARK_SCALA_VERSION/classes:$LAUNCH_CLASSPATH"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">if [[ -n "$SPARK_TESTING" ]]; then</span><br><span class="line">  unset YARN_CONF_DIR</span><br><span class="line">  unset HADOOP_CONF_DIR</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 封装了真正的执行的spark的类</span></span><br><span class="line">build_command() &#123;</span><br><span class="line">  "$RUNNER" -Xmx128m -cp "$LAUNCH_CLASSPATH" org.apache.spark.launcher.Main "$@"</span><br><span class="line">  printf "%d\0" $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭posix模式，因为它不允许进程替换</span></span><br><span class="line">set +o posix</span><br><span class="line"></span><br><span class="line">CMD=()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先循环读取ARG参数，加入到CMD中</span></span><br><span class="line">while IFS= read -d '' -r ARG; do</span><br><span class="line">  CMD+=("$ARG")</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行Spark的类</span></span><br><span class="line">done &lt; &lt;(build_command "$@")</span><br><span class="line">COUNT=$&#123;#CMD[@]&#125;</span><br><span class="line">LAST=$((COUNT - 1))</span><br><span class="line">LAUNCHER_EXIT_CODE=$&#123;CMD[$LAST]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if ! [[ $LAUNCHER_EXIT_CODE =~ ^[0-9]+$ ]]; then</span><br><span class="line">  echo "$&#123;CMD[@]&#125;" | head -n-1 1&gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $LAUNCHER_EXIT_CODE != 0 ]; then</span><br><span class="line">  exit $LAUNCHER_EXIT_CODE</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">CMD=("$&#123;CMD[@]:0:$LAST&#125;")</span><br><span class="line">exec "$&#123;CMD[@]&#125;"</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到虽然是执行了spark-shell，但是最终执行的是<code>org.apache.spark.launcher.Main</code>类，也就是说spark-shell的最底层是使用java来启动的</p>
<p>他们的执行流程大致如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spark-shell&#123;</span><br><span class="line">	spark-submit&#123;</span><br><span class="line">		spark-class&#123;</span><br><span class="line">			   build_command() &#123;</span><br><span class="line">			   	"$RUNNER" -Xmx128m -cp "$LAUNCH_CLASSPATH" org.apache.spark.launcher.Main "$@"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/azkaban/2/">Azkaban配置Plugin实现Spark作业提交(非Shell)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Azkaban/">Azkaban</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Azkaban/">Azkaban</a></span><div class="content"><p>第一步，我们要打开azkaban的<a href="https://github.com/azkaban/azkaban/tree/master/az-hadoop-jobtype-plugin/src/jobtypes" target="_blank" rel="noopener">官网</a>，配置一些文件和参数，如图所示</p>
<p><img src="https://yerias.github.io/azkaban_img/az%E9%85%8D%E7%BD%AESpark%E6%8F%90%E4%BA%A4.jpg" alt="az配置Spark提交"></p>
<p>将<code>spark</code>、<code>common.properties</code>、<code>commonprivate.properties</code>拷贝到服务器中对应的目录，最终的文件展示如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> jobtypes]$ tree</span><br><span class="line">.</span><br><span class="line">├── commonprivate.properties</span><br><span class="line">├── common.properties</span><br><span class="line">└── spark</span><br><span class="line">    ├── plugin.properties</span><br><span class="line">    └── <span class="keyword">private</span>.properties</span><br></pre></td></tr></table></figure>

<ol>
<li><p>配置commonprivate.properties中hadoop.home和spark.home指定的家目录</p>
</li>
<li><p>配置common.properties中hadoop.home和spark.home指定的家目录</p>
</li>
<li><p>修改private.properties文件中的参数(临时方案，可行)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">jobtype.classpath=$&#123;hadoop.classpath&#125;:$&#123;spark.home&#125;/conf:$&#123;spark.home&#125;/lib<span class="comment">/*</span></span><br><span class="line"><span class="comment">===&gt;</span></span><br><span class="line"><span class="comment">jobtype.classpath=hadoop.classpath:$&#123;spark.home&#125;/conf:$&#123;spark.home&#125;/lib/*</span></span><br></pre></td></tr></table></figure>

<p>这么做的原因是我们以上的文件中没有配置hadoop.classpath，官方也没有说明hadoop.classpath应该配置什么参数，目前修改掉引用不影响程序的使用。</p>
</li>
</ol>
<p>第二步，在conf/azkaban.properties文件下增加一个配置，主机名:端口号(随意修改)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">azkaban.webserver.url=https:<span class="comment">//hadoop:8666</span></span><br></pre></td></tr></table></figure>

<p>第三步，提交作业，所配的参数需要参考<a href="https://github.com/azkaban/azkaban/blob/master/az-hadoop-jobtype-plugin/src/main/java/azkaban/jobtype/SparkJobArg.java" target="_blank" rel="noopener">官网</a></p>
<p>测试案例:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">    user.to.proxy: hadoop</span><br><span class="line">nodes:</span><br><span class="line">  - name: sparkwc</span><br><span class="line">    <span class="class"><span class="keyword">type</span></span>: spark</span><br><span class="line">    config:</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>: com.data.spark.wc.<span class="type">SparkWC</span></span><br><span class="line">      master: yarn</span><br><span class="line">      deploy-mode: client</span><br><span class="line">      executor-memory: <span class="number">512</span>M</span><br><span class="line">      driver-memory: <span class="number">512</span>M</span><br><span class="line">      conf.spark.testing.memory: <span class="number">471859200</span></span><br><span class="line">      execution-jar: tunan-spark-utils<span class="number">-1.0</span>.jar</span><br><span class="line">      jars: tunan-spark-core<span class="number">-1.0</span>.jar</span><br><span class="line">      params: hdfs:<span class="comment">//hadoop:9000/input/wc.txt hdfs://hadoop:9000/out</span></span><br></pre></td></tr></table></figure>

<p>注意配置文件中的 jar 没有写路径，这么提交<strong>需要把 jar 包和配置文件一起打成zip包</strong>，提交到AZ的Web界面</p>
<p>第四步，查看结果</p>
<p><em>20200413更新：</em>  数据下标越界问题：hadoop下的/share/hadoop/common/lib/paranamer-2.3.jar过时，使用–jars传spark下的/jars/paranamer-2.8.jar    </p>
<p><em>20200423更新：</em> 所有参数都可以使用conf传递，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution_jar  对应的是appjar</span><br><span class="line">jars 对应的是 依赖jar</span><br><span class="line">params: $&#123;execution_jar&#125; 参数<span class="number">1</span> 参数<span class="number">2</span></span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/12/">Spark中的序列化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>在写Spark应用时，常常会碰到序列化的问题。例如，在Driver端的程序中创建了一个对象，而在各个Executor端会用到这个对象——由于Driver端的代码和Executor端的代码在不同的JVM中，甚至在不同的节点上，因此必然要有相应</p>
<h2 id="Java框架进行序列化"><a href="#Java框架进行序列化" class="headerlink" title="Java框架进行序列化"></a>Java框架进行序列化</h2><p>在默认情况下，Spark会使用Java的ObjectOutputStream框架对对象进行序列化，并且可以与任何实现java.io.Serializable的类一起工作。您还可以通过扩展java.io.Externalizable来更紧密地控制序列化的性能。Java序列化是灵活的，但通常相当慢，并且会导致许多类的大型序列化格式。</p>
<p>测试代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SerializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"SerializationDemo"</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stduentArr = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Student</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">1000000</span>) &#123;</span><br><span class="line">            stduentArr += (<span class="type">Student</span>(i + <span class="string">""</span>, i + <span class="string">"a"</span>, <span class="number">10</span>, <span class="string">"male"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">JavaSerialization</span> = sc.parallelize(stduentArr)</span><br><span class="line">        <span class="type">JavaSerialization</span>.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Web界面查看：33.2M</p>
<h2 id="Kryo框架进行序列化"><a href="#Kryo框架进行序列化" class="headerlink" title="Kryo框架进行序列化"></a>Kryo框架进行序列化</h2><p>Spark还可以使用Kryo库（Spark 2.x）来更快地序列化对象。Kryo比Java（通常多达10倍）要快得多，也更紧凑，但是不支持所有可串行化类型，并且要求您提前注册您将在程序中使用的类，以获得最佳性能。</p>
<ol>
<li><p>不注册使用的类测试</p>
<p>在conf中配置spark.serializer = org.apache.spark.serializer.KryoSerializer来使用kryo序列化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SerializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">        .setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        .setAppName(<span class="string">"SerializationDemo"</span>)</span><br><span class="line">        .set(<span class="string">"spark.serializer"</span>,<span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stduentArr = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Student</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">1000000</span>) &#123;</span><br><span class="line">            stduentArr += (<span class="type">Student</span>(i + <span class="string">""</span>, i + <span class="string">"a"</span>, <span class="number">10</span>, <span class="string">"male"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">JavaSerialization</span> = sc.parallelize(stduentArr)</span><br><span class="line">        <span class="type">JavaSerialization</span>.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Web界面查看：53.2M</p>
<p>这是因为使用Kryo时，不将使用的类注册，往往会得到比java序列化占用更大的内存</p>
</li>
<li><p>注册使用的类测试</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SerializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">        .setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        .setAppName(<span class="string">"SerializationDemo"</span>)</span><br><span class="line">        .set(<span class="string">"spark.serializer"</span>,<span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">        .registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">Student</span>])) <span class="comment">// 将自定义的类注册到Kryo</span></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stduentArr = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Student</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">1000000</span>) &#123;</span><br><span class="line">            stduentArr += (<span class="type">Student</span>(i + <span class="string">""</span>, i + <span class="string">"a"</span>, <span class="number">10</span>, <span class="string">"male"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">JavaSerialization</span> = sc.parallelize(stduentArr)</span><br><span class="line">        <span class="type">JavaSerialization</span>.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Web界面查看：21.7 M</p>
<p>在conf中注册</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(...).setAppName(...)</span><br><span class="line">conf.registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">MyClass1</span>], classOf[<span class="type">MyClass2</span>]))</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="总结及拓展"><a href="#总结及拓展" class="headerlink" title="总结及拓展"></a>总结及拓展</h2><p>Kryo serialization 性能和序列化大小都比默认提供的 Java serialization 要好，但是<strong>使用Kryo需要将自定义的类先注册进去</strong>，使用起来比 Java serialization麻烦。自从Spark 2.x 以来，我们在使用简单类型、简单类型数组或字符串类型的简单类型来调整RDDs时，在内部使用Kryo序列化器。</p>
<p>通过查找sparkcontext初始化的源码，可以发现某些类型已经在sparkcontext初始化的时候被注册进去。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Component which configures serialization, compression and encryption for various Spark</span></span><br><span class="line"><span class="comment"> * components, including automatic selection of which [[Serializer]] to use for shuffles.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">SerializerManager</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    defaultSerializer: <span class="type">Serializer</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    encryptionKey: <span class="type">Option</span>[<span class="type">Array</span>[<span class="type">Byte</span>]]</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(defaultSerializer: <span class="type">Serializer</span>, conf: <span class="type">SparkConf</span>) = <span class="keyword">this</span>(defaultSerializer, conf, <span class="type">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> kryoSerializer = <span class="keyword">new</span> <span class="type">KryoSerializer</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> stringClassTag: <span class="type">ClassTag</span>[<span class="type">String</span>] = implicitly[<span class="type">ClassTag</span>[<span class="type">String</span>]]</span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> primitiveAndPrimitiveArrayClassTags: <span class="type">Set</span>[<span class="type">ClassTag</span>[_]] = &#123;</span><br><span class="line">        <span class="keyword">val</span> primitiveClassTags = <span class="type">Set</span>[<span class="type">ClassTag</span>[_]](</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Boolean</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Byte</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Char</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Double</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Float</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Int</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Long</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Null</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Short</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> arrayClassTags = primitiveClassTags.map(_.wrap)</span><br><span class="line">        primitiveClassTags ++ arrayClassTags</span><br></pre></td></tr></table></figure>

<p>也就是说，Boolean、Byte、Char、Double、Float、Int、Long、Null、Short这些类型修饰的属性，自动使用kryo序列化。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/10/">Spark之分组TopN模块</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>在Spark中，分组TopN好写，但是如果想写出性能好的代码却也很难。下面我们将通过写TopN的方式，找出问题，解决问题。</p>
<ol>
<li><p>直接reduceByKey完成分组求和排序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"file:///home/hadoop/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)	<span class="comment">//((domain,url),1)</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = mapRDD.reduceByKey(_ + _).groupBy(x =&gt; x._1._1).mapValues( x=&gt; x.toList.sortBy(x =&gt; -x._2).map(x =&gt; (x._1._1,x._1._2,x._2)).take(<span class="number">2</span>))</span><br><span class="line">    result.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法虽然直接，但是在reduceByKey和groupBy分别进过了shuffle，而且x.toList是一个非常吃内存的操作，如果数据量大，直接OOM</p>
</li>
<li><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> domains = <span class="type">Array</span>(<span class="string">"www.google.com"</span>, <span class="string">"www.ruozedata.com"</span>, <span class="string">"www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (domain &lt;- domains)&#123;</span><br><span class="line">        mapRDD.filter(x =&gt; x._1._1.equals(domain)).reduceByKey(_+_).sortBy(x =&gt; -x._2).take(<span class="number">2</span>).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想：把需要分组分类的数据提前拿出来，在filter中过滤，每次执行一个分组，虽然减少了一次shuffle，但是我们不可能每次都把需要的数据都能提前拿到数据</p>
</li>
<li><p>使用ditinct.collect返回的数组替换人为创建的数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> domains = mapRDD.map(x =&gt; x._1._1).distinct().collect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (domain &lt;- domains)&#123;</span><br><span class="line">        mapRDD.filter( x =&gt; domain.equals(x._1._1)).reduceByKey(_+_).sortBy(x =&gt; -x._2).take(<span class="number">2</span>).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人说distinct性能不好，但是我们这里使用去重的是domain，这个数据量并不是很大，可以勉强接受，现在每次都使用for循环来处理数据，能不能更加优化一下呢</p>
</li>
<li><p>使用分区执行替换for循环</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> domains = mapRDD.map(x =&gt; x._1._1).distinct().collect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapPartRDD = mapRDD.reduceByKey(<span class="keyword">new</span> <span class="type">MyPartitioner</span>(domains), _ + _).mapPartitions(partition =&gt; &#123;</span><br><span class="line">        partition.toList.sortBy(x =&gt; -x._2).take(<span class="number">2</span>).iterator</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    mapPartRDD.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的分区类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span>(<span class="params">domains:<span class="type">Array</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">Partitioner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map = mutable.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until (domains.length))&#123;</span><br><span class="line">        map(domains(i)) = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = domains.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> domain = key.asInstanceOf[(<span class="type">String</span>, <span class="type">String</span>)]._1</span><br><span class="line">        map(domain)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的好处是原本一起计算的RDD，现在每个分区里面去计算了，虽然toList内存占用大，但是还凑合，最终的版本就是把toList替换掉。</p>
</li>
<li><p>使用TreeSet替换toList实现最终的排序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">        <span class="comment">//连接SparkMaster</span></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">            ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> domains = mapRDD.map(x =&gt; x._1._1).distinct().collect()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> ord: <span class="type">Ordering</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = <span class="keyword">new</span> <span class="type">Ordering</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)]() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: ((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>), y: ((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)): <span class="type">Int</span> = &#123;</span><br><span class="line">                <span class="keyword">if</span> (!x._1.equals(y._1) &amp;&amp; x._2 == y._2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  降序排</span></span><br><span class="line">                y._2 - x._2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> treeSort = mapRDD.reduceByKey(<span class="keyword">new</span> <span class="type">MyPartitioner</span>(domains), _ + _).mapPartitions(partition =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> set = mutable.<span class="type">TreeSet</span>.empty(ord)</span><br><span class="line">            partition.foreach(x =&gt; &#123;</span><br><span class="line">                set.add(x)</span><br><span class="line">                <span class="keyword">if</span> (set.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    set.remove(set.lastKey) <span class="comment">//移除最后一个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            set.toIterator</span><br><span class="line">        &#125;).collect()</span><br><span class="line">        treeSort.foreach(println)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用TreeSet实现自定义排序器，使之每次维护的只有需要的极少量数据，这样占用内存少，效率最高。</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/03/spark/11/">SparkSQL&amp;DataFrame的read和write&amp;SparkSQL做统计分析&amp;UDF函数&amp;存储格式的转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>SparkSQL</li>
<li>DataFrame的read和write</li>
<li>SparkSQL做统计分析</li>
<li>UDF函数</li>
<li>存储格式的转换</li>
</ol>
<h2 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h2><h3 id="认识SparkSQL"><a href="#认识SparkSQL" class="headerlink" title="认识SparkSQL"></a>认识SparkSQL</h3><ol>
<li><p>SparkSQL的进化之路</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.0以前：</span><br><span class="line">   Shark</span><br><span class="line">1.1.x开始：</span><br><span class="line">   SparkSQL(只是测试性的) SQL</span><br><span class="line">1.3.x:</span><br><span class="line">   SparkSQL(正式版本)+Dataframe</span><br><span class="line">1.5.x:</span><br><span class="line">SparkSQL 钨丝计划</span><br><span class="line">1.6.x：</span><br><span class="line">   SparkSQL+DataFrame+DataSet(测试版本)</span><br><span class="line">2.x.x:</span><br><span class="line">   SparkSQL+DataFrame+DataSet(正式版本)</span><br><span class="line">   SparkSQL:还有其他的优化</span><br><span class="line">   StructuredStreaming(DataSet)</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是SparkSQL?</p>
<p>spark SQL是spark的一个模块，主要用于进行结构化数据的处理。它提供的最核心的编程抽象就是DataFrame。</p>
</li>
<li><p>SparkSQL的作用</p>
<p>提供一个编程抽象（DataFrame） 并且作为分布式 SQL 查询引擎</p>
<p>DataFrame：它可以根据很多源进行构建，包括：<strong>结构化的数据文件，hive中的表，外部的关系型数据库，以及RDD</strong></p>
</li>
<li><p>运行原理</p>
<p>将 Spark SQL 转化为 RDD， 然后提交到集群执行</p>
</li>
<li><p>特点</p>
<ol>
<li>容易整合</li>
<li>统一的数据访问方式</li>
<li>兼容 Hive</li>
<li>标准的数据连接</li>
</ol>
</li>
<li><p>spark-sql</p>
<p>spark-sql是一个Spark专属的SQL命令行交互工具，在使用spark-sql之前要把hive-site.xml 拷贝到Spark/Conf下，spark-sql和spark-shell用法一样，但是在引入外部依赖的时候，spark-sql需要用–jars和–driver-class-path同时引入依赖才不会报错</p>
</li>
<li><p>持久化</p>
<p>在spark-sql中的持久化Table命令是: cache table xxx，清除持久化 uncache table xxx</p>
<p>spark-SQL中的cache和uncache都是eager的，立即执行的</p>
<p><strong>考点：RDD和SparkSQL的cache有什么区别？</strong></p>
<ul>
<li>RDD中的cache是lazy的 spark-SQL中的cache是eager的</li>
</ul>
</li>
<li><p>遗留问题</p>
<p>–files/–jars    传进去的东西清不掉</p>
</li>
</ol>
<h3 id="SparkSession"><a href="#SparkSession" class="headerlink" title="SparkSession"></a>SparkSession</h3><p>SparkSession是Spark 2.0引如的新概念。SparkSession为用户提供了统一的切入点，来让用户学习spark的各项功能。 </p>
<p>在spark的早期版本中，SparkContext是spark的主要切入点，由于RDD是主要的API，我们通过sparkcontext来创建和操作RDD。对于每个其他的API，我们需要使用不同的context。例如，对于Streming，我们需要使用StreamingContext；对于sql，使用sqlContext；对于Hive，使用hiveContext。但是随着DataSet和DataFrame的API逐渐成为标准的API，就需要为他们建立接入点。所以在spark2.0中，引入SparkSession作为DataSet和DataFrame API的切入点，SparkSession封装了SparkConf、SparkContext和SQLContext。为了向后兼容，SQLContext和HiveContext也被保存下来。 </p>
<p>SparkSession实质上是SQLContext和HiveContext的组合（未来可能还会加上StreamingContext），所以在SQLContext和HiveContext上可用的API在SparkSession上同样是可以使用的。SparkSession内部封装了sparkContext，所以计算实际上是由sparkContext完成的。</p>
<p>特点：</p>
<ol>
<li><p><strong>为用户提供一个统一的切入点使用Spark 各项功能</strong></p>
</li>
<li><p><strong>允许用户通过它调用 DataFrame 和 Dataset 相关 API 来编写程序</strong></p>
</li>
<li><p><strong>减少了用户需要了解的一些概念，可以很容易的与 Spark 进行交互</strong></p>
</li>
<li><p><strong>与 Spark 交互之时不需要显示的创建 SparkConf, SparkContext 以及 SQlContext，这些对象已经封闭在 SparkSession 中</strong></p>
</li>
</ol>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格。DataFrame与RDD的主要区别在于，前者带有schema元信息，即DataFrame所表示的二维表数据集的每一列都带有名称和类型。这使得Spark SQL得以洞察更多的结构信息，从而对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观RDD，由于无从得知所存数据元素的具体内部结构，Spark Core只能在stage层面进行简单、通用的流水线优化。</p>
<p><img src="https://yerias.github.io/spark_img/RDD%E5%92%8CDataFrame%E7%9A%84%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9%E6%AF%94%E8%BE%83.png" alt="RDD和DataFrame的存储内容比较"></p>
<h2 id="DataFrame的read和write"><a href="#DataFrame的read和write" class="headerlink" title="DataFrame的read和write"></a>DataFrame的read和write</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><ol>
<li><p>数据的读取[DataFrameReader]</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">rdd2df</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.json"</span></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line">		<span class="comment">//  读取json数据</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"json"</span>).load(in)</span><br><span class="line">        <span class="comment">//  使用$"" 导入隐式转换</span></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="comment">//  可以使用UDF</span></span><br><span class="line">        df.select($<span class="string">"name"</span>,$<span class="string">"age"</span>).show(<span class="number">2</span>,<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">//  不可以使用UDF 适合大部分场景</span></span><br><span class="line">        df.select(<span class="string">"name"</span>,<span class="string">"age"</span>).show()</span><br><span class="line">        <span class="comment">//  不推介，写着复杂</span></span><br><span class="line">        df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).show(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select方法用于选择要输出的列，推介使用 $”col” 和 “col” 的方法</p>
<ol>
<li>使用select可以选取打印的列，空值为null</li>
<li>show()默认打印20条数据，可以指定条数</li>
<li>truncate默认为true，截取长度，可以设置为false</li>
</ol>
<p>select方法有三种不同的写法，fliter也有</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).filter(<span class="symbol">'name</span> === <span class="string">"Andy"</span>).show()	<span class="comment">//推介使用</span></span><br><span class="line">df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).filter(df(<span class="string">"name"</span>) === <span class="string">"Andy"</span>).show()</span><br><span class="line">df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).filter(<span class="string">"name = 'Andy'"</span>).show()</span><br></pre></td></tr></table></figure>

<p>printSchema()方法可以查看数据的Schema信息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.printSchema()</span><br><span class="line">------------------------------------------------</span><br><span class="line">root</span><br><span class="line"> |-- age: long (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- name: string (nullable = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据的存储[DataFrameWriter]</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectDf: <span class="type">DataFrame</span> = df.select($<span class="string">"name"</span>, $<span class="string">"age"</span>)</span><br><span class="line"><span class="comment">//  写出json数据</span></span><br><span class="line">selectDf.write.format(<span class="string">"json"</span>).mode(<span class="string">"overwrite"</span>).save(out)</span><br></pre></td></tr></table></figure>

<p>这里需要知道的一个概念是Save Modes</p>
<p>Save操作可以选择使用SaveMode，它指定目标如果存在，如何处理现有数据。重要的是要认识到，这些保存模式不利用任何锁定，也不是原子性的。此外，在执行覆盖时，在写入新数据之前将删除数据。</p>
<table>
<thead>
<tr>
<th align="left">Scala/Java</th>
<th align="left">Any Language</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SaveMode.ErrorIfExists</code> (default)</td>
<td align="left"><code>&quot;error&quot; or &quot;errorifexists&quot;</code> (default)</td>
<td align="left">在将DataFrame保存到数据源时，如果数据已经存在，则会抛出error。</td>
</tr>
<tr>
<td align="left"><code>SaveMode.Append</code></td>
<td align="left"><code>&quot;append&quot;</code></td>
<td align="left">在将DataFrame保存到数据源时，如果数据/表已经存在，则DataFrame的内容将被append到现有数据中。</td>
</tr>
<tr>
<td align="left"><code>SaveMode.Overwrite</code></td>
<td align="left"><code>&quot;overwrite&quot;</code></td>
<td align="left">overwrite模式意味着在将DataFrame保存到数据源时，如果数据/表已经存在，则现有数据将被DataFrame的内容覆盖。</td>
</tr>
<tr>
<td align="left"><code>SaveMode.Ignore</code></td>
<td align="left"><code>&quot;ignore&quot;</code></td>
<td align="left">ignore模式意味着在将DataFrame保存到数据源时，如果数据已经存在，则save操作不保存DataFrame的内容，也不更改现有数据。这类似于SQL中的<code>CREATE TABLE IF NOT EXISTS</code>。</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><ol>
<li><p>数据的读取</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">text2df</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.txt"</span></span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-sql/out"</span></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DataFrame不能直接split，且调用map返回的是一个Dataset</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"text"</span>).load(in)</span><br><span class="line">        <span class="keyword">val</span> mapDF: <span class="type">Dataset</span>[(<span class="type">String</span>, <span class="type">String</span>)] = df.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.toString().split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">        mapDF.show()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DataFrame转换为RDD后，再toDF，返回的是一个DataFrame</span></span><br><span class="line">        <span class="keyword">val</span> mapRDD2DF: <span class="type">DataFrame</span> = df.rdd.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.toString().split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;).toDF()</span><br><span class="line">        mapRDD2DF.show()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用textFile方法读取文本文件直接返回的是一个Dataset</span></span><br><span class="line">        <span class="keyword">val</span> ds: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(in)</span><br><span class="line">        <span class="keyword">val</span> mapDs: <span class="type">Dataset</span>[(<span class="type">String</span>, <span class="type">String</span>)] = ds.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">        mapDs.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文本数据读进来的一行在一个字段里面，所以要使用map算子，在map中split</p>
<ol>
<li>直接read.format()读进来的是DataFrame，map中不能直接split</li>
<li>DataFrame通过.rdd的方式转换成RDD，map中也不能直接split</li>
<li>通过read.textFile()的方式读进来的是Dataset，map中可以split</li>
</ol>
</li>
<li><p>数据的存储</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"text"</span>).load(in)</span><br><span class="line"><span class="keyword">val</span> mapDF = df.map(row =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> words = row.toString().split(<span class="string">","</span>)</span><br><span class="line">    <span class="comment">// 拼接成一列</span></span><br><span class="line">    words(<span class="number">0</span>) +<span class="string">","</span>+words(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mapDF.write.format(<span class="string">"text"</span>).mode(<span class="string">"overwrite"</span>).save(out)</span><br></pre></td></tr></table></figure>

<p>文本数据写出去的时候</p>
<ol>
<li>不支持int类型，如果存在int类型，会报错，解决办法是toString，转换成字符串</li>
<li>只能作为一列输出，如果是多列，会报错，解决办法是拼接起来，组成一列</li>
</ol>
<p><strong>文本数据压缩输出，只要是Spark支持的压缩的格式，都可以指定</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">mapDF.write</span><br><span class="line">    .format(<span class="string">"text"</span>)</span><br><span class="line">    <span class="comment">// 添加压缩操作</span></span><br><span class="line">    .option(<span class="string">"compression"</span>,<span class="string">"gzip"</span>)</span><br><span class="line">    .mode(<span class="string">"overwrite"</span>)</span><br><span class="line">    .save(out)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><ol>
<li><p>数据的读取</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">csv2df</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.csv"</span></span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-sql/out"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read</span><br><span class="line">            .format(<span class="string">"csv"</span>)</span><br><span class="line">            .option(<span class="string">"header"</span>, <span class="string">"true"</span>)</span><br><span class="line">            .option(<span class="string">"sep"</span>, <span class="string">";"</span>)</span><br><span class="line">            .option(<span class="string">"interSchema"</span>,<span class="string">"true"</span>)</span><br><span class="line">            .load(in)</span><br><span class="line">        df.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>csv读取数据注意使用几个参数</p>
<ol>
<li>指定表头：<code>option(&quot;header&quot;, &quot;true&quot;)</code></li>
<li>指定分隔符：<code>option(&quot;sep&quot;, &quot;;&quot;)</code></li>
<li>类型自动推测：<code>option(&quot;interSchema&quot;,&quot;true&quot;)</code></li>
</ol>
</li>
</ol>
<h3 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h3><p>在操作jdbc之前要导入两个依赖，一个是mysql-jdbc，用来连接mysql，一个是config，用来解决硬编码的问题</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.typesafe<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.conf文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.<span class="keyword">default</span>.driver=<span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">db.<span class="keyword">default</span>.url=<span class="string">"jdbc:mysql://hadoop/listener?characterEncoding=utf-8&amp;useSSL=false"</span></span><br><span class="line">db.<span class="keyword">default</span>.user=<span class="string">"root"</span></span><br><span class="line">db.<span class="keyword">default</span>.password=<span class="string">"root"</span></span><br><span class="line">db.<span class="keyword">default</span>.source=<span class="string">"dws_ad_phone_type_dist"</span></span><br><span class="line">db.<span class="keyword">default</span>.target=<span class="string">"dws_ad_phone_type_dist_1"</span></span><br><span class="line">db.<span class="keyword">default</span>.db=<span class="string">"access_dw"</span></span><br><span class="line"></span><br><span class="line"># Connection Pool settings</span><br><span class="line">db.<span class="keyword">default</span>.poolInitialSize=<span class="number">10</span></span><br><span class="line">db.<span class="keyword">default</span>.poolMaxSize=<span class="number">20</span></span><br><span class="line">db.<span class="keyword">default</span>.connectionTimeoutMillis=<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>数据的读取</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">mysql2df</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取配置文件中的值，db.default开头</span></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="type">ConfigFactory</span>.load()</span><br><span class="line">        <span class="keyword">val</span> driver = conf.getString(<span class="string">"db.default.driver"</span>)</span><br><span class="line">        <span class="keyword">val</span> url = conf.getString(<span class="string">"db.default.url"</span>)</span><br><span class="line">        <span class="keyword">val</span> user = conf.getString(<span class="string">"db.default.user"</span>)</span><br><span class="line">        <span class="keyword">val</span> password = conf.getString(<span class="string">"db.default.password"</span>)</span><br><span class="line">        <span class="keyword">val</span> source = conf.getString(<span class="string">"db.default.source"</span>)</span><br><span class="line">        <span class="keyword">val</span> target = conf.getString(<span class="string">"db.default.target"</span>)</span><br><span class="line">        <span class="keyword">val</span> db = conf.getString(<span class="string">"db.default.db"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据库的内容</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read</span><br><span class="line">            .format(<span class="string">"jdbc"</span>)</span><br><span class="line">            .option(<span class="string">"url"</span>, url)</span><br><span class="line">            .option(<span class="string">"dbtable"</span>, <span class="string">s"<span class="subst">$db</span>.<span class="subst">$source</span>"</span>)	<span class="comment">//库名.源表</span></span><br><span class="line">            .option(<span class="string">"user"</span>, user)</span><br><span class="line">            .option(<span class="string">"password"</span>, password)</span><br><span class="line">            .option(<span class="string">"driver"</span>, driver)</span><br><span class="line">            .load()</span><br><span class="line">        <span class="comment">//使用DataFrame创建临时表提供spark.sql查询</span></span><br><span class="line">        df.createOrReplaceTempView(<span class="string">"phone_type_dist"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//spark.sql写SQL返回一个DataFrame</span></span><br><span class="line">        <span class="keyword">val</span> sqlDF: <span class="type">DataFrame</span> = spark.sql(<span class="string">"select * from phone_type_dist where phoneSystemType = 'IOS'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用df.createOrReplaceTempView()方法创建一个DataFrame数据生成的临时表，提供spark.sql()使用SQL操作数据，返回的也是一个DataFrame</li>
</ul>
</li>
<li><p>数据的存储</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接着上面返回的sqlDF: DataFrame</span></span><br><span class="line">sqlDF.write</span><br><span class="line">    .format(<span class="string">"jdbc"</span>)</span><br><span class="line">    .option(<span class="string">"url"</span>, url)</span><br><span class="line">    .option(<span class="string">"dbtable"</span>, <span class="string">s"<span class="subst">$db</span>.<span class="subst">$target</span>"</span>)	<span class="comment">//库名.目标表</span></span><br><span class="line">    .option(<span class="string">"user"</span>, user)</span><br><span class="line">    .option(<span class="string">"password"</span>, password)</span><br><span class="line">    .option(<span class="string">"driver"</span>,driver)</span><br><span class="line">    .save()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SparkSQL做统计分析"><a href="#SparkSQL做统计分析" class="headerlink" title="SparkSQL做统计分析"></a>SparkSQL做统计分析</h2><ol>
<li><p>数据</p>
</li>
<li><p>需求：求每个国家的每个域名的访问流量排名前2</p>
</li>
<li><p>SQL实现</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GroupTopN</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">        <span class="keyword">val</span> ds = spark.read.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="comment">//为生成需要的表格做准备</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = ds.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">3</span>), words(<span class="number">12</span>), words(<span class="number">15</span>).toLong)</span><br><span class="line">        &#125;).toDF(<span class="string">"country"</span>, <span class="string">"domain"</span>, <span class="string">"traffic"</span>)</span><br><span class="line"></span><br><span class="line">        df.createOrReplaceTempView(<span class="string">"access"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个国家的域名流量前2</span></span><br><span class="line">        <span class="keyword">val</span> topNSQL=<span class="string">""</span><span class="string">"select</span></span><br><span class="line"><span class="string">                      |	*</span></span><br><span class="line"><span class="string">                      |from (</span></span><br><span class="line"><span class="string">                      |		select</span></span><br><span class="line"><span class="string">                      |			t.*,row_number() over(partition by country order by sum_traffic desc) r</span></span><br><span class="line"><span class="string">                      |		from</span></span><br><span class="line"><span class="string">                      |			(</span></span><br><span class="line"><span class="string">                      |				select country,domain,sum(traffic) as sum_traffic from access group by country,domain</span></span><br><span class="line"><span class="string">                      |			) t</span></span><br><span class="line"><span class="string">                      |	) rt</span></span><br><span class="line"><span class="string">                      |where rt.r &lt;=2 "</span><span class="string">""</span>.stripMargin</span><br><span class="line"></span><br><span class="line">        spark.sql(topNSQL).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果只要求traffic的降序，可以使用API直接写出来</p>
<p>分组，求和，别名，降序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//traffic降序排序</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">df.groupBy(<span class="string">"country"</span>,<span class="string">"domain"</span>).agg(sum(<span class="string">"traffic"</span>).as(<span class="string">"sum_traffic"</span>)).sort($<span class="string">"sum_traffic"</span>.desc).show()</span><br></pre></td></tr></table></figure>

<p><strong>注意看源码中案例仿写</strong></p>
</li>
<li><p>结果展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+----------------+-----------------+-----------+---+</span><br><span class="line">|         country|           domain|sum_traffic|  r|</span><br><span class="line">+----------------+-----------------+-----------+---+</span><br><span class="line">|            中国| www.bilibili.com|   <span class="number">24265886</span>|  <span class="number">1</span>|</span><br><span class="line">|            中国|www.ruozedata.com|    <span class="number">4187637</span>|  <span class="number">2</span>|</span><br><span class="line">|          利比亚| www.bilibili.com|      <span class="number">22816</span>|  <span class="number">1</span>|</span><br><span class="line">|          利比亚|  ruoze.ke.qq.com|      <span class="number">15970</span>|  <span class="number">2</span>|</span><br><span class="line">|            加纳| www.bilibili.com|     <span class="number">138659</span>|  <span class="number">1</span>|</span><br><span class="line">|            加纳|www.ruozedata.com|      <span class="number">17988</span>|  <span class="number">2</span>|</span><br><span class="line">|        利比里亚| www.bilibili.com|      <span class="number">20593</span>|  <span class="number">1</span>|</span><br><span class="line">|        利比里亚|  ruoze.ke.qq.com|       <span class="number">7466</span>|  <span class="number">2</span>|</span><br><span class="line">+----------------+-----------------+-----------+---+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="UDF函数"><a href="#UDF函数" class="headerlink" title="UDF函数"></a>UDF函数</h2><ol>
<li><p>数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大狗	小破车,渣团,热刺,我纯</span><br><span class="line">桶子	利物浦</span><br><span class="line">二娃	南大王,西班牙人</span><br></pre></td></tr></table></figure>
</li>
<li><p>需求：求出每个人的爱好的个数</p>
</li>
<li><p>SQLs实现</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LoveLength</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取文本内容</span></span><br><span class="line">        <span class="keyword">val</span> ds: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文本转换成DF</span></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = ds.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">"\t"</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;).toDF(<span class="string">"name"</span>, <span class="string">"love"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建UDF</span></span><br><span class="line">        spark.udf.register(<span class="string">"length"</span>, (love: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">            love.split(<span class="string">","</span>).length</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DF创建临时表</span></span><br><span class="line">        df.createOrReplaceTempView(<span class="string">"udf_love"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在sql中使用UDF函数</span></span><br><span class="line">        spark.sql(<span class="string">"select name,love,length(love) as love_length from udf_love"</span>).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面是使用SQL的解决方案，还可以使用API的方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的udf需要返回值</span></span><br><span class="line"><span class="keyword">val</span> loveLengthUDF: <span class="type">UserDefinedFunction</span> = spark.udf.register(<span class="string">"length"</span>, (love: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">    love.split(<span class="string">","</span>).length</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//df.select中传入UDF函数</span></span><br><span class="line">df.select($<span class="string">"name"</span>,$<span class="string">"love"</span>,loveLengthUDF($<span class="string">"love"</span>)).show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+----+---------------------+----------------+</span><br><span class="line">|大狗|小破车,渣团,热刺,我纯   |               <span class="number">4</span>|</span><br><span class="line">|桶子|               利物浦 |               <span class="number">1</span>|</span><br><span class="line">|二娃|      南大王,西班牙人  |               <span class="number">2</span>|</span><br><span class="line">+----+---------------------+----------------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="存储格式的转换"><a href="#存储格式的转换" class="headerlink" title="存储格式的转换"></a>存储格式的转换</h2><p>Spark读text文件进行清洗，清洗完以后直接以我们想要的列式存储格式输出，如果按以前的方式要经过很多复杂的步骤</p>
<p>用Spark的时候只需要在<code>df.write.format(&quot;orc&quot;).mode().save()</code>中指定格式即可，如orc，现在就很方便了，想转成什么格式，只要format支持就ok</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">text2orc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.txt"</span></span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-sql/out"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> df = spark.read.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对文本文件做处理</span></span><br><span class="line">        df.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>),words(<span class="number">1</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">            .toDF(<span class="string">"name"</span>,<span class="string">"age"</span>)	<span class="comment">//这一步解决了数据没有表头的问题</span></span><br><span class="line">            .write</span><br><span class="line">            .mode(<span class="string">"overwrite"</span>)	<span class="comment">//save mode</span></span><br><span class="line">            .format(<span class="string">"orc"</span>)	<span class="comment">//save format</span></span><br><span class="line">            .save(out)	<span class="comment">//save path</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>20200416更新：</em> df.write.format(“…”).option(“compression”,”…”)   ==&gt; 存储格式+压缩格式</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/02/spark/9/">经典案例&amp;多目录输出&amp;计数器&amp;持久化&amp;广播变量</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>经典案例</li>
<li>多目录输出</li>
<li>计数器</li>
<li>持久化</li>
<li>广播变量</li>
</ol>
<h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户     节目            展示 点击</span></span><br><span class="line"><span class="comment"> * 001,一起看|电视剧|军旅|亮剑,1,1</span></span><br><span class="line"><span class="comment"> * 001,一起看|电视剧|军旅|亮剑,1,0</span></span><br><span class="line"><span class="comment"> * 002,一起看|电视剧|军旅|士兵突击,1,1</span></span><br><span class="line"><span class="comment"> * ==&gt;</span></span><br><span class="line"><span class="comment"> * 001,一起看,2,1</span></span><br><span class="line"><span class="comment"> * 001,电视剧,2,1</span></span><br><span class="line"><span class="comment"> * 001,军旅,2,1</span></span><br><span class="line"><span class="comment"> * 001,亮剑,2,1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">exercise02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> linesRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"tunan-spark-core/data/test2.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用map返回的是一个数组，我不要数组，就使用flatMap</span></span><br><span class="line">        <span class="keyword">import</span> com.tunan.spark.utils.<span class="type">ImplicitAspect</span>.rdd2RichRDD</span><br><span class="line">        <span class="keyword">val</span> map2RDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">Int</span>))] = linesRDD.flatMap(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">val</span> programs: <span class="type">Array</span>[<span class="type">String</span>] = words(<span class="number">1</span>).split(<span class="string">"\\|"</span>)</span><br><span class="line">            <span class="keyword">val</span> mapRDD: <span class="type">Array</span>[((<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">Int</span>))] = programs.map(program =&gt; ((words(<span class="number">0</span>), program), (words(<span class="number">2</span>).toInt, words(<span class="number">3</span>).toInt)))</span><br><span class="line">            mapRDD</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Iterable</span>[(<span class="type">Int</span>, <span class="type">Int</span>)])] = map2RDD.groupByKey()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是mapValues很好的一个使用案例</span></span><br><span class="line">        <span class="keyword">val</span> mapVRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">Int</span>))] = groupRDD.mapValues(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> imps: <span class="type">Int</span> = x.map(_._1).sum</span><br><span class="line">            <span class="keyword">val</span> check: <span class="type">Int</span> = x.map(_._2).sum</span><br><span class="line">            (imps, check)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化输出</span></span><br><span class="line">        mapVRDD.map(x =&gt; &#123;</span><br><span class="line">            (x._1._1,x._1._2,x._2._1,x._2._1)</span><br><span class="line">        &#125;).print()</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多目录输出"><a href="#多目录输出" class="headerlink" title="多目录输出"></a>多目录输出</h2><ol>
<li><p>实现多目录输出自定义类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.<span class="type">NullWritable</span></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapred.lib.<span class="type">MultipleTextOutputFormat</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMultipleTextOutputFormat</span> <span class="keyword">extends</span> <span class="title">MultipleTextOutputFormat</span>[<span class="type">Any</span>,<span class="type">Any</span>] </span>&#123;</span><br><span class="line">    <span class="comment">//生成最终生成的key的类型，这里不要，给Null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">generateActualKey</span></span>(key: <span class="type">Any</span>, value: <span class="type">Any</span>): <span class="type">Any</span> = <span class="type">NullWritable</span>.get()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成最终生成的value的类型，这里是String</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">generateActualValue</span></span>(key: <span class="type">Any</span>, value: <span class="type">Any</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">        value.asInstanceOf[<span class="type">String</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成文件名</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">generateFileNameForKeyValue</span></span>(key: <span class="type">Any</span>, value: <span class="type">Any</span>, name: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="string">s"<span class="subst">$key</span>/<span class="subst">$name</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主类，使用<code>saveAsHadoopFile(path, keyClass, valueClass, fm.runtimeClass.asInstanceOf[Class[F]])</code>方法保存数据，指定参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultipleDirectory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-core/out"</span></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="type">CheckHDFSOutPath</span>.ifExistsDeletePath(sc.hadoopConfiguration,out)</span><br><span class="line">        <span class="comment">//读取数组，转换成键值对的格式</span></span><br><span class="line">        <span class="keyword">val</span> lines = sc.textFile(<span class="string">"tunan-spark-core/ip/access-result/*"</span>)</span><br><span class="line">        <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = lines.map(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = line.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">12</span>), line)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//多目录保存文件</span></span><br><span class="line">        mapRDD.saveAsHadoopFile(out,classOf[<span class="type">String</span>],classOf[<span class="type">String</span>],classOf[<span class="type">MyMultipleTextOutputFormat</span>])</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="https://yerias.github.io/spark_img/%E5%A4%9A%E7%9B%AE%E5%BD%95%E8%BE%93%E5%87%BA.jpg" alt="多目录输出"></p>
</li>
</ol>
<p>在spark程序中，当一个传递给Spark操作(例如map和reduce)的函数在远程节点上面运行时，Spark操作实际上操作的是这个函数所用变量的一个<strong>独立副本</strong>。这些变量会被复制到每台机器上，并且这些变量在远程机器上的所有更新都不会传递回驱动程序。通常跨任务的读写变量是低效的，但是，Spark还是为两种常见的使用模式提供了两种有限的共享变量：广播变量（broadcast variable）和累加器（accumulator）</p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="为什么要定义计数器？"><a href="#为什么要定义计数器？" class="headerlink" title="为什么要定义计数器？"></a>为什么要定义计数器？</h3><p>在spark应用程序中，我们经常会有这样的需求，如<em>异常监控</em>，<em>调试</em>，<em>记录符合某特性的数据的数目</em>，这种需求都需要用到计数器，如果一个变量不被声明为一个累加器，那么它将在被改变时不会再driver端进行全局汇总，即在分布式运行时每个task运行的只是原始变量的一个副本，并不能改变原始变量的值，但是当这个变量被声明为累加器后，该变量就会有分布式计数的功能。</p>
<h3 id="图解计数器"><a href="#图解计数器" class="headerlink" title="图解计数器"></a>图解计数器</h3><p>错误的图解</p>
<p><img src="https://yerias.github.io/spark_img/%E7%B4%AF%E5%8A%A0%E5%99%A8%E9%94%99%E8%AF%AF%E7%9A%84%E5%9B%BE%E8%A7%A3.png" alt="累加器错误的图解"></p>
<p>正确的图解</p>
<p><img src="https://yerias.github.io/spark_img/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%9B%BE%E8%A7%A3.png" alt="累加器正确的图解"></p>
<p>计数器种类很多，但是经常用的就是两种，<code>longAccumulator</code>和<code>collectionAccumulator</code></p>
<p><strong>需要注意的是计数器是lazy的，只有触发action才会进行计数，在不持久化的情况下重复触发action，计数器会重复累加</strong></p>
<h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><p>Accumulators 是只能通过associative和commutative操作“added”的变量，因此可以有效地并行支持。它们可用于实现计数器(如MapReduce)和Spark本身支持数字类型的累加器，程序员还<strong>可以添加对新类型的支持</strong>。</p>
<p><code>longAccumulator</code>通过累加的方式计数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyLongAccumulator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="keyword">var</span> acc = sc.longAccumulator(<span class="string">"计数"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rdd = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="comment">// 计数器做累加</span></span><br><span class="line">            acc.add(<span class="number">1</span>L)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// action操作 </span></span><br><span class="line">        forRDD.count()</span><br><span class="line">       </span><br><span class="line">        println(acc.value)	<span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>longAccumulator</code>做计数的时候要小心重复执行action导致的acc.value的变化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyLongAccumulatorV2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="comment">//生成计数器</span></span><br><span class="line">        <span class="keyword">val</span> acc = sc.longAccumulator(<span class="string">"计数"</span>)</span><br><span class="line">        <span class="keyword">val</span> rdd = sc.parallelize(<span class="number">1</span> to <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="comment">//计数器做累加</span></span><br><span class="line">            acc.add(<span class="number">1</span>L)</span><br><span class="line">        &#125;)</span><br><span class="line">        forRDD.count()</span><br><span class="line">        println(acc.value)	<span class="comment">//8</span></span><br><span class="line">        forRDD.count()</span><br><span class="line">        println(acc.value)	<span class="comment">//16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于重复执行了count()，累加器的数量成倍增长，解决这种错误累加也很简单，就是在count之前调用forRDD的cache方法(或persist)，这样在count后数据集就会被缓存下来，reduce操作就会读取缓存的数据集，而无需从头开始计算。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyLongAccumulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="comment">//生成计数器</span></span><br><span class="line">        <span class="keyword">val</span> acc = sc.longAccumulator(<span class="string">"计数"</span>)</span><br><span class="line">        <span class="keyword">val</span> rdd = sc.parallelize(<span class="number">1</span> to <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="comment">//计数器做累加</span></span><br><span class="line">            acc.add(<span class="number">1</span>L)</span><br><span class="line">        &#125;)</span><br><span class="line">        forRDD.cache().count()</span><br><span class="line">        println(acc.value)	<span class="comment">//8</span></span><br><span class="line">        forRDD.count()</span><br><span class="line">        println(acc.value)	<span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CollectionAccumulator"><a href="#CollectionAccumulator" class="headerlink" title="CollectionAccumulator"></a>CollectionAccumulator</h3><p><code>collectionAccumulator</code>，集合计数器，计数器中保存的是集合元素，通过泛型指定。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：id后三位相同的加入计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyCollectionAccumulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc  = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成集合计数器</span></span><br><span class="line">        <span class="keyword">val</span> acc = sc.collectionAccumulator[<span class="type">People</span>](<span class="string">"集合计数器"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成RDD</span></span><br><span class="line">        <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">People</span>] = sc.parallelize(<span class="type">Array</span>(<span class="type">People</span>(<span class="string">"tunan"</span>, <span class="number">100000</span>), <span class="type">People</span>(<span class="string">"xiaoqi"</span>, <span class="number">100001</span>), <span class="type">People</span>(<span class="string">"张三"</span>, <span class="number">100222</span>), <span class="type">People</span>(<span class="string">"李四"</span>, <span class="number">100003</span>)))</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//map操作</span></span><br><span class="line">        rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> id2 = x.id.toString.reverse</span><br><span class="line">            <span class="comment">//满足条件就加入计数器，</span></span><br><span class="line">            <span class="keyword">if</span> (id2(<span class="number">0</span>) == id2(<span class="number">1</span>) &amp;&amp; id2(<span class="number">0</span>) ==id2(<span class="number">2</span>))&#123;</span><br><span class="line">                acc.add(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).count()	<span class="comment">//触发action</span></span><br><span class="line"></span><br><span class="line">        println(acc.value)	<span class="comment">//[People(张三,100222), People(tunan,100000)]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>(<span class="params">name:<span class="type">String</span>,id:<span class="type">Long</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><p>计数器在Driver端定义赋初始值，计数器只能在Driver端读取最后的值，在Excutor端更新。</p>
</li>
<li><p>计数器不是一个调优的操作，因为如果不这样做，结果是错的</p>
</li>
</ol>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Spark中最重要的功能之一是跨操作在内存中持久化数据集。持久化一个RDD时，每个节点在内存中存储它计算的任何分区，并在该数据集(或从中派生的数据集)的其他操作中重构它们。这使得将来的操作要快得多(通常超过10倍)。缓存是迭代算法和快速交互使用的关键工具。</p>
<p>可以使用其上的persist()或cache()方法将RDD标记为持久的。第一次在操作中计算它时，它将保存在节点的内存中。Spark的缓存是容错的——如果一个RDD的任何分区丢失了，它将使用最初创建它的转换自动重新计算。</p>
<p>持久化的存储级别很多，常用的是MEMORY_ONLY、MEMORY_ONLY_SER、MEMORY_AND_DISK</p>
<table>
<thead>
<tr>
<th align="left">Storage Level</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MEMORY_ONLY</td>
<td align="left">将RDD作为不序列化的Java对象存储在JVM中。如果RDD不适合内存，那么一些分区将不会被缓存，而是在需要它们时动态地重新计算。这是默认级别。</td>
</tr>
<tr>
<td align="left">MEMORY_AND_DISK</td>
<td align="left">将RDD作为不序列化的Java对象存储在JVM中。如果RDD不适合内存，那么将不适合的分区存储在磁盘上，并在需要时从那里读取它们。</td>
</tr>
<tr>
<td align="left">MEMORY_ONLY_SER (Java and Scala)</td>
<td align="left">将RDD存储为序列化的Java对象(每个分区一个字节数组)。这通常比反序列化对象更节省空间，特别是在使用快速序列化器时，但读取时需要更多cpu。</td>
</tr>
</tbody></table>
<h3 id="如何选择它们？"><a href="#如何选择它们？" class="headerlink" title="如何选择它们？"></a><strong>如何选择它们？</strong></h3><p>Storage Level的选择是内存和CPU的权衡</p>
<ol>
<li>内存多：MEMORY_ONLY (不进行序列化)</li>
<li>CPU跟的上：MEMORY_ONLY_SER (进行了序列化，推介)</li>
<li>不建议写Disk</li>
</ol>
<p>使用cache()和persist()进行持久化操作，它们都是<strong>lazy</strong>的，需要action才能触发，默认使用MEMORY_ONLY</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> forRDD.cache</span></span><br><span class="line">res18: forRDD.type = MapPartitionsRDD[9] at map at &lt;console&gt;:27</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> forRDD.count</span></span><br><span class="line">res19: Long = 8</span><br></pre></td></tr></table></figure>

<p>结果可以在Web UI的<strong>Storage</strong>中查看</p>
<p>如果需要<strong>清除缓存</strong>，使用unpersist()，清除缓存数据是立即执行的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> forRDD.unpersist()</span></span><br><span class="line">res8: forRDD.type = MapPartitionsRDD[3] at map at &lt;console&gt;:28</span><br></pre></td></tr></table></figure>

<p><strong>怎么修改存储级别？</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">    <span class="comment">//计数器做累加</span></span><br><span class="line">    acc.add(<span class="number">1</span>L)</span><br><span class="line">&#125;).persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br></pre></td></tr></table></figure>

<p>StorageLevel是个object，需要的级别都可以从里面拿出来</p>
<h4 id="考点：cache和persist有什么区别？"><a href="#考点：cache和persist有什么区别？" class="headerlink" title="考点：cache和persist有什么区别？"></a><strong>考点：cache和persist有什么区别？</strong></h4><ul>
<li>cache调用的persist，persist调用的persist(storage level)</li>
</ul>
<h4 id="考点：序列化和非序列化有什么区别？"><a href="#考点：序列化和非序列化有什么区别？" class="headerlink" title="考点：序列化和非序列化有什么区别？"></a><strong>考点：序列化和非序列化有什么区别？</strong></h4><ul>
<li>序列化将对象转换成字节数组了，节省空间，占CPU</li>
</ul>
<h3 id="Removing-Data"><a href="#Removing-Data" class="headerlink" title="Removing Data"></a>Removing Data</h3><p>Spark自动监视每个节点上的缓存使用情况，并以最近最少使用(LRU)的方式删除旧的数据分区。如果想要手动删除一个RDD，而不是等待它从缓存中消失，那么可以使用RDD.unpersist()方法。</p>
<p>伪代码以及画图表示出什么是LRU？</p>
<h2 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h2><h3 id="为什么要将变量定义成广播变量？"><a href="#为什么要将变量定义成广播变量？" class="headerlink" title="为什么要将变量定义成广播变量？"></a>为什么要将变量定义成广播变量？</h3><p>如果我们要在分布式计算里面分发大对象，例如：<em>字典</em>，<em>集合</em>，<em>黑白名单</em>等，这个都会由Driver端进行分发，一般来讲，如果这个变量不是广播变量，那么每个task就会分发一份，这在<strong>task数目十分多的情况下Driver的带宽会成为系统的瓶颈，而且会大量消耗task服务器上的资源</strong>，如果将这个变量声明为广播变量，那么知识每个executor拥有一份，这个executor启动的task会共享这个变量，节省了通信的成本和服务器的资源。</p>
<h3 id="广播变量图解"><a href="#广播变量图解" class="headerlink" title="广播变量图解"></a>广播变量图解</h3><p>错误的，不使用广播变量</p>
<p><img src="https://yerias.github.io/spark_img/%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F.png" alt="不使用广播变量"></p>
<p>正确的，使用广播变量的情况</p>
<p><img src="https://yerias.github.io/spark_img/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F.png" alt="使用广播变量"></p>
<h3 id="小表广播案例"><a href="#小表广播案例" class="headerlink" title="小表广播案例"></a>小表广播案例</h3><p>使用广播变量的场景很多， 我们都知道spark 一种常见的优化方式就是小表广播， 使用 map join 来代替 reduce join， 我们通过把小的数据集广播到各个节点上，节省了一次特别 expensive 的 shuffle 操作。</p>
<p>比如driver 上有一张数据量很小的表， 其他节点上的task 都需要 lookup 这张表， 那么 driver 可以先把这张表 copy 到这些节点，这样 task 就可以在本地查表了。</p>
<ol>
<li><p>Fact table  航线(起点机场, 终点机场, 航空公司, 起飞时间)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SEA,JFK,DL,7:00</span><br><span class="line">SFO,LAX,AA,7:05</span><br><span class="line">SFO,JFK,VX,7:05</span><br><span class="line">JFK,LAX,DL,7:10</span><br><span class="line">LAX,SEA,DL,7:10</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dimension table 机场(简称, 全称, 城市, 所处城市简称)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JFK,John F. Kennedy International Airport,New York,NY</span><br><span class="line">LAX,Los Angeles International Airport,Los Angeles,CA</span><br><span class="line">SEA,Seattle-Tacoma International Airport,Seattle,WA</span><br><span class="line">SFO,San Francisco International Airport,San Francisco,CA</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dimension table  航空公司(简称,全称)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AA,American Airlines</span><br><span class="line">DL,Delta Airlines</span><br><span class="line">VX,Virgin America</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：将机场维度表和航空公司维度表进行广播，生成Map，航线事实表从广播变量中通过key拿到value(计算在每个executor上)</p>
</li>
<li><p>代码</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BroadcastApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fact table  航线(起点机场, 终点机场, 航空公司, 起飞时间)</span></span><br><span class="line">        <span class="keyword">val</span> flights = sc.textFile(<span class="string">"tunan-spark-core/broadcast/flights.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dimension table 机场(简称, 全称, 城市, 所处城市简称)</span></span><br><span class="line">        <span class="keyword">val</span> airports: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"tunan-spark-core/broadcast/airports.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dimension table  航空公司(简称,全称)</span></span><br><span class="line">        <span class="keyword">val</span> airlines = sc.textFile(<span class="string">"tunan-spark-core/broadcast/airlines.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最终统计结果：</span></span><br><span class="line"><span class="comment">         * 出发城市           终点城市           航空公司名称         起飞时间</span></span><br><span class="line"><span class="comment">         * Seattle           New York       Delta Airlines          7:00</span></span><br><span class="line"><span class="comment">         * San Francisco     Los Angeles    American Airlines       7:05</span></span><br><span class="line"><span class="comment">         * San Francisco     New York       Virgin America          7:05</span></span><br><span class="line"><span class="comment">         * New York          Los Angeles    Delta Airlines          7:10</span></span><br><span class="line"><span class="comment">         * Los Angeles       Seattle        Delta Airlines          7:10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//广播Dimension Table airport，生成Map</span></span><br><span class="line">        <span class="keyword">val</span> airportsBC = sc.broadcast(airports.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = x.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">2</span>))</span><br><span class="line">        &#125;).collectAsMap())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广播Dimension Table airlines，生成Map</span></span><br><span class="line">        <span class="keyword">val</span> airlinesBC = sc.broadcast(airlines.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = x.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;).collectAsMap())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过key获取value</span></span><br><span class="line">        flights.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">val</span> a = airportsBC.value.get(words(<span class="number">0</span>)).get</span><br><span class="line">            <span class="keyword">val</span> b = airportsBC.value.get(words(<span class="number">1</span>)).get</span><br><span class="line">            <span class="keyword">val</span> c = airlinesBC.value.get(words(<span class="number">2</span>)).get</span><br><span class="line">            a+<span class="string">"    "</span>+b+<span class="string">"    "</span>+c+<span class="string">"    "</span>+words(<span class="number">3</span>)</span><br><span class="line">        &#125;).foreach(println)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New York    	Los Angeles     Delta Airlines    7:10</span><br><span class="line">Los Angeles     Seattle    		Delta Airlines    7:10</span><br><span class="line">Seattle    		New York    	Delta Airlines    7:00</span><br><span class="line">San Francisco   Los Angeles     American Airlines 7:05</span><br><span class="line">San Francisco   New York    	Virgin America    7:05</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="为什么只能-broadcast-只读的变量"><a href="#为什么只能-broadcast-只读的变量" class="headerlink" title="为什么只能 broadcast 只读的变量"></a>为什么只能 broadcast 只读的变量</h3><p>这就涉及一致性的问题，如果变量可以被更新，那么一旦变量被某个节点更新，其他节点要不要一块更新？如果多个节点同时在更新，更新顺序是什么？怎么做同步？ 仔细想一下， 每个都很头疼， spark 目前就索性搞成了只读的。  因为分布式强一致性真的很蛋疼</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改</p>
</li>
<li><p>能不能将一个RDD使用广播变量广播出去？因为RDD是不存储数据的。<strong>可以将RDD的结果广播出去。</strong></p>
</li>
<li><p>广播变量只能在Driver端定义，<strong>不能在Executor端定义。</strong></p>
</li>
<li><p>在Driver端可以修改广播变量的值，<strong>在Executor端无法修改广播变量的值。</strong></p>
</li>
<li><p>如果executor端用到了Driver的变量，<strong>不使用广播变量在Executor有多少task就有多少Driver端的变量副本。</strong></p>
</li>
<li><p>如果Executor端用到了Driver的变量，<strong>使用广播变量在每个Executor中只有一份Driver端的变量副本。</strong></p>
</li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/">&lt;&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/">&gt;&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>