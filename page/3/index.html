<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BigData Developer"><meta name="keywords" content="yerias,TUNANのBlog,BigData"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">133</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">TUNANのBlog</div><div id="site-sub-title">感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/20/spark/20/">Spark Streaming简介&amp;Spark Streaming的内部结构&amp;StreamingContext对象&amp;离散流（DStream）&amp;IDEA开发Spark Streaming</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><hr>
<p>参考博客: <a href="https://vinxikk.github.io/2018/05/29/spark/" target="_blank" rel="noopener">https://vinxikk.github.io/2018/05/29/spark/</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>Spark Streaming简介</li>
<li>Spark Streaming的内部结构</li>
<li>StreamingContext对象</li>
<li>离散流（DStream）</li>
<li>IDEA开发Spark Streaming</li>
</ol>
<h2 id="Spark-Streaming简介"><a href="#Spark-Streaming简介" class="headerlink" title="Spark Streaming简介"></a>Spark Streaming简介</h2><p>Spark Streaming是核心Spark API的扩展，实现<strong>可扩展</strong>、<strong>高吞吐量</strong>、<strong>可容错的实时数据流处理</strong>。数据可以从诸如Kafka，Flume，Kinesis或TCP套接字等众多来源获取，并且可以使用由高级函数（如map，reduce，join和window）开发的复杂算法进行流数据处理。最后，处理后的数据可以被推送到文件系统，数据库和实时仪表板。而且还可以在数据流上应用Spark提供的机器学习和图处理算法。</p>
<p><img src="https://yerias.github.io/spark_img/what-is-spark-streaming.png" alt="what-is-spark-streaming"></p>
<h2 id="Spark-Streaming的内部结构"><a href="#Spark-Streaming的内部结构" class="headerlink" title="Spark Streaming的内部结构"></a>Spark Streaming的内部结构</h2><p>在内部，它的工作原理如下。Spark Streaming接收实时输入数据流，并将数据切分成批，然后由Spark引擎对其进行处理，最后生成“批”形式的结果流。</p>
<p><img src="https://yerias.github.io/spark_img/streaming-batch-process.png" alt="streaming-batch-process"></p>
<p>Spark Streaming将连续的数据流抽象为discretizedstream(DStream)。在内部，DStream由一个RDD序列表示。</p>
<h2 id="StreamingContext对象"><a href="#StreamingContext对象" class="headerlink" title="StreamingContext对象"></a>StreamingContext对象</h2><p>初始化<code>StreamingContext</code>：</p>
<p>方式一，从<code>SparkConf</code>对象中创建：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Context对象：StreamingContext</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"MyNetworkWordCount"</span>).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line"><span class="comment">//指定批处理的时间间隔</span></span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>方式二，从现有的<code>SparkContext</code>实例中创建：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(sc, <span class="type">Seconds</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>appName参数是应用程序在集群UI上显示的名称。</li>
<li>master是Spark，Mesos或YARN集群的URL，或者一个特殊的<code>“local [*]”</code>字符串来让程序以本地模式运行。</li>
<li>当在集群上运行程序时，不需要在程序中硬编码master参数，而是使用spark-submit提交应用程序并将master的URL以脚本参数的形式传入。但是，对于本地测试和单元测试，您可以通过<code>“local[*]”</code>来运行Spark Streaming程序（请确保本地系统中的cpu核心数够用）。</li>
<li><code>StreamingContext</code>会内在的创建一个<code>SparkContext</code>的实例（所有Spark功能的起始点），你可以通过<code>ssc.sparkContext</code>访问到这个实例。</li>
<li>批处理的时间窗口长度必须根据应用程序的延迟要求和可用的集群资源进行设置。</li>
</ul>
<p>注意：</p>
<ul>
<li>一旦一个<code>StreamingContext</code>开始运作，就不能设置或添加新的流计算。</li>
<li>一旦一个上下文被停止，它将无法重新启动。</li>
<li>同一时刻，一个JVM中只能有一个<code>StreamingContext</code>处于活动状态。</li>
<li><code>StreamingContext</code>上的<code>stop()</code>方法也会停止<code>SparkContext</code>。 要仅停止<code>StreamingContext</code>（保持<code>SparkContext</code>活跃），请将<code>stop()</code> 方法的可选参数<code>stopSparkContext</code>设置为<code>false</code>。</li>
<li>只要前一个<code>StreamingContext</code>在下一个<code>StreamingContext</code>被创建之前停止（不停止<code>SparkContext</code>），<code>SparkContext</code>就可以被重用来创建多个<code>StreamingContext</code>。</li>
</ul>
<h2 id="离散流（DStream）"><a href="#离散流（DStream）" class="headerlink" title="离散流（DStream）"></a>离散流（DStream）</h2><p><code>DiscretizedStream</code>(<code>DStream</code>) 是Spark Streaming对流式数据的基本抽象。它表示连续的数据流，这些连续的数据流可以是从数据源接收的输入数据流，也可以是通过对输入数据流执行转换操作而生成的经处理的数据流。在内部，<code>DStream</code>由一系列连续的RDD表示，如下图：</p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-1.png" alt="streaming-dstream-1"></p>
<p>我们将一行行文本组成的流转换为单词流，具体做法为：将<code>flatMap</code>操作应用于名为lines的 DStream中的每个RDD上，以生成words DStream的RDD。如下图所示：</p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-2.png" alt="streaming-dstream-2"></p>
<p>但是DStream和RDD也有区别，下面画图说明：</p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-3.png" alt="streaming-dstream-3"></p>
<p><img src="https://yerias.github.io/spark_img/streaming-dstream-4.png" alt="streaming-dstream-4"></p>
<h2 id="IDEA开发Spark-Streaming"><a href="#IDEA开发Spark-Streaming" class="headerlink" title="IDEA开发Spark Streaming"></a>IDEA开发Spark Streaming</h2><p>要编写自己的Spark流程序，必须将以下依赖项添加到Maven项目中。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spark-streaming_2<span class="number">.12</span>&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.4</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="SocketFile简单的单词计数"><a href="#SocketFile简单的单词计数" class="headerlink" title="SocketFile简单的单词计数"></a>SocketFile简单的单词计数</h3><ol>
<li><p>实现代scala代码逻辑</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到StreamingContext对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    dispose(ssc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启StreamingContext</span></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dispose</span></span>(ssc: <span class="type">StreamingContext</span>) = &#123;</span><br><span class="line">    <span class="comment">//输入记录</span></span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑处理</span></span><br><span class="line">    <span class="keyword">val</span> words = text.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> pair = words.map(x =&gt; (x, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> result = pair.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出记录</span></span><br><span class="line">    result.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用nc发送消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">$ nc -lk <span class="number">9100</span></span><br><span class="line"></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端接收消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1357008430000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(hello,<span class="number">1</span>)</span><br><span class="line">(world,<span class="number">1</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>DStreams 是表示从源端接收的输入数据的数据流。在这个简单的示例中，行是一个输入DStream，因为它表示从netcat服务器接收到的数据流。每个输入DStream(本节后面讨论的文件流除外)都与接收方(Scala doc、Java doc)对象相关联，接收方接收来自源的数据并将其存储在Spark内存中进行处理。</p>
<p><code>注意</code>：Spark流应用程序需要分配足够的Core来处理接收到的数据，以及运行接收方。设置core的数量要大于Receivers的数量。</p>
<h3 id="Checkpoint维护State"><a href="#Checkpoint维护State" class="headerlink" title="Checkpoint维护State"></a>Checkpoint维护State</h3><p>什么是updateStateByKey?</p>
<ul>
<li><strong>updateStateByKey</strong>(<em>func</em>)可以返回一个新“state”的DStream，其中通过对键的前一个状态和键的新值应用给定的函数来更新每个键的状态。这可以用来维护每个键的任意状态数据。</li>
</ul>
<p>什么是Checkpoint?</p>
<ul>
<li>Checkpoint可以通过在一个容错的、可靠的文件系统中设置一个目录来启用，Checkpoint信息将被保存到这个目录中。这是通过使用streamingContext.checkpoint(checkpointDirectory)实现的。</li>
</ul>
<ol>
<li><p>下面案例也是单词计数，只不过需求变成了<strong>求当天到现在为止的单词计数</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    dispose(ssc)</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dispose</span></span>(ssc: <span class="type">StreamingContext</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置checkpoint目录，保存offset</span></span><br><span class="line">    ssc.checkpoint(<span class="string">"./chk"</span>)</span><br><span class="line">    <span class="comment">// updateStateByKey：维护记录的state</span></span><br><span class="line">    lines.flatMap(_.split(<span class="string">" "</span>)).map((_, <span class="number">1</span>)).updateStateByKey(updateFunction)</span><br><span class="line">    .print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现对新值和旧值的累加</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateFunction</span></span>(newValues: <span class="type">Seq</span>[<span class="type">Int</span>], oldValues: <span class="type">Option</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> curr = newValues.sum</span><br><span class="line">    <span class="keyword">val</span> old = oldValues.getOrElse(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> count = curr + old</span><br><span class="line">    <span class="type">Some</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用nc发送消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">$ nc -lk <span class="number">9100</span></span><br><span class="line"></span><br><span class="line">a a a b b c</span><br><span class="line">a a a b b c</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端接收消息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1587439170000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,<span class="number">2</span>)</span><br><span class="line">(a,<span class="number">3</span>)</span><br><span class="line">(c,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1587439175000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(b,<span class="number">4</span>)</span><br><span class="line">(a,<span class="number">6</span>)</span><br><span class="line">(c,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上面的代码一直运行，结果可以一直累加，但是代码一旦停止运行，再次运行时，结果会不会接着上一次进行计算，上一次的计算结果丢失了，主要原因上每次程序运行都会初始化一个程序入口，而2次运行的程序入口不是同一个入口，所以会导致第一次计算的结果丢失</p>
<p>第一次的运算结果状态保存在Driver里面，所以我们如果想用上一次的计算结果，我们需要将上一次的Driver里面的运行结果状态取出来，而上面的代码有一个checkpoint方法，它会把上一次Driver里面的运算结果状态保存在checkpoint的目录里面，我们在第二次启动程序时，从checkpoint里面取出上一次的运行结果状态，把这次的Driver状态恢复成和上一次Driver一样的状态</p>
<h3 id="Checkpoint维护State-HA"><a href="#Checkpoint维护State-HA" class="headerlink" title="Checkpoint维护State HA"></a>Checkpoint维护State HA</h3><p>以下代码参考<a href="http://spark.apache.org/docs/latest/streaming-programming-guide.html#checkpointing" target="_blank" rel="noopener">官网</a></p>
<p>如果想让应用程序从驱动程序故障中恢复，我们应该重写代码，让它具备下面的功能</p>
<ul>
<li>当程序第一次启动时，它将创建一个新的StreamingContext，设置所有的流，然后调用start()。</li>
<li>当程序在失败后重新启动时，它将从Checkpoint目录中的Checkpoint数据重新创建一个StreamingContext。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> checkpoint = <span class="string">"./chk_v2"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到StreamingContext</span></span><br><span class="line">    <span class="keyword">val</span> ssc  = <span class="type">StreamingContext</span>.getOrCreate(checkpoint, functionToCreateContext)</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建StreamingContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionToCreateContext</span></span>(): <span class="type">StreamingContext</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">50000</span>))   <span class="comment">// new context</span></span><br><span class="line"></span><br><span class="line">    dispose(ssc)</span><br><span class="line"></span><br><span class="line">    ssc.checkpoint(checkpoint)   <span class="comment">// set checkpoint directory</span></span><br><span class="line">    ssc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理具题的业务逻辑</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">dispose</span></span>(ssc: <span class="type">StreamingContext</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>) <span class="comment">// create DStreams</span></span><br><span class="line"></span><br><span class="line">    lines</span><br><span class="line">    .flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    .map((_, <span class="number">1</span>))</span><br><span class="line">    .updateStateByKey(updateFunction)</span><br><span class="line">    .print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新state</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateFunction</span></span>(newValues: <span class="type">Seq</span>[<span class="type">Int</span>], oldValues: <span class="type">Option</span>[<span class="type">Int</span>]): <span class="type">Option</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> curr = newValues.sum</span><br><span class="line">    <span class="keyword">val</span> old = oldValues.getOrElse(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> count = curr + old</span><br><span class="line">    <span class="type">Some</span>(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码中维护State的方法"><a href="#源码中维护State的方法" class="headerlink" title="源码中维护State的方法"></a>源码中维护State的方法</h3><p>在阅读源码中的Example模块下Streaming下的StatefulNetworkWordCount object时，发现了一种维护State的写法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存checkpoint</span></span><br><span class="line"><span class="keyword">val</span> checkpoint = <span class="string">"./chk_v3"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 拿到 StreamingContext</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="type">StreamingContext</span>.getOrCreate(checkpoint, functionToCreateContext)</span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 StreamingContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionToCreateContext</span></span>(): <span class="type">StreamingContext</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line">    ssc.checkpoint(checkpoint)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对记录做累加操作</span></span><br><span class="line">    <span class="keyword">val</span> mappingFunc = (word: <span class="type">String</span>, one: <span class="type">Option</span>[<span class="type">Int</span>], state: <span class="type">State</span>[<span class="type">Int</span>]) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(state.isTimingOut())&#123;</span><br><span class="line">            println(<span class="string">"超时3秒没拿到数据"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">val</span> sum = one.getOrElse(<span class="number">0</span>) + state.getOption.getOrElse(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">val</span> output = (word, sum)</span><br><span class="line">            state.update(sum)</span><br><span class="line">            output</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑处理</span></span><br><span class="line">    <span class="keyword">val</span> lines = ssc.socketTextStream(<span class="string">"hadoop"</span>, <span class="number">9100</span>)</span><br><span class="line">    lines</span><br><span class="line">    .flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    .map((_,<span class="number">1</span>))</span><br><span class="line">    .mapWithState(<span class="type">StateSpec</span>.function(mappingFunc)</span><br><span class="line">                  .timeout(<span class="type">Seconds</span>(<span class="number">3</span>))</span><br><span class="line">                 ).print()</span><br><span class="line"></span><br><span class="line">    ssc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/20/spark/19/">Idea加载Spark源码，并且在控制台查询SQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><ol>
<li><p>下载Spark源码</p>
<p>本次案例，我们使用Apche版本，版本为：spark-2.4.5</p>
<p>下载链接：<a href="https://github.com/apache/spark" target="_blank" rel="noopener">https://github.com/apache/spark</a></p>
<p><em>20200421更新：</em></p>
<p>一般使用spark对应版本的scala编译最好，如果使用不同版本的scala编译，需要修改主pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.12.10<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译Spark源码</p>
<p>在编译Spark源码之前，需要修改一些东西，原因是scope规定provided会报ClassNotFoundException</p>
<ul>
<li><p>修改hive-thriftserver模块下的pom.xm文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-continuation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-servlets<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-proxy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-util<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--       &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.eclipse.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jetty.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        &lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果还有其他类似的ClassNotFoundException，都是这个原因引起的，注释即可</p>
</li>
</ul>
<p>使用<code>git-bash</code>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -DskipTests=true</span><br><span class="line"></span><br><span class="line">## 经过漫长的等待，出现如下界面时，表示编译成功(忘记保留了，这里先用hive的)</span><br><span class="line">[INFO] Reactor Summary:</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] Hive 1.1.0-cdh5.16.2 ............................... SUCCESS [  3.119 s]</span><br><span class="line">[INFO] Hive Classifications ............................... SUCCESS [  2.406 s]</span><br><span class="line">[INFO] Hive Shims Common .................................. SUCCESS [  3.327 s]</span><br><span class="line">[INFO] Hive Shims 0.23 .................................... SUCCESS [  3.494 s]</span><br><span class="line">[INFO] Hive Shims Scheduler ............................... SUCCESS [  2.423 s]</span><br><span class="line">[INFO] Hive Shims ......................................... SUCCESS [  1.463 s]</span><br><span class="line">[INFO] Hive Common ........................................ SUCCESS [  8.382 s]</span><br><span class="line">[INFO] Hive Serde ......................................... SUCCESS [  8.001 s]</span><br><span class="line">[INFO] Hive Metastore ..................................... SUCCESS [ 28.285 s]</span><br><span class="line">[INFO] Hive Ant Utilities ................................. SUCCESS [  1.668 s]</span><br><span class="line">[INFO] Spark Remote Client ................................ SUCCESS [  4.915 s]</span><br><span class="line">[INFO] Hive Query Language ................................ SUCCESS [01:36 min]</span><br><span class="line">[INFO] Hive Service ....................................... SUCCESS [ 22.921 s]</span><br><span class="line">[INFO] Hive Accumulo Handler .............................. SUCCESS [  5.496 s]</span><br><span class="line">[INFO] Hive JDBC .......................................... SUCCESS [  5.797 s]</span><br><span class="line">[INFO] Hive Beeline ....................................... SUCCESS [  3.957 s]</span><br><span class="line">[INFO] Hive CLI ........................................... SUCCESS [  4.060 s]</span><br><span class="line">[INFO] Hive Contrib ....................................... SUCCESS [  4.321 s]</span><br><span class="line">[INFO] Hive HBase Handler ................................. SUCCESS [  5.518 s]</span><br><span class="line">[INFO] Hive HCatalog ...................................... SUCCESS [  1.399 s]</span><br><span class="line">[INFO] Hive HCatalog Core ................................. SUCCESS [  5.933 s]</span><br><span class="line">[INFO] Hive HCatalog Pig Adapter .......................... SUCCESS [  4.632 s]</span><br><span class="line">[INFO] Hive HCatalog Server Extensions .................... SUCCESS [  4.477 s]</span><br><span class="line">[INFO] Hive HCatalog Webhcat Java Client .................. SUCCESS [  4.903 s]</span><br><span class="line">[INFO] Hive HCatalog Webhcat .............................. SUCCESS [  7.452 s]</span><br><span class="line">[INFO] Hive HCatalog Streaming ............................ SUCCESS [  4.306 s]</span><br><span class="line">[INFO] Hive HWI ........................................... SUCCESS [  3.461 s]</span><br><span class="line">[INFO] Hive ODBC .......................................... SUCCESS [  3.061 s]</span><br><span class="line">[INFO] Hive Shims Aggregator .............................. SUCCESS [  0.840 s]</span><br><span class="line">[INFO] Hive TestUtils ..................................... SUCCESS [  1.077 s]</span><br><span class="line">[INFO] Hive Packaging 1.1.0-cdh5.16.2 ..................... SUCCESS [  4.194 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 04:22 min</span><br><span class="line">[INFO] Finished at: 2020-04-12T18:50:46+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
</li>
<li><p>将源码导入IDEA </p>
<p>源码以Maven方式，导入IDEA后，等待依赖加载完成</p>
<p>在编译之前需要删除spark-sql下的test包下的streaming包，不然会在<code>Build Project</code>时进入这里，引起<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>异常</p>
<p>点击<code>Build Project</code>编译</p>
</li>
</ol>
<h3 id="本地调试Spark-SQL"><a href="#本地调试Spark-SQL" class="headerlink" title="本地调试Spark SQL"></a>本地调试Spark SQL</h3><ol>
<li><p>找到<code>hive-thriftserver</code>模块，在<code>main</code>下，新建<code>resources</code>目录，并标记为资源目录</p>
</li>
<li><p>拷贝集群上如下配置文件到<code>resources</code>目录中</p>
<p>hive-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.header<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.cli.print.current.db<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.uris<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>thrift://hadoop:9083<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>指向的是运行metastore服务的主机<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器需启动 metastore 服务</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">hive --service metastore &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>SparkSQLCLIDriver</code></p>
<p>在运行之前，需要在VM options中添加参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-<span class="type">Dspark</span>.master=local[<span class="number">2</span>] -<span class="type">Djline</span>.<span class="type">WindowsTerminal</span>.directConsole=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>控制台输出如下信息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Spark</span> master: local[<span class="number">2</span>], <span class="type">Application</span> <span class="type">Id</span>: local<span class="number">-1587372819248</span></span><br><span class="line">spark-sql (<span class="keyword">default</span>)&gt; show databases;</span><br><span class="line">show databases;</span><br><span class="line">databaseName</span><br><span class="line">access_dw</span><br><span class="line"><span class="keyword">default</span></span><br><span class="line">offline_dw</span><br><span class="line">store_format</span><br></pre></td></tr></table></figure>




</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/18/error/6/">Error: java.io.IOException: Invalid LZO header</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Error/">Error</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Error/">Error</a></span><div class="content"><p>在使用Flume传输数据的时候，需要注意几个字段</p>
<p>我们这里使用的是flume传输到hdfs</p>
<p>参数：hdfs.fileType 指定的数据传输类型，默认SequenceFile，如果直接传输本文本数据，则会乱码。在传输文本数据的时候它的值要修改为DataStream</p>
<p>而现在根据我们的错误提示就知道我们使用了Lzo压缩，所以需要把它的值修改为CompressedStream，即可解决问题。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>hdfs.fileType</td>
<td>SequenceFile</td>
<td>File format: currently <code>SequenceFile</code>, <code>DataStream</code> or <code>CompressedStream</code> (1)DataStream will not compress output file and please don’t set codeC (2)CompressedStream requires set hdfs.codeC with an available codeC</td>
</tr>
</tbody></table>
<hr>
<p>还需要注意的一个参数是：hdfs.codeC ，在使用flume时，可以将数据压缩输出，它的值可选为gzip, bzip2, lzo, lzop, snappy</p>
<p>lzop的后缀是lzo</p>
<p>lzo的后缀是lzp.default</p>
<hr>
<p>还是要熟悉一下flume的文档。。。<a href="http://flume.apache.org/releases/content/1.9.0/FlumeUserGuide.html#hdfs-sink" target="_blank" rel="noopener">hdfs</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/16/spark/18/">自定义外部Text数据源</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>这里接着上次的解读jdbc数据源，现在我们自己实现一个text的外部数据源</p>
<hr>
<ol>
<li><p>创建DefaultSource类实现RelationProviderTrait，注意这里的类名必须是DefaultSource，源码中写死了</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultSource</span>  <span class="keyword">extends</span> <span class="title">RelationProvider</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(sqlContext: <span class="type">SQLContext</span>, parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span> = &#123;</span><br><span class="line">      <span class="comment">//拿到client传入的参数path</span></span><br><span class="line">    <span class="keyword">val</span> path = parameters.get(<span class="string">"path"</span>)</span><br><span class="line">      <span class="comment">//判断path是否存在</span></span><br><span class="line">    path <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(p) =&gt;<span class="keyword">new</span> <span class="type">TextDataSourceRelation</span>(sqlContext,p)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"path is required ..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义Relation，继承BashRelation和TableScan，拿到Schema和RDD[Row]</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextDataSourceRelation</span>(<span class="params">context:<span class="type">SQLContext</span>,path:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">BaseRelation</span> <span class="keyword">with</span> <span class="title">TableScan</span> <span class="keyword">with</span> <span class="title">Logging</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span> = context</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//重写StructType接口的方式实现Schema</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">schema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>&#123;</span><br><span class="line">    <span class="type">List</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"id"</span>,<span class="type">StringType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"name"</span>,<span class="type">StringType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"sex"</span>,<span class="type">StringType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"sal"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>),</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"comm"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写buildScan拿到RDD[Row]</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">      <span class="comment">//拿到文本数据</span></span><br><span class="line">    <span class="keyword">val</span> textRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sqlContext.sparkContext.textFile(path)</span><br><span class="line">      <span class="comment">//拿到每个StructField</span></span><br><span class="line">    <span class="keyword">val</span> schemaField: <span class="type">Array</span>[<span class="type">StructField</span>] = schema.fields</span><br><span class="line">      <span class="comment">//对每行数据逗号切分，并且去掉空格，返回集合</span></span><br><span class="line">    textRDD.map(_.split(<span class="string">","</span>).map(_.trim))</span><br><span class="line">      <span class="comment">//对集合中的每个元素操作，通过zipWithIndex算子可以拿到元素的内容和对应的索引号</span></span><br><span class="line">      .map(row =&gt; row.zipWithIndex.map &#123;</span><br><span class="line">          <span class="comment">//模式匹配，拿到了value和index，然后对其做操作</span></span><br><span class="line">        <span class="keyword">case</span> (value, index) =&gt; &#123;</span><br><span class="line">            <span class="comment">//通过schemaField和index拿到列名</span></span><br><span class="line">          <span class="keyword">val</span> columnName = schemaField(index).name</span><br><span class="line">            <span class="comment">//判断当前的列名是否是sex，并在工具类中做匹配，对value转换类型</span></span><br><span class="line">          <span class="type">Utils</span>.caseTo(<span class="keyword">if</span> (columnName.equalsIgnoreCase(<span class="string">"sex"</span>)) &#123;</span><br><span class="line">              <span class="comment">//如果列名是sex，列下元素是1、2或者3，则返回对应的字符</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="string">"1"</span>) &#123;</span><br><span class="line">              <span class="string">"男"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="string">"2"</span>) &#123;</span><br><span class="line">              <span class="string">"女"</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="string">"未知"</span></span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//如果列名不是sex，则直接返回元素</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value</span><br><span class="line">              <span class="comment">//传入dataType的类型，在工具类中做匹配，使value与schema的类型一致</span></span><br><span class="line">          &#125;, schemaField(index).dataType)</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//结果是个集合，转换成RDD[Row]</span></span><br><span class="line">      &#125;).map(x =&gt; <span class="type">Row</span>.fromSeq(x))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义Utils类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">caseTo</span></span>(value:<span class="type">String</span>,dataType: <span class="type">DataType</span>) =&#123;</span><br><span class="line">      <span class="comment">//模式匹配，转换value的类型</span></span><br><span class="line">    dataType <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> _:<span class="type">DoubleType</span> =&gt; value.toDouble</span><br><span class="line">      <span class="keyword">case</span> _:<span class="type">LongType</span> =&gt; value.toLong</span><br><span class="line">      <span class="keyword">case</span> _:<span class="type">StringType</span> =&gt; value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .master(<span class="string">"local[2]"</span>)</span><br><span class="line">      .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> textDF: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"com.tunan.spark.sql.extds.text"</span>).load(<span class="string">"tunan-spark-sql/extds"</span>)</span><br><span class="line"></span><br><span class="line">    textDF.printSchema()</span><br><span class="line">    textDF.show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- id: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- name: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- sex: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- sal: double (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- comm: double (nullable = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">ERROR</span> <span class="type">TextDataSourceRelation</span>: 进入buildScan方法</span><br><span class="line">+---+----+----+-------+------+</span><br><span class="line">| id|name| sex|    sal|  comm|</span><br><span class="line">+---+----+----+-------+------+</span><br><span class="line">|  <span class="number">1</span>|张三|  男|<span class="number">10000.0</span>|<span class="number">1000.0</span>|</span><br><span class="line">|  <span class="number">2</span>|李四|  男|<span class="number">12000.0</span>|<span class="number">2000.0</span>|</span><br><span class="line">|  <span class="number">3</span>|王五|  女|<span class="number">12500.0</span>|<span class="number">1000.0</span>|</span><br><span class="line">|  <span class="number">4</span>|赵六|未知|<span class="number">20000.0</span>|<span class="number">2000.0</span>|</span><br><span class="line">|  <span class="number">5</span>|图南|  男|<span class="number">21000.0</span>|<span class="number">1000.0</span>|</span><br><span class="line">|  <span class="number">6</span>|小七|  女|<span class="number">10000.0</span>|<span class="number">1500.0</span>|</span><br><span class="line">+---+----+----+-------+------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/16/spark/17/">数据列自动推导&amp;数据错误执行模式&amp;UDAF&amp;UDTF&amp;解读Spark SQL执行计划优化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>数据列自动推导</li>
<li>数据错误执行模式</li>
<li>UDAF</li>
<li>UDTF</li>
<li>解读Spark SQL执行计划优化</li>
</ol>
<h2 id="数据列自动推导"><a href="#数据列自动推导" class="headerlink" title="数据列自动推导"></a>数据列自动推导</h2><ol>
<li><p>源数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">a|b|c</span><br><span class="line"><span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span></span><br><span class="line"><span class="number">4</span>|tunan|<span class="number">6</span></span><br><span class="line"><span class="number">7</span>|<span class="number">8</span>|<span class="number">9.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码处理</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">    .builder()</span><br><span class="line">    .master(<span class="string">"local[2]"</span>)</span><br><span class="line">    .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    .getOrCreate()</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">val</span> csvDF: <span class="type">DataFrame</span> = spark.read</span><br><span class="line">    .format(<span class="string">"csv"</span>)</span><br><span class="line">    .option(<span class="string">"header"</span>,<span class="string">"true"</span>)</span><br><span class="line">    .option(<span class="string">"sep"</span>,<span class="string">"|"</span>)</span><br><span class="line">    .option(<span class="string">"interSchema"</span>,<span class="string">"true"</span>)</span><br><span class="line">    .load(<span class="string">"tunan-spark-sql/data/test.csv"</span>)</span><br><span class="line">   </span><br><span class="line">  csvDF.printSchema()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印数据Schema信息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line"> |-- a: integer (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- b: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- c: double (nullable = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数据错误执行模式"><a href="#数据错误执行模式" class="headerlink" title="数据错误执行模式"></a>数据错误执行模式</h2><p>在Spark中，读取数据时，遇到错误数据或者脏数据时，我们可以使用option设置mode，区分将错误数据是默认处理<code>PERMISSIVE</code>，还是丢弃数据<code>DROPMALFORMED</code>，还是快速失败<code>FAILFAST</code>，这些方法可以在ParseMode.scala</p>
<ol>
<li><p>源数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="string">"a"</span>:<span class="number">4</span>,:<span class="number">5</span>,<span class="string">"c"</span>:<span class="number">6</span>&#125;</span><br><span class="line">&#123;<span class="string">"a"</span>:<span class="number">7</span>,<span class="string">"b"</span>:<span class="number">8</span>,<span class="string">"c"</span>:<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jsonDF: <span class="type">DataFrame</span> = spark.read.json(<span class="string">"tunan-spark-sql/data/test.json"</span>)</span><br><span class="line">jsonDF.show()</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+----------------+----+----+----+</span><br><span class="line">| _corrupt_record|   a|   b|   c|</span><br><span class="line">+----------------+----+----+----+</span><br><span class="line">|            <span class="literal">null</span>|   <span class="number">1</span>|   <span class="number">2</span>|   <span class="number">3</span>|</span><br><span class="line">|&#123;<span class="string">"a"</span>:<span class="number">4</span>,:<span class="number">5</span>,<span class="string">"c"</span>:<span class="number">6</span>&#125;|<span class="literal">null</span>|<span class="literal">null</span>|<span class="literal">null</span>|</span><br><span class="line">|            <span class="literal">null</span>|   <span class="number">7</span>|   <span class="number">8</span>|   <span class="number">9</span>|</span><br><span class="line">+----------------+----+----+----+</span><br></pre></td></tr></table></figure>

<p>如果没有在option中设置mode选项，默认为<code>PERMISSIVE</code>，通过_corrupt_record列打印出错误信息</p>
</li>
<li><p>使用option设置mode为<code>DROPMALFORMED</code>，如果碰到错误的数据，则自动丢弃</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jsonDF: <span class="type">DataFrame</span> = spark.read.option(<span class="string">"mode"</span>,<span class="string">"DROPMALFORMED"</span>).json(<span class="string">"tunan-spark-sql/data/test.json"</span>)</span><br><span class="line">jsonDF.show()</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+---+---+---+</span><br><span class="line">|  a|  b|  c|</span><br><span class="line">+---+---+---+</span><br><span class="line">|  <span class="number">1</span>|  <span class="number">2</span>|  <span class="number">3</span>|</span><br><span class="line">|  <span class="number">7</span>|  <span class="number">8</span>|  <span class="number">9</span>|</span><br><span class="line">+---+---+---+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="UDAF"><a href="#UDAF" class="headerlink" title="UDAF"></a>UDAF</h2><ol>
<li><p>自定义一个UDAF的class或者object，作为具体的逻辑实现，需要继承<code>UserDefinedAggregateFunction</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AgeAvgUDAF</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span></span>&#123;</span><br><span class="line">    <span class="comment">//输入类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"input"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>)::<span class="type">Nil</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//聚合内部中的buffer类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"sums"</span>,<span class="type">DoubleType</span>,<span class="literal">true</span>)::</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"num"</span>,<span class="type">LongType</span>,<span class="literal">true</span>)::<span class="type">Nil</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入数据类型</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">DoubleType</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入数据类型是否和输出数据类型相等</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//聚合内部buffer的初始化</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      buffer(<span class="number">0</span>) = <span class="number">0.0</span></span><br><span class="line">      buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分区内更新聚合buffer</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>, input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      buffer.update(<span class="number">0</span>,buffer.getDouble(<span class="number">0</span>)+input.getDouble(<span class="number">0</span>))</span><br><span class="line">      buffer.update(<span class="number">1</span>,buffer.getLong(<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分区间合并</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>, buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      buffer1.update(<span class="number">0</span>,buffer1.getDouble(<span class="number">0</span>)+buffer2.getDouble(<span class="number">0</span>))</span><br><span class="line">      buffer1.update(<span class="number">1</span>,buffer1.getLong(<span class="number">1</span>)+buffer2.getLong(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终计算</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">      buffer.getDouble(<span class="number">0</span>)/buffer.getLong(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册并使用UDAF</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">     .builder()</span><br><span class="line">     .master(<span class="string">"local[2]"</span>)</span><br><span class="line">     .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">     .getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数据源</span></span><br><span class="line">   <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">Row</span>]()</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"zhangsan"</span>,<span class="number">18</span>,<span class="string">"男"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"lisi"</span>,<span class="number">20</span>,<span class="string">"男"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"wangwu"</span>,<span class="number">26</span>,<span class="string">"女"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"翠翠"</span>,<span class="number">18</span>,<span class="string">"女"</span>))</span><br><span class="line">   list.add(<span class="type">Row</span>(<span class="string">"闰土"</span>,<span class="number">8</span>,<span class="string">"男"</span>))</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 自定义Schema</span></span><br><span class="line">   <span class="keyword">val</span> schema = <span class="type">StructType</span>(</span><br><span class="line">     <span class="type">StructField</span>(<span class="string">"name"</span>, <span class="type">StringType</span>, <span class="literal">true</span>)::</span><br><span class="line">     <span class="type">StructField</span>(<span class="string">"age"</span>, <span class="type">IntegerType</span>, <span class="literal">true</span>)::</span><br><span class="line">     <span class="type">StructField</span>(<span class="string">"sex"</span>, <span class="type">StringType</span>, <span class="literal">true</span>)::<span class="type">Nil</span></span><br><span class="line">   )</span><br><span class="line">   </span><br><span class="line"><span class="comment">//创建df</span></span><br><span class="line">   <span class="keyword">val</span> df = spark.createDataFrame(list, schema)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建视图</span></span><br><span class="line">   df.createOrReplaceTempView(<span class="string">"people"</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//注册UDAF</span></span><br><span class="line">   spark.udf.register(<span class="string">"age_avg_udaf"</span>,<span class="type">AgeAvgUDAF</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//使用UDAF</span></span><br><span class="line">   spark.sql(<span class="string">"select sex,age_avg_udaf(age) as ave_age from people group by sex"</span>).show()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+---+---------+</span><br><span class="line">|sex|  ave_age|</span><br><span class="line">+---+---------+</span><br><span class="line">| 男|    <span class="number">15.33</span>|</span><br><span class="line">| 女|     <span class="number">22.0</span>|</span><br><span class="line">+---+---------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="UDTF"><a href="#UDTF" class="headerlink" title="UDTF"></a>UDTF</h2><p>UDTF还在研究，先搞个简单的案例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ExplodeUDTF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .master(<span class="string">"local[2]"</span>)</span><br><span class="line">      .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义schema  </span></span><br><span class="line">    <span class="keyword">val</span> schema = <span class="type">StructType</span>(</span><br><span class="line">      <span class="type">StructField</span>(<span class="string">"teacher"</span>, <span class="type">StringType</span>, <span class="literal">true</span>) ::</span><br><span class="line">        <span class="type">StructField</span>(<span class="string">"sources"</span>, <span class="type">StringType</span>, <span class="literal">true</span>) :: <span class="type">Nil</span></span><br><span class="line">    )</span><br><span class="line">	<span class="comment">// 自定义数据源</span></span><br><span class="line">    <span class="keyword">val</span> list = <span class="keyword">new</span> util.<span class="type">ArrayList</span>[<span class="type">Row</span>]()</span><br><span class="line">    list.add(<span class="type">Row</span>(<span class="string">"tunan"</span>, <span class="string">"hive,spark,flink"</span>))</span><br><span class="line">    list.add(<span class="type">Row</span>(<span class="string">"xiaoqi"</span>, <span class="string">"cdh,kafka,hbase"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建临时视图</span></span><br><span class="line">    <span class="keyword">val</span> df = spark.createDataFrame(list, schema)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="comment">// 使用flatMap拆分</span></span><br><span class="line">    df.flatMap(x =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> line = <span class="keyword">new</span> <span class="type">ListBuffer</span>[(<span class="type">String</span>, <span class="type">String</span>)]()</span><br><span class="line">      <span class="keyword">val</span> sources = x.getString(<span class="number">1</span>).split(<span class="string">","</span>)</span><br><span class="line">      <span class="keyword">for</span> (source &lt;- sources)&#123;</span><br><span class="line">        line.append((x.getString(<span class="number">0</span>),source))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//返回</span></span><br><span class="line">      line</span><br><span class="line">    &#125;).toDF(<span class="string">"teacher"</span>,<span class="string">"source"</span>).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">|teacher|source|</span><br><span class="line">+-------+------+</span><br><span class="line">|  tunan|  hive|</span><br><span class="line">|  tunan| spark|</span><br><span class="line">|  tunan| flink|</span><br><span class="line">| xiaoqi|   cdh|</span><br><span class="line">| xiaoqi| kafka|</span><br><span class="line">| xiaoqi| hbase|</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure>

<h2 id="解读Spark-SQL执行计划优化"><a href="#解读Spark-SQL执行计划优化" class="headerlink" title="解读Spark SQL执行计划优化"></a>解读Spark SQL执行计划优化</h2><ol>
<li><p>建空表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sqltest (<span class="keyword">key</span> <span class="keyword">string</span>,<span class="keyword">value</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">extended</span> <span class="keyword">select</span> a.key*(<span class="number">3</span>*<span class="number">5</span>),b.value <span class="keyword">from</span> sqltest a <span class="keyword">join</span> sqltest b <span class="keyword">on</span> a.key=b.key <span class="keyword">and</span> a.key &gt;<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解读执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 解析逻辑计划，做些简单的解析</span><br><span class="line">== Parsed Logical Plan ==</span><br><span class="line">'Project [unresolvedalias(('a.key * (3 * 5)), None), 'b.value]</span><br><span class="line">+- 'Join Inner, (('a.key = 'b.key) &amp;&amp; ('a.key &gt; 3))</span><br><span class="line">   :- 'SubqueryAlias `a`</span><br><span class="line">   :  +- 'UnresolvedRelation `sqltest`</span><br><span class="line">   +- 'SubqueryAlias `b`</span><br><span class="line">      +- 'UnresolvedRelation `sqltest`</span><br><span class="line"></span><br><span class="line">// 分析逻辑计划，解析出了数据类型，拿到数据库和表，拿到了序列化方式                           </span><br><span class="line">== Analyzed Logical Plan ==</span><br><span class="line">(CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE)): double, value: string</span><br><span class="line">Project [(cast(key<span class="comment">#2 as double) * cast((3 * 5) as double)) AS (CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE))#6, value#5]</span></span><br><span class="line">+- Join Inner, ((key<span class="comment">#2 = key#4) &amp;&amp; (cast(key#2 as int) &gt; 3))</span></span><br><span class="line">   :- SubqueryAlias `a`</span><br><span class="line">   :  +- SubqueryAlias `default`.`sqltest`</span><br><span class="line">   :     +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#2, value#3]</span></span><br><span class="line">   +- SubqueryAlias `b`</span><br><span class="line">      +- SubqueryAlias `default`.`sqltest`</span><br><span class="line">         +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#4, value#5]</span></span><br><span class="line"></span><br><span class="line">// 优化逻辑计划，数值类型的运算直接拿到结果，解析过滤条件</span><br><span class="line">== Optimized Logical Plan ==</span><br><span class="line">Project [(cast(key<span class="comment">#2 as double) * 15.0) AS (CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE))#6, value#5]</span></span><br><span class="line">+- Join Inner, (key<span class="comment">#2 = key#4)</span></span><br><span class="line">   :- Project [key<span class="comment">#2]</span></span><br><span class="line">   :  +- Filter (isnotnull(key<span class="comment">#2) &amp;&amp; (cast(key#2 as int) &gt; 3))</span></span><br><span class="line">   :     +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#2, value#3]</span></span><br><span class="line">   +- Filter ((cast(key<span class="comment">#4 as int) &gt; 3) &amp;&amp; isnotnull(key#4))</span></span><br><span class="line">      +- HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key<span class="comment">#4, value#5]</span></span><br><span class="line"></span><br><span class="line">//物理计划，join方式为SortMergeJoin，数据使用hashpartitioning保存，扫描表的方式是HiveTableRelation</span><br><span class="line">== Physical Plan ==</span><br><span class="line">*(5) Project [(cast(key#2 as double) * 15.0) AS (CAST(key AS DOUBLE) * CAST((3 * 5) AS DOUBLE))#6, value#5]</span><br><span class="line">+- *(5) SortMergeJoin [key#2], [key#4], Inner</span><br><span class="line">   :- *(2) Sort [key#2 ASC NULLS FIRST], false, 0</span><br><span class="line">   :  +- Exchange hashpartitioning(key<span class="comment">#2, 200)</span></span><br><span class="line">   :     +- *(1) Filter (isnotnull(key#2) &amp;&amp; (cast(key#2 as int) &gt; 3))</span><br><span class="line">   :        +- Scan hive default.sqltest [key<span class="comment">#2], HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key#2, value#3]</span></span><br><span class="line">   +- *(4) Sort [key#4 ASC NULLS FIRST], false, 0</span><br><span class="line">      +- Exchange hashpartitioning(key<span class="comment">#4, 200)</span></span><br><span class="line">         +- *(3) Filter ((cast(key#4 as int) &gt; 3) &amp;&amp; isnotnull(key#4))</span><br><span class="line">            +- Scan hive default.sqltest [key<span class="comment">#4, value#5], HiveTableRelation `default`.`sqltest`, org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe, [key#4, value#5]</span></span><br></pre></td></tr></table></figure>

<p>可以简单的看做四步，分别是解析逻辑计划、分析逻辑计划、优化逻辑计划、物理执行计划</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/15/jvm/1/">JVM之运行时数据区</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>jvm命令</li>
<li>jvm的运行时数据区</li>
<li>jvm会发生哪些ERROR</li>
<li>从一个class出发理解数据区</li>
</ol>
<h2 id="jvm命令"><a href="#jvm命令" class="headerlink" title="jvm命令"></a>jvm命令</h2><h3 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h3><ol>
<li>标准: 稳定的，长期没有变化</li>
<li>X: 相对变化较少的</li>
<li>XX: 变化较大，JVM调优重点</li>
</ol>
<p>设置参数时，idea指定在VM options里面，命令行直接加在java命令后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xss10m -XX:+PrintGCDetails JVMParams</span><br></pre></td></tr></table></figure>

<h3 id="常见的XX类型的参数"><a href="#常见的XX类型的参数" class="headerlink" title="常见的XX类型的参数"></a>常见的XX类型的参数</h3><ol>
<li><p>-XX:+PrintGCDetails: 打印GC日志</p>
</li>
<li><p>-XX:+PrintFlagsInitial: 打印所有初始的参数信息</p>
</li>
<li><p>-XX:+PrintFlagsFinal: 打印所有最终的参数信息</p>
</li>
<li><p>-Xms设置堆的最小空间大小。</p>
</li>
<li><p>-Xmx设置堆的最大空间大小。</p>
</li>
<li><p>-XX:NewSize设置新生代最小空间大小。</p>
</li>
<li><p>-XX:MaxNewSize设置新生代最大空间大小。</p>
</li>
<li><p>-XX:PermSize设置永久代最小空间大小。</p>
</li>
<li><p>-XX:MaxPermSize设置永久代最大空间大小。</p>
</li>
<li><p>-Xss设置每个线程的堆栈大小。</p>
</li>
<li><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制</p>
<p> <strong>老年代空间大小=堆空间大小-年轻代大空间大小</strong></p>
</li>
</ol>
<p>例如：</p>
<p>java -XX:+PrintFlagsFinal -version </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">uintx MaxHeapSize             := <span class="number">2048917504</span>     &#123;product&#125;</span><br><span class="line">intx MaxInlineLevel            = <span class="number">9</span>              &#123;product&#125;</span><br><span class="line">intx MaxInlineSize    		   = <span class="number">35</span>             &#123;product&#125;</span><br><span class="line">bool ParGCTrimOverflow   	   = <span class="keyword">true</span>           &#123;product&#125;</span><br><span class="line">bool ParGCUseLocalOverflow     = <span class="keyword">false</span>          &#123;product&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面只显示部分参数，但是能够说明我们需要理解的内容，即 ‘=’ 表示默认值，‘:=’ 表示被修改过的值。同时还有数值类型和布尔类型。</p>
<h3 id="几个特殊的XX类型参数"><a href="#几个特殊的XX类型参数" class="headerlink" title="几个特殊的XX类型参数"></a>几个特殊的XX类型参数</h3><p>-Xms、-Xmx、-Xss 实际上是XX类型的缩写</p>
<p>-Xms ==&gt; -XX:InitialHeapSize: 表示为: -Xms10m<br>-Xmx ==&gt; -XX:MaxHeapSize: 表示为: -Xmx10m<br>-Xss ==&gt; -XX:ThreadStackSize</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><p>查看java进程：jps</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jps</span><br><span class="line"><span class="number">13612</span> JVMParams</span><br><span class="line"><span class="number">13644</span> Jps</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看java进程的参数信息<br>jinfo -flag name pid </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag MaxHeapSize <span class="number">13612</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">2048917504</span></span><br><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag InitialHeapSize <span class="number">13612</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">130023424</span></span><br><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag ThreadStackSize <span class="number">13612</span></span><br><span class="line">-XX:ThreadStackSize=<span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>怎么理解-XX:MaxHeapSize=2048917504，-XX:InitialHeapSize=130023424 ?</p>
<p>分析：</p>
<p>我主机的物理内存为8G，2048917504k = 1.9G，130023424  = 124M</p>
<p>理论上heap的最大值为物理内存的1/4，最小值为物理内存的1/64</p>
<p>但是一般情况下，我们会把MaxHeapSize和InitialHeapSize设置相同的值，防止内存抖动</p>
</li>
<li><p>查看java进程的默认和设置的参数</p>
<p>jinfo -flags pid </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flags  <span class="number">13612</span></span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount=<span class="number">2</span> ...</span><br><span class="line">Command line:  -Xss10m -XX:+PrintGCDetails ...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jvm的运行时数据区"><a href="#jvm的运行时数据区" class="headerlink" title="jvm的运行时数据区"></a>jvm的运行时数据区</h2><p><img src="https://yerias.github.io/java_img/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="运行时数据区"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是每个线程私有的</p>
<p>程序计数器是一块较小的内存空间，它可以看做是当前线程的行号指示器，这在多线程环境下非常有用。使得线程切换后能够恢复到正确的执行位置。</p>
<p>在java虚拟机规范中，这是唯一一个没有规定任何OutOfMemoryError的地方</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>java虚拟机栈也是每个线程私有的，它的生命周期和线程相同</p>
<p>虚拟机栈描述的是java方法执行的线程内存模型: 每个方法被执行的时候，java虚拟机栈都会同步创建一个Frame(栈帧)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>最常用的就是局部变量表，局部变量表存放了编译期可知的各种java虚拟机的基本数据类型(boolean、byte、char、sort、int、long、float、double)、对象引用(reference类型)和returnAddress类型，这部分在后面讲有详细的解释。</p>
<p>在java虚拟机规范中，这个区域可能存在两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverflowError异常，常见的有循环调用方法名；如果java虚拟机栈容量可以动态扩展，当栈无法申请到足够的内存时就会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈是线程私有的</p>
<p>本地方法栈与虚拟机栈所发挥的作用是非常类似的，其区别只是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为本地(native)方法服务</p>
<p>常见的本地方法有getClass、hashCode、clone、notify、notifyAll、wait、sleep等</p>
<p>与java虚拟机栈一样，本地方法栈也会在栈深度溢出的时候或者栈扩展失败的时候抛出StackOutflowError和OutOfMemoryError异常。</p>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>java堆是所有线程共享的，是虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。</p>
<p>此内存区域的唯一目的是存放对象实例，对象实例包括对象和数组。</p>
<p>如果在java堆中没有内存完成实例分配，并且堆也无法扩展，java虚拟机将会抛出OutOfMemoryError异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是所有线程共享的</p>
<p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，简单点说就是Class。</p>
<p>方法区只是java虚拟机的规范，它属于堆的一个逻辑部分，为了和堆区分开，也叫非堆。在jdk8之前，方法区的具体实现叫做永久代，</p>
<ol>
<li>由于类及方法的信息大小很难确定，所以内存设置小了会发生OOM，设置大了又浪费</li>
<li>GC复杂度高，回收效率低</li>
<li>合并 HotSpot 与 JRockit </li>
</ol>
<p>所以在jdk8完全用元空间替换了永久代，元空间直接使用的系统内存。</p>
<p>在java虚拟机规范中，如果方法区无法满足内存分配需求时，会抛出OouOfMemoryError</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是java虚拟机规范中定义的内存区域，但是这部分也会被频繁使用，所以也可能会抛出OutOfMemoryError。</p>
<h2 id="jvm会发生哪些ERROR"><a href="#jvm会发生哪些ERROR" class="headerlink" title="jvm会发生哪些ERROR"></a>jvm会发生哪些ERROR</h2><h3 id="java堆内存OOM异常测试"><a href="#java堆内存OOM异常测试" class="headerlink" title="java堆内存OOM异常测试"></a>java堆内存OOM异常测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx10m -Xms10m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid184.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">10209413</span> bytes in <span class="number">0.080</span> secs]</span><br></pre></td></tr></table></figure>

<h3 id="java虚拟机栈和本地方法栈SOF测试"><a href="#java虚拟机栈和本地方法栈SOF测试" class="headerlink" title="java虚拟机栈和本地方法栈SOF测试"></a>java虚拟机栈和本地方法栈SOF测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss2M</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF stackSOF = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackSOF.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈深度："</span>+stackSOF.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">栈深度：<span class="number">41075</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>

<h3 id="java虚拟机栈和本地方法栈OOM测试"><a href="#java虚拟机栈和本地方法栈OOM测试" class="headerlink" title="java虚拟机栈和本地方法栈OOM测试"></a>java虚拟机栈和本地方法栈OOM测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss4m</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackleakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackleakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>死机</p>
<h3 id="方法区和运行时常量池OOM"><a href="#方法区和运行时常量池OOM" class="headerlink" title="方法区和运行时常量池OOM"></a>方法区和运行时常量池OOM</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:PerSize=<span class="number">6</span>m -XX:MaxPermSize=<span class="number">6</span>M</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>jdk8没有测试出来</p>
<h2 id="从一个class出发理解数据区"><a href="#从一个class出发理解数据区" class="headerlink" title="从一个class出发理解数据区"></a>从一个class出发理解数据区</h2><p><img src="https://yerias.github.io/java_img/class%E7%B1%BB%E5%AF%B9%E6%AF%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="class类对比运行时数据区"></p>
<p>如图所示，很容易的理解各区分别保存java代码中的哪些部分</p>
<p>堆区: 保存的People对象</p>
<p>栈区: 保存的栈帧，栈帧中保存了引用name和age和引用people</p>
<p>方法区: 保存的People.class相关的，包括类型信息、常量、静态变量sss</p>
<p>运行时常量池: 保存name和age字符串内容</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/15/spark/16/">从jdbc的角度解读外部数据源</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>首先了解三个trait，分别是BaseRelation、TableScan/PrunedScan/PrunedFilteredScan、<del>InsertableRelation</del>、RelationProvider，他们的功能在源码中解读。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代表了一个抽象的数据源。该数据源由一行行有着已知schema的数据组成（关系表）。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRelation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schema</span></span>: <span class="type">StructType</span>	<span class="comment">//schema *</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sizeInBytes</span></span>: <span class="type">Long</span> = sqlContext.conf.defaultSizeInBytes</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">needConversion</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unhandledFilters</span></span>(filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">Array</span>[<span class="type">Filter</span>] = filters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于扫描整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TableScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于裁剪整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrunedScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于裁剪并过滤整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrunedFilteredScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>], filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据的时候实现，设置overwrite是否为true</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertableRelation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">DataFrame</span>, overwrite: <span class="type">Boolean</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为自定义的数据源类型生成一个新的Relation对象</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RelationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个新的Relation</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(sqlContext: <span class="type">SQLContext</span>, parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jdbc实现"><a href="#jdbc实现" class="headerlink" title="jdbc实现"></a>jdbc实现</h2><p>JdbcRelationProvider (最初也是最终的地方)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdbcRelationProvider</span> <span class="keyword">extends</span> <span class="title">CreatableRelationProvider</span></span></span><br><span class="line"><span class="class"><span class="keyword">with</span> <span class="title">RelationProvider</span> <span class="keyword">with</span> <span class="title">DataSourceRegister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">shortName</span></span>(): <span class="type">String</span> = <span class="string">"jdbc"</span> <span class="comment">//简称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(</span><br><span class="line">        sqlContext: <span class="type">SQLContext</span>,</span><br><span class="line">        parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span> = &#123;	<span class="comment">//所有options参数以map形式传入</span></span><br><span class="line">        <span class="keyword">val</span> jdbcOptions = <span class="keyword">new</span> <span class="type">JDBCOptions</span>(parameters) <span class="comment">//把参数传入和系统参数匹配</span></span><br><span class="line">        <span class="keyword">val</span> resolver = sqlContext.conf.resolver 	<span class="comment">//忽略大小写</span></span><br><span class="line">        <span class="keyword">val</span> timeZoneId = sqlContext.conf.sessionLocalTimeZone 	<span class="comment">//拿到时区</span></span><br><span class="line">        <span class="keyword">val</span> schema = <span class="type">JDBCRelation</span>.getSchema(resolver, jdbcOptions) 	<span class="comment">//传入参数，拿到schema</span></span><br><span class="line">        <span class="keyword">val</span> parts = <span class="type">JDBCRelation</span>.columnPartition(schema, resolver, timeZoneId,  jdbcOptions) <span class="comment">//拿到分区</span></span><br><span class="line">        <span class="type">JDBCRelation</span>(schema, parts, jdbcOptions)(sqlContext.sparkSession)  <span class="comment">//拿到RDD[R]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getSchema </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSchema</span></span>(resolver: <span class="type">Resolver</span>, jdbcOptions: <span class="type">JDBCOptions</span>): <span class="type">StructType</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tableSchema = <span class="type">JDBCRDD</span>.resolveTable(jdbcOptions)   <span class="comment">//传入参数，解析table，拿到Schame</span></span><br><span class="line">    jdbcOptions.customSchema <span class="keyword">match</span> &#123; <span class="comment">//模式匹配</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(customSchema) =&gt; <span class="type">JdbcUtils</span>.getCustomSchema( </span><br><span class="line">            tableSchema, customSchema, resolver)	<span class="comment">// 返回定制的Schema</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; tableSchema 	<span class="comment">//返回直接的Schema</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolveTable (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolveTable</span></span>(options: <span class="type">JDBCOptions</span>): <span class="type">StructType</span> = &#123; 	<span class="comment">//传入参数，拿到Schame</span></span><br><span class="line">    <span class="keyword">val</span> url = options.url 	<span class="comment">//拿到url：jdbc:mysql://hadoop:3306/</span></span><br><span class="line">    <span class="keyword">val</span> table = options.tableOrQuery	<span class="comment">//拿到table：access_dw.dws_ad_phone_type_dist</span></span><br><span class="line">    <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url) <span class="comment">//拿到方言：MySQLDialect</span></span><br><span class="line">    <span class="keyword">val</span> conn: <span class="type">Connection</span> = <span class="type">JdbcUtils</span>.createConnectionFactory(options)() <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> statement = conn.prepareStatement(dialect.getSchemaQuery(table)) <span class="comment">//拿到sql：com.mysql.jdbc.JDBC42PreparedStatement@5bda157e: SELECT * FROM access_dw.dws_ad_phone_type_dist WHERE 1=0</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement.setQueryTimeout(options.queryTimeout) <span class="comment">//设置超时时间</span></span><br><span class="line">            <span class="keyword">val</span> rs = statement.executeQuery() <span class="comment">//执行查询，返回一个查询产生的数据的ResultSet对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">JdbcUtils</span>.getSchema(rs, dialect, alwaysNullable = <span class="literal">true</span>)  <span class="comment">//传入数据rs，拿到schema，接着下面的内容</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rs.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            statement.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        conn.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getSchema (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSchema</span></span>(</span><br><span class="line">    resultSet: <span class="type">ResultSet</span>, <span class="comment">//查询表返回的rs(表结构)</span></span><br><span class="line">    dialect: <span class="type">JdbcDialect</span>, <span class="comment">//MySQL方言</span></span><br><span class="line">    alwaysNullable: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">StructType</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> rsmd = resultSet.getMetaData <span class="comment">//拿到表的元数据</span></span><br><span class="line">  <span class="keyword">val</span> ncols = rsmd.getColumnCount  <span class="comment">//拿到需要的字段的列的数量</span></span><br><span class="line">  <span class="keyword">val</span> fields = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">StructField</span>](ncols) <span class="comment">//创建一个StructField类型的数组，拼接fields</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; ncols) &#123; <span class="comment">//循环出每个column</span></span><br><span class="line">    <span class="keyword">val</span> columnName = rsmd.getColumnLabel(i + <span class="number">1</span>) <span class="comment">//返回列名：phoneSystemType</span></span><br><span class="line">    <span class="keyword">val</span> dataType = rsmd.getColumnType(i + <span class="number">1</span>) 	<span class="comment">//返回数据类型：12</span></span><br><span class="line">    <span class="keyword">val</span> typeName = rsmd.getColumnTypeName(i + <span class="number">1</span>) 	<span class="comment">//返回数据类型的名称：VARCHAR</span></span><br><span class="line">    <span class="keyword">val</span> fieldSize = rsmd.getPrecision(i + <span class="number">1</span>)  <span class="comment">//返回字段大小：64</span></span><br><span class="line">    <span class="keyword">val</span> fieldScale = rsmd.getScale(i + <span class="number">1</span>)	<span class="comment">//返回scale：0</span></span><br><span class="line">    <span class="keyword">val</span> isSigned = &#123; <span class="comment">//判断是否有符号</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rsmd.isSigned(i + <span class="number">1</span>) <span class="comment">//是否有符号：false</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// Workaround for HIVE-14684:</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">SQLException</span> <span class="keyword">if</span></span><br><span class="line">        e.getMessage == <span class="string">"Method not supported"</span> &amp;&amp;</span><br><span class="line">          rsmd.getClass.getName == <span class="string">"org.apache.hive.jdbc.HiveResultSetMetaData"</span> =&gt; <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nullable = <span class="keyword">if</span> (alwaysNullable) &#123; 	<span class="comment">//判断是否可为空</span></span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rsmd.isNullable(i + <span class="number">1</span>) != <span class="type">ResultSetMetaData</span>.columnNoNulls</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> metadata = <span class="keyword">new</span> <span class="type">MetadataBuilder</span>().putLong(<span class="string">"scale"</span>, fieldScale)</span><br><span class="line">    <span class="keyword">val</span> columnType =</span><br><span class="line">      dialect.getCatalystType(dataType, typeName, fieldSize, metadata).getOrElse(</span><br><span class="line">        getCatalystType(dataType, fieldSize, fieldScale, isSigned)) <span class="comment">// 传入参数拿到类型：StringType</span></span><br><span class="line">    fields(i) = <span class="type">StructField</span>(columnName, columnType, nullable) <span class="comment">//传入列名，数据类型，是否可为空，创建StructField，并加入到fields中</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">StructType</span>(fields) <span class="comment">//传入所有的StructField构建StructType，并返回，到这里拿到最终的Schema</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBCRelation (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>[sql] <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCRelation</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    override val schema: <span class="type">StructType</span>, //拿到<span class="type">Schema</span></span></span></span><br><span class="line"><span class="class"><span class="params">    parts: <span class="type">Array</span>[<span class="type">Partition</span>], //得到分区</span></span></span><br><span class="line"><span class="class"><span class="params">    jdbcOptions: <span class="type">JDBCOptions</span></span>)(<span class="params">@transient val sparkSession: <span class="type">SparkSession</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">BaseRelation</span> <span class="title">//实现BaseRelation，必然拿到了Schema</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">PrunedFilteredScan</span> <span class="title">//实现裁剪并且过滤的扫描表</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">InsertableRelation</span> </span>&#123; <span class="comment">//实现插入的模式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span> = sparkSession.sqlContext</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> needConversion: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查JDBCRDD.compileFilter是否可以接受输入过滤器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unhandledFilters</span></span>(filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">Array</span>[<span class="type">Filter</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (jdbcOptions.pushDownPredicate) &#123;</span><br><span class="line">      filters.filter(<span class="type">JDBCRDD</span>.compileFilter(_, <span class="type">JdbcDialects</span>.get(jdbcOptions.url)).isEmpty)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      filters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建Scan</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>], filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;	<span class="comment">//requiredColumns：需要的列，filters：过滤条件</span></span><br><span class="line">    <span class="comment">// 依赖类型擦除：将RDD[InternalRow]传递回RDD[Row]</span></span><br><span class="line">    <span class="type">JDBCRDD</span>.scanTable(</span><br><span class="line">      sparkSession.sparkContext, <span class="comment">//上下文环境</span></span><br><span class="line">      schema, 	<span class="comment">//Schema</span></span><br><span class="line">      requiredColumns, <span class="comment">//需要的列</span></span><br><span class="line">      filters, <span class="comment">//过滤条件</span></span><br><span class="line">      parts,   <span class="comment">//分区</span></span><br><span class="line">      jdbcOptions).asInstanceOf[<span class="type">RDD</span>[<span class="type">Row</span>]] <span class="comment">//最终的结果转换成RDD[Row]类型</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">DataFrame</span>, overwrite: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    data.write</span><br><span class="line">      .mode(<span class="keyword">if</span> (overwrite) <span class="type">SaveMode</span>.<span class="type">Overwrite</span> <span class="keyword">else</span> <span class="type">SaveMode</span>.<span class="type">Append</span>)</span><br><span class="line">      .jdbc(jdbcOptions.url, jdbcOptions.tableOrQuery, jdbcOptions.asProperties)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> partitioningInfo = <span class="keyword">if</span> (parts.nonEmpty) <span class="string">s" [numPartitions=<span class="subst">$&#123;parts.length&#125;</span>]"</span> <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">    <span class="comment">// 计划输出中不应包含凭据，表信息就足够了。</span></span><br><span class="line">    <span class="string">s"JDBCRelation(<span class="subst">$&#123;jdbcOptions.tableOrQuery&#125;</span>)"</span> + partitioningInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanTable (阶段二: 拿RDD[Row])</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanTable</span></span>(</span><br><span class="line">    sc: <span class="type">SparkContext</span>, </span><br><span class="line">    schema: <span class="type">StructType</span>,</span><br><span class="line">    requiredColumns: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">    filters: <span class="type">Array</span>[<span class="type">Filter</span>],</span><br><span class="line">    parts: <span class="type">Array</span>[<span class="type">Partition</span>],</span><br><span class="line">    options: <span class="type">JDBCOptions</span>): <span class="type">RDD</span>[<span class="type">InternalRow</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> url = options.url <span class="comment">//拿到客户端传入的rul</span></span><br><span class="line">    <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url) <span class="comment">//拿到方言</span></span><br><span class="line">    <span class="keyword">val</span> quotedColumns = requiredColumns.map(colName =&gt; dialect.quoteIdentifier(colName)) <span class="comment">//拿到需要的列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">JDBCRDD</span>(	<span class="comment">//传入参数，返回RDD[InternalRow]</span></span><br><span class="line">        sc,</span><br><span class="line">        <span class="type">JdbcUtils</span>.createConnectionFactory(options),</span><br><span class="line">        pruneSchema(schema, requiredColumns),</span><br><span class="line">        quotedColumns,</span><br><span class="line">        filters,</span><br><span class="line">        parts,</span><br><span class="line">        url,</span><br><span class="line">        options)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBCRDD(阶段二: 拿RDD[Row])</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示通过JDBC访问的数据库中的表的RDD。</span></span><br><span class="line"><span class="keyword">private</span>[jdbc] <span class="class"><span class="keyword">class</span> <span class="title">JDBCRDD</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    sc: <span class="type">SparkContext</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    getConnection: (</span>) <span class="title">=&gt;</span> <span class="title">Connection</span>,</span></span><br><span class="line"><span class="class">    <span class="title">schema</span></span>: <span class="type">StructType</span>,</span><br><span class="line">    columns: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">    filters: <span class="type">Array</span>[<span class="type">Filter</span>],</span><br><span class="line">    partitions: <span class="type">Array</span>[<span class="type">Partition</span>],</span><br><span class="line">    url: <span class="type">String</span>,</span><br><span class="line">    options: <span class="type">JDBCOptions</span>)</span><br><span class="line"><span class="keyword">extends</span> <span class="type">RDD</span>[<span class="type">InternalRow</span>](sc, <span class="type">Nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引与此RDD对应的分区列表。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartitions</span></span>: <span class="type">Array</span>[<span class="type">Partition</span>] = partitions</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `columns` 作为一个字符串注入到SQL查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> columnList: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sb = <span class="keyword">new</span> <span class="type">StringBuilder</span>()</span><br><span class="line">        columns.foreach(x =&gt; sb.append(<span class="string">","</span>).append(x))</span><br><span class="line">        <span class="keyword">if</span> (sb.isEmpty) <span class="string">"1"</span> <span class="keyword">else</span> sb.substring(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `filters`, 作为一个where语句注入到SQL查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> filterWhereClause: <span class="type">String</span> =</span><br><span class="line">    filters</span><br><span class="line">    .flatMap(<span class="type">JDBCRDD</span>.compileFilter(_, <span class="type">JdbcDialects</span>.get(url)))</span><br><span class="line">    .map(p =&gt; <span class="string">s"(<span class="subst">$p</span>)"</span>).mkString(<span class="string">" AND "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前分区有where语句，那么就拼接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getWhereClause</span></span>(part: <span class="type">JDBCPartition</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (part.whereClause != <span class="literal">null</span> &amp;&amp; filterWhereClause.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + <span class="string">s"(<span class="subst">$filterWhereClause</span>)"</span> + <span class="string">" AND "</span> + <span class="string">s"(<span class="subst">$&#123;part.whereClause&#125;</span>)"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.whereClause != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + part.whereClause</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filterWhereClause.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + filterWhereClause</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对JDBC驱动程序运行SQL查询。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(thePart: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">InternalRow</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> closed = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> rs: <span class="type">ResultSet</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> stmt: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> conn: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != rs) &#123;</span><br><span class="line">                    rs.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing resultset"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != stmt) &#123;</span><br><span class="line">                    stmt.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing statement"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != conn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!conn.isClosed &amp;&amp; !conn.getAutoCommit) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            conn.commit()</span><br><span class="line">                        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logWarning(<span class="string">"Exception committing transaction"</span>, e)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    conn.close()</span><br><span class="line">                &#125;</span><br><span class="line">                logInfo(<span class="string">"closed connection"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing connection"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.addTaskCompletionListener[<span class="type">Unit</span>]&#123; context =&gt; close() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> inputMetrics = context.taskMetrics().inputMetrics</span><br><span class="line">        <span class="keyword">val</span> part = thePart.asInstanceOf[<span class="type">JDBCPartition</span>]</span><br><span class="line">        conn = getConnection()</span><br><span class="line">        <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url)</span><br><span class="line">        <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line">        dialect.beforeFetch(conn, options.asProperties.asScala.toMap)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这在通过JDBC读取表/查询之前执行一个通用的SQL语句(或PL/SQL块)。</span></span><br><span class="line">        <span class="comment">// 使用此功能初始化数据库会话环境，例如用于优化和/或故障排除。</span></span><br><span class="line">        options.sessionInitStatement <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(sql) =&gt;</span><br><span class="line">            <span class="keyword">val</span> statement = conn.prepareStatement(sql)</span><br><span class="line">            logInfo(<span class="string">s"Executing sessionInitStatement: <span class="subst">$sql</span>"</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.setQueryTimeout(options.queryTimeout)</span><br><span class="line">                statement.execute() <span class="comment">//最终执行的就是jdbc</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                statement.close()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回RDD[InternalRow]</span></span><br><span class="line">        <span class="type">CompletionIterator</span>[<span class="type">InternalRow</span>, <span class="type">Iterator</span>[<span class="type">InternalRow</span>]](</span><br><span class="line">            <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, rowsIterator), close())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终一套debug走下来，其实就是两步</p>
<ol>
<li>第二步通过jdbc查元数据，拿到Schema</li>
<li>第二步通过jdbc查数据拿到RDD[Row]</li>
</ol>
<p><strong>最终的创建DataFrame由框架解决</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/13/spark/15/">RDD转换DadaFrame&amp;使用SQL操作数据源&amp;跨数据源join&amp;SQL与DF与DS的比较&amp;Spark元数据管理: catalog</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>RDD转换DadaFrame</li>
<li>使用SQL操作数据源</li>
<li>跨数据源join</li>
<li>SQL与DF与DS的比较</li>
<li>Spark元数据管理: catalog</li>
</ol>
<h2 id="RDD转换DadaFrame"><a href="#RDD转换DadaFrame" class="headerlink" title="RDD转换DadaFrame"></a>RDD转换DadaFrame</h2><ol>
<li><p>第一种方式是使用反射来推断包含特定对象类型的RDD的模式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/top.txt"</span></span><br><span class="line">        <span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = spark.sparkContext.textFile(in)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            people(words(<span class="number">0</span>), words(<span class="number">1</span>), words(<span class="number">2</span>).toInt)</span><br><span class="line">        &#125;)</span><br><span class="line">        mapRDD.toDF().show()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">people</span>(<span class="params">name:<span class="type">String</span>,subject:<span class="type">String</span>,grade:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过反射class的这种方式可以获得Schema创建DataFrame，简单通用，但是在<strong>创建外部数据源的场景下不适用</strong></p>
</li>
<li><p>第二种方法是通过编程接口，通过StructType可以构造Schema，然后将其应用于现有的RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/top.txt"</span></span><br><span class="line">        <span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = spark.sparkContext.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在原RDD上创建rowRDD</span></span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            <span class="type">Row</span>(words(<span class="number">0</span>), words(<span class="number">1</span>), words(<span class="number">2</span>).toDouble)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建和上一步对应的行结构类型的StructType</span></span><br><span class="line">        <span class="keyword">val</span> innerStruct =</span><br><span class="line">            <span class="type">StructType</span>(</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"name"</span>, <span class="type">StringType</span>, <span class="literal">false</span>) ::</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"subject"</span>, <span class="type">StringType</span>, <span class="literal">false</span>) ::</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"grade"</span>, <span class="type">DoubleType</span>, <span class="literal">false</span>) :: <span class="type">Nil</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将schema和Rows结合，创建出DF</span></span><br><span class="line">        <span class="keyword">val</span> df = spark.createDataFrame(mapRDD, innerStruct)</span><br><span class="line"></span><br><span class="line">        df.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>在原RDD上创建rowRDD</li>
<li>创建和上一步对应的行结构类型的StructType</li>
<li>将schema和Rows结合，创建出DF</li>
</ol>
</li>
</ol>
<h2 id="使用SQL操作数据源"><a href="#使用SQL操作数据源" class="headerlink" title="使用SQL操作数据源"></a>使用SQL操作数据源</h2><p>在官网的<a href="http://spark.apache.org/docs/latest/sql-data-sources.html" target="_blank" rel="noopener">Data Sources</a> 下，每个数据源下都有一个Sql选项卡，其中就是对应的SQL采集源数据，并生成对应的SQL视图的代码，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">spark-sql (default)&gt; CREATE TEMPORARY VIEW jsonTable</span><br><span class="line">                   &gt; USING org.apache.spark.sql.json</span><br><span class="line">                   &gt; OPTIONS (</span><br><span class="line">                   &gt;   path "file:///home/hadoop/data/people.json"</span><br><span class="line">                   &gt; );</span><br><span class="line">Response code</span><br><span class="line"></span><br><span class="line">spark-sql (default)&gt; SELECT * FROM jsonTable;</span><br><span class="line">age	name</span><br><span class="line">NULL	Michael</span><br><span class="line">30	Andy</span><br><span class="line">19	Justin</span><br></pre></td></tr></table></figure>

<h2 id="跨数据源join"><a href="#跨数据源join" class="headerlink" title="跨数据源join"></a>跨数据源join</h2><p>跨数据源join是Spark非常好用的一个特性，从不同的数据源拿到spark中，再从spark写出去，简直轻而易举。</p>
<p>下面我们将验证从hive和mysql中分别拿出一个表join(在idea中操作时，需要先连上hive)</p>
<ol>
<li><p>jdbc</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jdbcDF = spark.read</span><br><span class="line">    .format(<span class="string">"jdbc"</span>)</span><br><span class="line">    .option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://hadoop/?characterEncoding=utf-8&amp;useSSL=false"</span>)</span><br><span class="line">    .option(<span class="string">"dbtable"</span>, <span class="string">"tunan.dept"</span>)</span><br><span class="line">    .option(<span class="string">"user"</span>, <span class="string">"root"</span>)</span><br><span class="line">    .option(<span class="string">"password"</span>, <span class="string">"root"</span>)</span><br><span class="line">    .load()</span><br></pre></td></tr></table></figure>
</li>
<li><p>hive</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> hiveDF = spark.sql(<span class="string">"select * from default.emp"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>join</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> joinDF: <span class="type">DataFrame</span> = jdbcDF.join(hiveDF, <span class="string">"deptno"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&gt;&gt; joinDF.show(<span class="literal">false</span>)</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br><span class="line">|deptno|     dname|level|empno| ename|      job| jno|      date|   sal| prize|</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br><span class="line">|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">1700</span>| <span class="number">7566</span>| <span class="type">JONES</span>|  <span class="type">MANAGER</span>|<span class="number">7839</span>|  <span class="number">1981</span><span class="number">-4</span><span class="number">-2</span>|<span class="number">2975.0</span>|  <span class="literal">null</span>|</span><br><span class="line">|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">1700</span>| <span class="number">7521</span>|  <span class="type">WARD</span>| <span class="type">SALESMAN</span>|<span class="number">7698</span>| <span class="number">1981</span><span class="number">-2</span><span class="number">-22</span>|<span class="number">1250.0</span>| <span class="number">500.0</span>|</span><br><span class="line">|    <span class="number">20</span>|  <span class="type">RESEARCH</span>| <span class="number">1800</span>| <span class="number">7934</span>|<span class="type">MILLER</span>|    <span class="type">CLERK</span>|<span class="number">7782</span>| <span class="number">1982</span><span class="number">-1</span><span class="number">-23</span>|<span class="number">1300.0</span>|  <span class="literal">null</span>|</span><br><span class="line">|    <span class="number">20</span>|  <span class="type">RESEARCH</span>| <span class="number">1800</span>| <span class="number">7902</span>|  <span class="type">FORD</span>|  <span class="type">ANALYST</span>|<span class="number">7566</span>| <span class="number">1981</span><span class="number">-12</span><span class="number">-3</span>|<span class="number">3000.0</span>|  <span class="literal">null</span>|</span><br><span class="line">....</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们并不需要全部的数据，下面我们将经过处理选择我们需要的数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义视实体类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDept</span>(<span class="params">deptno:<span class="type">String</span>,dname:<span class="type">String</span>,level:<span class="type">Int</span>,empno:<span class="type">String</span>,ename:<span class="type">String</span>,job:<span class="type">String</span>,jno:<span class="type">String</span>,date:<span class="type">String</span>,sal:<span class="type">Double</span>,prize:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Result</span>(<span class="params">empno:<span class="type">String</span>,ename:<span class="type">String</span>,deptno:<span class="type">String</span>,dname:<span class="type">String</span>,prize:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//DF转换成DS</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">joinDS</span></span>: <span class="type">Dataset</span>[<span class="type">EmpDept</span>] = joinDF.as[<span class="type">EmpDept</span>]</span><br><span class="line"><span class="comment">//从DS中拿到数据，反射的方式拿到Schema信息</span></span><br><span class="line"><span class="keyword">val</span> mapDS = joinDS.map(x =&gt; <span class="type">Result</span>(x.empno, x.ename, x.deptno, x.dname,x.prize))</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存到文件</span></span><br><span class="line">mapDS.write.format(<span class="string">"orc"</span>).save(<span class="string">"tunan-spark-sql/out"</span>)</span><br><span class="line"><span class="comment">// 保存到MySQL数据库</span></span><br><span class="line">mapDS.write.format(<span class="string">"jdbc"</span>)</span><br><span class="line">.option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://hadoop/?characterEncoding=utf-8&amp;useSSL=false"</span>)</span><br><span class="line">.option(<span class="string">"dbtable"</span>, <span class="string">"tunan.join_result"</span>)</span><br><span class="line">.option(<span class="string">"user"</span>, <span class="string">"root"</span>)</span><br><span class="line">.option(<span class="string">"password"</span>, <span class="string">"root"</span>)</span><br><span class="line">.mode(<span class="string">"overwrite"</span>)</span><br><span class="line">.save()</span><br></pre></td></tr></table></figure>

<p>查看结果:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+-----+------+------+----------+------+</span><br><span class="line">|empno| ename|deptno|     dname| prize|</span><br><span class="line">+-----+------+------+----------+------+</span><br><span class="line">| <span class="number">7566</span>| <span class="type">JONES</span>|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>|  <span class="literal">null</span>|</span><br><span class="line">| <span class="number">7521</span>|  <span class="type">WARD</span>|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">500.0</span>|</span><br><span class="line">| <span class="number">7934</span>|<span class="type">MILLER</span>|    <span class="number">20</span>|  <span class="type">RESEARCH</span>|  <span class="literal">null</span>|</span><br><span class="line">| <span class="number">7902</span>|  <span class="type">FORD</span>|    <span class="number">20</span>|  <span class="type">RESEARCH</span>|  <span class="literal">null</span>|</span><br><span class="line">...</span><br><span class="line">+-----+------+------+----------+------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SQL与DF与DS的比较"><a href="#SQL与DF与DS的比较" class="headerlink" title="SQL与DF与DS的比较"></a>SQL与DF与DS的比较</h2><p>小问题：spark.read.load()   这句代码没用指定读取格式，那么它的默认格式是什么？</p>
<p>现在我们需要对比的是SQL、DF、DS三者对Syntax Errors和Analysis Errors的不同程度的响应</p>
<p>在上一步中，我们将joinDF转化成了joinDS，现在我们就看看他们在选择需要的列的时候，做了什么样的执行计划</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectDF: <span class="type">DataFrame</span> = joinDF.select(<span class="string">"ename"</span>)</span><br><span class="line"><span class="keyword">val</span> selectDS: <span class="type">Dataset</span>[<span class="type">String</span>] = joinDS.map(_.ename)</span><br><span class="line"></span><br><span class="line">println(selectDF.queryExecution.optimizedPlan.numberedTreeString)</span><br><span class="line">println(<span class="string">"-------------"</span>)</span><br><span class="line">println(selectDS.queryExecution.optimizedPlan.numberedTreeString)</span><br></pre></td></tr></table></figure>

<p>很明显selectDS做出了优化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="type">Project</span> [ename#<span class="number">7</span>]</span><br><span class="line"><span class="number">01</span> +- <span class="type">Join</span> <span class="type">Inner</span>, (deptno#<span class="number">0</span> = deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">02</span>    :- <span class="type">Project</span> [deptno#<span class="number">0</span>]</span><br><span class="line"><span class="number">03</span>    :  +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">0</span>)</span><br><span class="line"><span class="number">04</span>    :     +- <span class="type">Relation</span>[deptno#<span class="number">0</span>,dname#<span class="number">1</span>,level#<span class="number">2</span>] <span class="type">JDBCRelation</span>(tunan.dept) [numPartitions=<span class="number">1</span>]</span><br><span class="line"><span class="number">05</span>    +- <span class="type">Project</span> [ename#<span class="number">7</span>, deptno#<span class="number">13</span>]</span><br><span class="line"><span class="number">06</span>       +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">07</span>          +- <span class="type">HiveTableRelation</span> `<span class="keyword">default</span>`.`emp`, org.apache.hadoop.hive.serde2.<span class="keyword">lazy</span>.<span class="type">LazySimpleSerDe</span>, [empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>, deptno#<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="type">SerializeFromObject</span> [staticinvoke(<span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">spark</span>.<span class="title">unsafe</span>.<span class="title">types</span>.<span class="title">UTF8String</span>, <span class="title">StringType</span>, <span class="title">fromString</span>, <span class="title">input</span>[0, java.lang.<span class="type">String</span>, true], <span class="title">true</span>, <span class="title">false</span>) <span class="title">AS</span> <span class="title">value#47</span>]</span></span><br><span class="line"><span class="class">01 <span class="title">+-</span> <span class="title">MapElements</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$$$Lambda$1097/374205056@10f8e2d2</span>, <span class="title">class</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$EmpDept</span>, [<span class="type">StructField</span>(deptno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(dname,<span class="type">StringType</span>,true), <span class="type">StructField</span>(level,<span class="type">StringType</span>,true), <span class="type">StructField</span>(empno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(ename,<span class="type">StringType</span>,true), <span class="type">StructField</span>(job,<span class="type">StringType</span>,true), <span class="type">StructField</span>(jno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(date,<span class="type">StringType</span>,true), <span class="type">StructField</span>(sal,<span class="type">DoubleType</span>,false), <span class="type">StructField</span>(prize,<span class="type">StringType</span>,true)], <span class="title">obj#46</span></span>: java.lang.<span class="type">String</span></span><br><span class="line"><span class="number">02</span>    +- <span class="type">DeserializeToObject</span> newInstance(<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$EmpDept</span>), <span class="title">obj#45</span></span>: com.tunan.spark.sql.join.<span class="type">JdbcJoinHive</span>$<span class="type">EmpDept</span></span><br><span class="line"><span class="number">03</span>       +- <span class="type">Project</span> [deptno#<span class="number">0</span>, dname#<span class="number">1</span>, level#<span class="number">2</span>, empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>]</span><br><span class="line"><span class="number">04</span>          +- <span class="type">Join</span> <span class="type">Inner</span>, (deptno#<span class="number">0</span> = deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">05</span>             :- <span class="type">Filter</span> isnotnull(deptno#<span class="number">0</span>)</span><br><span class="line"><span class="number">06</span>             :  +- <span class="type">Relation</span>[deptno#<span class="number">0</span>,dname#<span class="number">1</span>,level#<span class="number">2</span>] <span class="type">JDBCRelation</span>(tunan.dept) [numPartitions=<span class="number">1</span>]</span><br><span class="line"><span class="number">07</span>             +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">08</span>                +- <span class="type">HiveTableRelation</span> `<span class="keyword">default</span>`.`emp`, org.apache.hadoop.hive.serde2.<span class="keyword">lazy</span>.<span class="type">LazySimpleSerDe</span>, [empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>, deptno#<span class="number">13</span>]</span><br></pre></td></tr></table></figure>

<p>由此我们可以根据在Spark SQL应用中，选择列的时候，SQL、DF、DS三者做一个比较</p>
<table>
<thead>
<tr>
<th></th>
<th>SQL</th>
<th>DF</th>
<th>DS</th>
</tr>
</thead>
<tbody><tr>
<td>Syntax Errors</td>
<td>runtime</td>
<td>compile</td>
<td>compile</td>
</tr>
<tr>
<td>Analysis Errors</td>
<td>runtime</td>
<td>runtime</td>
<td>compile</td>
</tr>
</tbody></table>
<p>在执行SQL的时候，无论是语法错误还是运行错误，都无法在编译时就提前暴露出来</p>
<p>在执行DF的时候，算子如果写错了，会提前暴露出来，但是写的列名只有在运行的时候才会检查是否正确</p>
<p>在执行DS的时候，由于case class反射的机制，算子和列名都可以提前到代码编写时就检测到错误</p>
<p><strong>所以最优的执行顺序为 DS &gt; DF &gt; SQL</strong></p>
<h3 id="面试题：RDD、DS、DF的区别"><a href="#面试题：RDD、DS、DF的区别" class="headerlink" title="面试题：RDD、DS、DF的区别"></a>面试题：RDD、DS、DF的区别</h3><ol>
<li>RDD不支持SQL</li>
<li>DF每一行都是Row类型，不能直接访问字段，必须解析才行</li>
<li>DS每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获 得每一行的信息</li>
<li>DataFrame与Dataset均支持spark sql的操作，比如select，group by之类，还 能注册临时表/视窗，进行sql语句操作</li>
<li>可以看出，Dataset在需要访问列中的某个字段时是非常方便的，然而，如果要 写一些适配性很强的函数时，如果使用Dataset，行的类型又不确定，可能是各种case class，无法实现适配，这时候用DataFrame即Dataset[Row]就能比较好的解决问题。</li>
</ol>
<h3 id="面试题：RDD和Dataset-DataFrame中的Persist的默认缓存级别"><a href="#面试题：RDD和Dataset-DataFrame中的Persist的默认缓存级别" class="headerlink" title="面试题：RDD和Dataset/DataFrame中的Persist的默认缓存级别"></a>面试题：RDD和Dataset/DataFrame中的Persist的默认缓存级别</h3><ul>
<li>Dataset 中的缓存级别是 MEMORY_AND_DISK</li>
<li>RDD 中的缓存级别是 MEMORY_ONLY</li>
</ul>
<h3 id="面试题：Spark-RDD和Spark-SQL的的cache有什么区别"><a href="#面试题：Spark-RDD和Spark-SQL的的cache有什么区别" class="headerlink" title="面试题：Spark RDD和Spark SQL的的cache有什么区别"></a>面试题：Spark RDD和Spark SQL的的cache有什么区别</h3><ul>
<li><p>Spark RDD的cache是lazy的，需要action才会执行cache操作</p>
</li>
<li><p>Spark SQL的cache是egaer的，马上就cache了</p>
</li>
</ul>
<h2 id="Spark元数据管理-catalog"><a href="#Spark元数据管理-catalog" class="headerlink" title="Spark元数据管理: catalog"></a>Spark元数据管理: catalog</h2><p>拿到catalog</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).enableHiveSupport().getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> catalog: <span class="type">Catalog</span> = spark.catalog</span><br></pre></td></tr></table></figure>

<ol>
<li><p>展示所有数据库</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dbList: <span class="type">Dataset</span>[<span class="type">Database</span>] = catalog.listDatabases()</span><br><span class="line">dbList.show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前数据库</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.currentDatabase</span><br></pre></td></tr></table></figure>
</li>
<li><p>只展示名字</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line">dbList.map(_.name).show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>展示指定库的所有表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.setCurrentDatabase(<span class="string">"offline_dw"</span>)</span><br><span class="line">catalog.listTables().show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listTable = catalog.listTables()</span><br><span class="line">listTable.filter(<span class="symbol">'name</span> === <span class="string">"dws_country_traffic"</span>).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断某个表是否缓存</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.isCached(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.cacheTable(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.isCached(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.uncacheTable(<span class="string">"dws_country_traffic"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：catalog的cacheTable是lazy的</strong></p>
</li>
<li><p>展示所有函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.listFunctions().show(<span class="number">1000</span>，<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册函数，再次展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">spark.udf.register(<span class="string">"udf_string_length"</span>,(word:<span class="type">String</span>) =&gt; &#123;</span><br><span class="line">    word.split(<span class="string">","</span>).length</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">catalog.listFunctions().filter(<span class="symbol">'name</span> === <span class="string">"udf_string_length"</span>).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>





</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/13/">Spark源码之解读spark-shell脚本</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>该篇文章主要分析一下Spark源码中启动spark-shell脚本的处理逻辑，从spark-shell一步步深入进去看看任务提交的整体流程</p>
<ol>
<li><p>spark-shell脚本解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化cygwin=<span class="literal">false</span></span></span><br><span class="line">cygwin=false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查你的系统是否属于cygwin</span></span><br><span class="line">case "$(uname)" in</span><br><span class="line">  CYGWIN*) cygwin=true;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置shell的模式为POSIX标准模式</span></span><br><span class="line">set -o posix</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测是否设置过SPARK_HOME环境变量</span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export _SPARK_CMD_USAGE="Usage: ./bin/spark-shell [options]</span><br><span class="line">Scala REPL options:</span><br><span class="line">  -I &lt;file&gt;                   preload &lt;file&gt;, enforcing line-by-line interpretation"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">scala默认不会使用java classpath，需要手动设置一下让scala使用java</span></span><br><span class="line">SPARK_SUBMIT_OPTS="$SPARK_SUBMIT_OPTS -Dscala.usejavacp=true"</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 判断是否是cygwin</span></span><br><span class="line">  if $cygwin; then</span><br><span class="line">    # 关闭echo回显，设置读操作最少1个字符</span><br><span class="line">    stty -icanon min 1 -echo &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    export SPARK_SUBMIT_OPTS="$SPARK_SUBMIT_OPTS -Djline.terminal=unix"</span><br><span class="line">    # 启动spark-submit 执行org.apache.spark.repl.Main类，并设置应用的名字，传递参数</span><br><span class="line">    "$&#123;SPARK_HOME&#125;"/bin/spark-submit --class org.apache.spark.repl.Main --name "Spark shell" "$@"</span><br><span class="line">    # 开启echo回显</span><br><span class="line">    stty icanon echo &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  else</span><br><span class="line">    export SPARK_SUBMIT_OPTS</span><br><span class="line">    # 启动spark-submit 执行org.apache.spark.repl.Main类，并设置应用的名字，传递参数</span><br><span class="line">    "$&#123;SPARK_HOME&#125;"/bin/spark-submit --class org.apache.spark.repl.Main --name "Spark shell" "$@"</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit_status=127</span><br><span class="line">saved_stty=""</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> restore stty settings (<span class="built_in">echo</span> <span class="keyword">in</span> particular)</span></span><br><span class="line">function restoreSttySettings() &#123;</span><br><span class="line">  stty $saved_stty</span><br><span class="line">  saved_stty=""</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断是否恢复终端设置</span></span><br><span class="line">function onExit() &#123;</span><br><span class="line">  if [[ "$saved_stty" != "" ]]; then</span><br><span class="line">    restoreSttySettings</span><br><span class="line">  fi</span><br><span class="line">  exit $exit_status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕获INT中断信号，然就执行onExit方法</span></span><br><span class="line">trap onExit INT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存了当前的终端配置</span></span><br><span class="line">saved_stty=$(stty -g 2&gt;/dev/null)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果收到退出命令，就恢复stty状态</span></span><br><span class="line">if [[ ! $? ]]; then</span><br><span class="line">  saved_stty=""</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用main方法，并传递所有的参数</span></span><br><span class="line">main "$@"</span><br><span class="line"></span><br><span class="line">exit_status=$?</span><br><span class="line">onExit</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面启动了spark-submit，接下来我们解读该脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查是否设置了<span class="variable">$&#123;SPARK_HOME&#125;</span></span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在Python 3.3+中禁用字符串的随机哈希</span></span><br><span class="line">export PYTHONHASHSEED=0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动spark-class，并传递了org.apache.spark.deploy.SparkSubmit作为第一个参数，然后把前面Spark-shell的参数都传给spark-class</span></span><br><span class="line">exec "$&#123;SPARK_HOME&#125;"/bin/spark-class org.apache.spark.deploy.SparkSubmit "$@"</span><br></pre></td></tr></table></figure>
</li>
<li><p>在spark-submit中又启动了spark-class，继续解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查/设置SPARK_HOME</span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置一些环境变量</span></span><br><span class="line">. "$&#123;SPARK_HOME&#125;"/bin/load-spark-env.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到bin/java,并赋值给RUNNER变量</span></span><br><span class="line">if [ -n "$&#123;JAVA_HOME&#125;" ]; then</span><br><span class="line">  RUNNER="$&#123;JAVA_HOME&#125;/bin/java"</span><br><span class="line">else</span><br><span class="line">  if [ "$(command -v java)" ]; then</span><br><span class="line">    RUNNER="java"</span><br><span class="line">  else</span><br><span class="line">    echo "JAVA_HOME is not set" &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">  fi  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到Spark的Jar包</span></span><br><span class="line">if [ -d "$&#123;SPARK_HOME&#125;/jars" ]; then</span><br><span class="line">  SPARK_JARS_DIR="$&#123;SPARK_HOME&#125;/jars"</span><br><span class="line">else</span><br><span class="line">  SPARK_JARS_DIR="$&#123;SPARK_HOME&#125;/assembly/target/scala-$SPARK_SCALA_VERSION/jars"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -d "$SPARK_JARS_DIR" ] &amp;&amp; [ -z "$SPARK_TESTING$SPARK_SQL_TESTING" ]; then</span><br><span class="line">  echo "Failed to find Spark jars directory ($SPARK_JARS_DIR)." 1&gt;&amp;2</span><br><span class="line">  echo "You need to build Spark with the target \"package\" before running this program." 1&gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">else</span><br><span class="line">  LAUNCH_CLASSPATH="$SPARK_JARS_DIR/*"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要，将启动程序构建目录添加到类路径。</span></span><br><span class="line">if [ -n "$SPARK_PREPEND_CLASSES" ]; then</span><br><span class="line">  LAUNCH_CLASSPATH="$&#123;SPARK_HOME&#125;/launcher/target/scala-$SPARK_SCALA_VERSION/classes:$LAUNCH_CLASSPATH"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">if [[ -n "$SPARK_TESTING" ]]; then</span><br><span class="line">  unset YARN_CONF_DIR</span><br><span class="line">  unset HADOOP_CONF_DIR</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 封装了真正的执行的spark的类</span></span><br><span class="line">build_command() &#123;</span><br><span class="line">  "$RUNNER" -Xmx128m -cp "$LAUNCH_CLASSPATH" org.apache.spark.launcher.Main "$@"</span><br><span class="line">  printf "%d\0" $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭posix模式，因为它不允许进程替换</span></span><br><span class="line">set +o posix</span><br><span class="line"></span><br><span class="line">CMD=()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先循环读取ARG参数，加入到CMD中</span></span><br><span class="line">while IFS= read -d '' -r ARG; do</span><br><span class="line">  CMD+=("$ARG")</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行Spark的类</span></span><br><span class="line">done &lt; &lt;(build_command "$@")</span><br><span class="line">COUNT=$&#123;#CMD[@]&#125;</span><br><span class="line">LAST=$((COUNT - 1))</span><br><span class="line">LAUNCHER_EXIT_CODE=$&#123;CMD[$LAST]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if ! [[ $LAUNCHER_EXIT_CODE =~ ^[0-9]+$ ]]; then</span><br><span class="line">  echo "$&#123;CMD[@]&#125;" | head -n-1 1&gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $LAUNCHER_EXIT_CODE != 0 ]; then</span><br><span class="line">  exit $LAUNCHER_EXIT_CODE</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">CMD=("$&#123;CMD[@]:0:$LAST&#125;")</span><br><span class="line">exec "$&#123;CMD[@]&#125;"</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到虽然是执行了spark-shell，但是最终执行的是<code>org.apache.spark.launcher.Main</code>类，也就是说spark-shell的最底层是使用java来启动的</p>
<p>他们的执行流程大致如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spark-shell&#123;</span><br><span class="line">	spark-submit&#123;</span><br><span class="line">		spark-class&#123;</span><br><span class="line">			   build_command() &#123;</span><br><span class="line">			   	"$RUNNER" -Xmx128m -cp "$LAUNCH_CLASSPATH" org.apache.spark.launcher.Main "$@"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/azkaban/2/">Azkaban配置Plugin实现Spark作业提交(非Shell)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Azkaban/">Azkaban</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Azkaban/">Azkaban</a></span><div class="content"><p>第一步，我们要打开azkaban的<a href="https://github.com/azkaban/azkaban/tree/master/az-hadoop-jobtype-plugin/src/jobtypes" target="_blank" rel="noopener">官网</a>，配置一些文件和参数，如图所示</p>
<p><img src="https://yerias.github.io/azkaban_img/az%E9%85%8D%E7%BD%AESpark%E6%8F%90%E4%BA%A4.jpg" alt="az配置Spark提交"></p>
<p>将<code>spark</code>、<code>common.properties</code>、<code>commonprivate.properties</code>拷贝到服务器中对应的目录，最终的文件展示如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> jobtypes]$ tree</span><br><span class="line">.</span><br><span class="line">├── commonprivate.properties</span><br><span class="line">├── common.properties</span><br><span class="line">└── spark</span><br><span class="line">    ├── plugin.properties</span><br><span class="line">    └── <span class="keyword">private</span>.properties</span><br></pre></td></tr></table></figure>

<ol>
<li><p>配置commonprivate.properties中hadoop.home和spark.home指定的家目录</p>
</li>
<li><p>配置common.properties中hadoop.home和spark.home指定的家目录</p>
</li>
<li><p>修改private.properties文件中的参数(临时方案，可行)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">jobtype.classpath=$&#123;hadoop.classpath&#125;:$&#123;spark.home&#125;/conf:$&#123;spark.home&#125;/lib<span class="comment">/*</span></span><br><span class="line"><span class="comment">===&gt;</span></span><br><span class="line"><span class="comment">jobtype.classpath=hadoop.classpath:$&#123;spark.home&#125;/conf:$&#123;spark.home&#125;/lib/*</span></span><br></pre></td></tr></table></figure>

<p>这么做的原因是我们以上的文件中没有配置hadoop.classpath，官方也没有说明hadoop.classpath应该配置什么参数，目前修改掉引用不影响程序的使用。</p>
</li>
</ol>
<p>第二步，在conf/azkaban.properties文件下增加一个配置，主机名:端口号(随意修改)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">azkaban.webserver.url=https:<span class="comment">//hadoop:8666</span></span><br></pre></td></tr></table></figure>

<p>第三步，提交作业，所配的参数需要参考<a href="https://github.com/azkaban/azkaban/blob/master/az-hadoop-jobtype-plugin/src/main/java/azkaban/jobtype/SparkJobArg.java" target="_blank" rel="noopener">官网</a></p>
<p>测试案例:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">    user.to.proxy: hadoop</span><br><span class="line">nodes:</span><br><span class="line">  - name: sparkwc</span><br><span class="line">    <span class="class"><span class="keyword">type</span></span>: spark</span><br><span class="line">    config:</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>: com.data.spark.wc.<span class="type">SparkWC</span></span><br><span class="line">      master: yarn</span><br><span class="line">      deploy-mode: client</span><br><span class="line">      executor-memory: <span class="number">512</span>M</span><br><span class="line">      driver-memory: <span class="number">512</span>M</span><br><span class="line">      conf.spark.testing.memory: <span class="number">471859200</span></span><br><span class="line">      execution-jar: tunan-spark-utils<span class="number">-1.0</span>.jar</span><br><span class="line">      jars: tunan-spark-core<span class="number">-1.0</span>.jar</span><br><span class="line">      params: hdfs:<span class="comment">//hadoop:9000/input/wc.txt hdfs://hadoop:9000/out</span></span><br></pre></td></tr></table></figure>

<p>注意配置文件中的 jar 没有写路径，这么提交<strong>需要把 jar 包和配置文件一起打成zip包</strong>，提交到AZ的Web界面</p>
<p>第四步，查看结果</p>
<p><em>20200413更新：</em>  数据下标越界问题：hadoop下的/share/hadoop/common/lib/paranamer-2.3.jar过时，使用–jars传spark下的/jars/paranamer-2.8.jar    </p>
<p><em>20200423更新：</em> 所有参数都可以使用conf传递，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution_jar  对应的是appjar</span><br><span class="line">jars 对应的是 依赖jar</span><br><span class="line">params: $&#123;execution_jar&#125; 参数<span class="number">1</span> 参数<span class="number">2</span></span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/">&lt;&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/">&gt;&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>