<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BigData Developer"><meta name="keywords" content="yerias,TUNANのBlog,BigData"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">129</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">TUNANのBlog</div><div id="site-sub-title">感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/15/jvm/1/">JVM之运行时数据区</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>jvm命令</li>
<li>jvm的运行时数据区</li>
<li>jvm会发生哪些ERROR</li>
<li>从一个class出发理解数据区</li>
</ol>
<h2 id="jvm命令"><a href="#jvm命令" class="headerlink" title="jvm命令"></a>jvm命令</h2><h3 id="JVM参数类型"><a href="#JVM参数类型" class="headerlink" title="JVM参数类型"></a>JVM参数类型</h3><ol>
<li>标准: 稳定的，长期没有变化</li>
<li>X: 相对变化较少的</li>
<li>XX: 变化较大，JVM调优重点</li>
</ol>
<p>设置参数时，idea指定在VM options里面，命令行直接加在java命令后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xss10m -XX:+PrintGCDetails JVMParams</span><br></pre></td></tr></table></figure>

<h3 id="常见的XX类型的参数"><a href="#常见的XX类型的参数" class="headerlink" title="常见的XX类型的参数"></a>常见的XX类型的参数</h3><ol>
<li><p>-XX:+PrintGCDetails: 打印GC日志</p>
</li>
<li><p>-XX:+PrintFlagsInitial: 打印所有初始的参数信息</p>
</li>
<li><p>-XX:+PrintFlagsFinal: 打印所有最终的参数信息</p>
</li>
<li><p>-Xms设置堆的最小空间大小。</p>
</li>
<li><p>-Xmx设置堆的最大空间大小。</p>
</li>
<li><p>-XX:NewSize设置新生代最小空间大小。</p>
</li>
<li><p>-XX:MaxNewSize设置新生代最大空间大小。</p>
</li>
<li><p>-XX:PermSize设置永久代最小空间大小。</p>
</li>
<li><p>-XX:MaxPermSize设置永久代最大空间大小。</p>
</li>
<li><p>-Xss设置每个线程的堆栈大小。</p>
</li>
<li><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制</p>
<p> <strong>老年代空间大小=堆空间大小-年轻代大空间大小</strong></p>
</li>
</ol>
<p>例如：</p>
<p>java -XX:+PrintFlagsFinal -version </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">uintx MaxHeapSize             := <span class="number">2048917504</span>     &#123;product&#125;</span><br><span class="line">intx MaxInlineLevel            = <span class="number">9</span>              &#123;product&#125;</span><br><span class="line">intx MaxInlineSize    		   = <span class="number">35</span>             &#123;product&#125;</span><br><span class="line">bool ParGCTrimOverflow   	   = <span class="keyword">true</span>           &#123;product&#125;</span><br><span class="line">bool ParGCUseLocalOverflow     = <span class="keyword">false</span>          &#123;product&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面只显示部分参数，但是能够说明我们需要理解的内容，即 ‘=’ 表示默认值，‘:=’ 表示被修改过的值。同时还有数值类型和布尔类型。</p>
<h3 id="几个特殊的XX类型参数"><a href="#几个特殊的XX类型参数" class="headerlink" title="几个特殊的XX类型参数"></a>几个特殊的XX类型参数</h3><p>-Xms、-Xmx、-Xss 实际上是XX类型的缩写</p>
<p>-Xms ==&gt; -XX:InitialHeapSize: 表示为: -Xms10m<br>-Xmx ==&gt; -XX:MaxHeapSize: 表示为: -Xmx10m<br>-Xss ==&gt; -XX:ThreadStackSize</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol>
<li><p>查看java进程：jps</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jps</span><br><span class="line"><span class="number">13612</span> JVMParams</span><br><span class="line"><span class="number">13644</span> Jps</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看java进程的参数信息<br>jinfo -flag name pid </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag MaxHeapSize <span class="number">13612</span></span><br><span class="line">-XX:MaxHeapSize=<span class="number">2048917504</span></span><br><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag InitialHeapSize <span class="number">13612</span></span><br><span class="line">-XX:InitialHeapSize=<span class="number">130023424</span></span><br><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flag ThreadStackSize <span class="number">13612</span></span><br><span class="line">-XX:ThreadStackSize=<span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>怎么理解-XX:MaxHeapSize=2048917504，-XX:InitialHeapSize=130023424 ?</p>
<p>分析：</p>
<p>我主机的物理内存为8G，2048917504k = 1.9G，130023424  = 124M</p>
<p>理论上heap的最大值为物理内存的1/4，最小值为物理内存的1/64</p>
<p>但是一般情况下，我们会把MaxHeapSize和InitialHeapSize设置相同的值，防止内存抖动</p>
</li>
<li><p>查看java进程的默认和设置的参数</p>
<p>jinfo -flags pid </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> ~]$ jinfo -flags  <span class="number">13612</span></span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:CICompilerCount=<span class="number">2</span> ...</span><br><span class="line">Command line:  -Xss10m -XX:+PrintGCDetails ...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="jvm的运行时数据区"><a href="#jvm的运行时数据区" class="headerlink" title="jvm的运行时数据区"></a>jvm的运行时数据区</h2><p><img src="https://yerias.github.io/java_img/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="运行时数据区"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是每个线程私有的</p>
<p>程序计数器是一块较小的内存空间，它可以看做是当前线程的行号指示器，这在多线程环境下非常有用。使得线程切换后能够恢复到正确的执行位置。</p>
<p>在java虚拟机规范中，这是唯一一个没有规定任何OutOfMemoryError的地方</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>java虚拟机栈也是每个线程私有的，它的生命周期和线程相同</p>
<p>虚拟机栈描述的是java方法执行的线程内存模型: 每个方法被执行的时候，java虚拟机栈都会同步创建一个Frame(栈帧)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直到执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>最常用的就是局部变量表，局部变量表存放了编译期可知的各种java虚拟机的基本数据类型(boolean、byte、char、sort、int、long、float、double)、对象引用(reference类型)和returnAddress类型，这部分在后面讲有详细的解释。</p>
<p>在java虚拟机规范中，这个区域可能存在两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，会抛出StackOverflowError异常，常见的有循环调用方法名；如果java虚拟机栈容量可以动态扩展，当栈无法申请到足够的内存时就会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈是线程私有的</p>
<p>本地方法栈与虚拟机栈所发挥的作用是非常类似的，其区别只是虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为本地(native)方法服务</p>
<p>常见的本地方法有getClass、hashCode、clone、notify、notifyAll、wait、sleep等</p>
<p>与java虚拟机栈一样，本地方法栈也会在栈深度溢出的时候或者栈扩展失败的时候抛出StackOutflowError和OutOfMemoryError异常。</p>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>java堆是所有线程共享的，是虚拟机所管理的内存中最大的一块，在虚拟机启动时创建。</p>
<p>此内存区域的唯一目的是存放对象实例，对象实例包括对象和数组。</p>
<p>如果在java堆中没有内存完成实例分配，并且堆也无法扩展，java虚拟机将会抛出OutOfMemoryError异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是所有线程共享的</p>
<p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，简单点说就是Class。</p>
<p>方法区只是java虚拟机的规范，它属于堆的一个逻辑部分，为了和堆区分开，也叫非堆。在jdk8之前，方法区的具体实现叫做永久代，</p>
<ol>
<li>由于类及方法的信息大小很难确定，所以内存设置小了会发生OOM，设置大了又浪费</li>
<li>GC复杂度高，回收效率低</li>
<li>合并 HotSpot 与 JRockit </li>
</ol>
<p>所以在jdk8完全用元空间替换了永久代，元空间直接使用的系统内存。</p>
<p>在java虚拟机规范中，如果方法区无法满足内存分配需求时，会抛出OouOfMemoryError</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是java虚拟机规范中定义的内存区域，但是这部分也会被频繁使用，所以也可能会抛出OutOfMemoryError。</p>
<h2 id="jvm会发生哪些ERROR"><a href="#jvm会发生哪些ERROR" class="headerlink" title="jvm会发生哪些ERROR"></a>jvm会发生哪些ERROR</h2><h3 id="java堆内存OOM异常测试"><a href="#java堆内存OOM异常测试" class="headerlink" title="java堆内存OOM异常测试"></a>java堆内存OOM异常测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xmx10m -Xms10m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid184.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">10209413</span> bytes in <span class="number">0.080</span> secs]</span><br></pre></td></tr></table></figure>

<h3 id="java虚拟机栈和本地方法栈SOF测试"><a href="#java虚拟机栈和本地方法栈SOF测试" class="headerlink" title="java虚拟机栈和本地方法栈SOF测试"></a>java虚拟机栈和本地方法栈SOF测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss2M</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF stackSOF = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackSOF.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"栈深度："</span>+stackSOF.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">栈深度：<span class="number">41075</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>

<h3 id="java虚拟机栈和本地方法栈OOM测试"><a href="#java虚拟机栈和本地方法栈OOM测试" class="headerlink" title="java虚拟机栈和本地方法栈OOM测试"></a>java虚拟机栈和本地方法栈OOM测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Xss4m</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackleakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">        oom.stackleakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>死机</p>
<h3 id="方法区和运行时常量池OOM"><a href="#方法区和运行时常量池OOM" class="headerlink" title="方法区和运行时常量池OOM"></a>方法区和运行时常量池OOM</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:PerSize=<span class="number">6</span>m -XX:MaxPermSize=<span class="number">6</span>M</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p>jdk8没有测试出来</p>
<h2 id="从一个class出发理解数据区"><a href="#从一个class出发理解数据区" class="headerlink" title="从一个class出发理解数据区"></a>从一个class出发理解数据区</h2><p><img src="https://yerias.github.io/java_img/class%E7%B1%BB%E5%AF%B9%E6%AF%94%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="class类对比运行时数据区"></p>
<p>如图所示，很容易的理解各区分别保存java代码中的哪些部分</p>
<p>堆区: 保存的People对象</p>
<p>栈区: 保存的栈帧，栈帧中保存了引用name和age和引用people</p>
<p>方法区: 保存的People.class相关的，包括类型信息、常量、静态变量sss</p>
<p>运行时常量池: 保存name和age字符串内容</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/15/spark/16/">从jdbc的角度解读外部数据源</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>首先了解三个trait，分别是BaseRelation、TableScan/PrunedScan/PrunedFilteredScan、<del>InsertableRelation</del>、RelationProvider，他们的功能在源码中解读。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代表了一个抽象的数据源。该数据源由一行行有着已知schema的数据组成（关系表）。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRelation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">schema</span></span>: <span class="type">StructType</span>	<span class="comment">//schema *</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sizeInBytes</span></span>: <span class="type">Long</span> = sqlContext.conf.defaultSizeInBytes</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">needConversion</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unhandledFilters</span></span>(filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">Array</span>[<span class="type">Filter</span>] = filters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于扫描整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TableScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于裁剪整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrunedScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于裁剪并过滤整张表，将数据返回成RDD[Row]。</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PrunedFilteredScan</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>], filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">RDD</span>[<span class="type">Row</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据的时候实现，设置overwrite是否为true</span></span><br><span class="line"><span class="meta">@InterfaceStability</span>.<span class="type">Stable</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertableRelation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">DataFrame</span>, overwrite: <span class="type">Boolean</span>): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为自定义的数据源类型生成一个新的Relation对象</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RelationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个新的Relation</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(sqlContext: <span class="type">SQLContext</span>, parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jdbc实现"><a href="#jdbc实现" class="headerlink" title="jdbc实现"></a>jdbc实现</h2><p>JdbcRelationProvider (最初也是最终的地方)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdbcRelationProvider</span> <span class="keyword">extends</span> <span class="title">CreatableRelationProvider</span></span></span><br><span class="line"><span class="class"><span class="keyword">with</span> <span class="title">RelationProvider</span> <span class="keyword">with</span> <span class="title">DataSourceRegister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">shortName</span></span>(): <span class="type">String</span> = <span class="string">"jdbc"</span> <span class="comment">//简称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createRelation</span></span>(</span><br><span class="line">        sqlContext: <span class="type">SQLContext</span>,</span><br><span class="line">        parameters: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]): <span class="type">BaseRelation</span> = &#123;	<span class="comment">//所有options参数以map形式传入</span></span><br><span class="line">        <span class="keyword">val</span> jdbcOptions = <span class="keyword">new</span> <span class="type">JDBCOptions</span>(parameters) <span class="comment">//把参数传入和系统参数匹配</span></span><br><span class="line">        <span class="keyword">val</span> resolver = sqlContext.conf.resolver 	<span class="comment">//忽略大小写</span></span><br><span class="line">        <span class="keyword">val</span> timeZoneId = sqlContext.conf.sessionLocalTimeZone 	<span class="comment">//拿到时区</span></span><br><span class="line">        <span class="keyword">val</span> schema = <span class="type">JDBCRelation</span>.getSchema(resolver, jdbcOptions) 	<span class="comment">//传入参数，拿到schema</span></span><br><span class="line">        <span class="keyword">val</span> parts = <span class="type">JDBCRelation</span>.columnPartition(schema, resolver, timeZoneId,  jdbcOptions) <span class="comment">//拿到分区</span></span><br><span class="line">        <span class="type">JDBCRelation</span>(schema, parts, jdbcOptions)(sqlContext.sparkSession)  <span class="comment">//拿到RDD[R]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getSchema </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSchema</span></span>(resolver: <span class="type">Resolver</span>, jdbcOptions: <span class="type">JDBCOptions</span>): <span class="type">StructType</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tableSchema = <span class="type">JDBCRDD</span>.resolveTable(jdbcOptions)   <span class="comment">//传入参数，解析table，拿到Schame</span></span><br><span class="line">    jdbcOptions.customSchema <span class="keyword">match</span> &#123; <span class="comment">//模式匹配</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(customSchema) =&gt; <span class="type">JdbcUtils</span>.getCustomSchema( </span><br><span class="line">            tableSchema, customSchema, resolver)	<span class="comment">// 返回定制的Schema</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; tableSchema 	<span class="comment">//返回直接的Schema</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resolveTable (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolveTable</span></span>(options: <span class="type">JDBCOptions</span>): <span class="type">StructType</span> = &#123; 	<span class="comment">//传入参数，拿到Schame</span></span><br><span class="line">    <span class="keyword">val</span> url = options.url 	<span class="comment">//拿到url：jdbc:mysql://hadoop:3306/</span></span><br><span class="line">    <span class="keyword">val</span> table = options.tableOrQuery	<span class="comment">//拿到table：access_dw.dws_ad_phone_type_dist</span></span><br><span class="line">    <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url) <span class="comment">//拿到方言：MySQLDialect</span></span><br><span class="line">    <span class="keyword">val</span> conn: <span class="type">Connection</span> = <span class="type">JdbcUtils</span>.createConnectionFactory(options)() <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> statement = conn.prepareStatement(dialect.getSchemaQuery(table)) <span class="comment">//拿到sql：com.mysql.jdbc.JDBC42PreparedStatement@5bda157e: SELECT * FROM access_dw.dws_ad_phone_type_dist WHERE 1=0</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement.setQueryTimeout(options.queryTimeout) <span class="comment">//设置超时时间</span></span><br><span class="line">            <span class="keyword">val</span> rs = statement.executeQuery() <span class="comment">//执行查询，返回一个查询产生的数据的ResultSet对象</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">JdbcUtils</span>.getSchema(rs, dialect, alwaysNullable = <span class="literal">true</span>)  <span class="comment">//传入数据rs，拿到schema，接着下面的内容</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rs.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            statement.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        conn.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getSchema (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSchema</span></span>(</span><br><span class="line">    resultSet: <span class="type">ResultSet</span>, <span class="comment">//查询表返回的rs(表结构)</span></span><br><span class="line">    dialect: <span class="type">JdbcDialect</span>, <span class="comment">//MySQL方言</span></span><br><span class="line">    alwaysNullable: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">StructType</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> rsmd = resultSet.getMetaData <span class="comment">//拿到表的元数据</span></span><br><span class="line">  <span class="keyword">val</span> ncols = rsmd.getColumnCount  <span class="comment">//拿到需要的字段的列的数量</span></span><br><span class="line">  <span class="keyword">val</span> fields = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">StructField</span>](ncols) <span class="comment">//创建一个StructField类型的数组，拼接fields</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; ncols) &#123; <span class="comment">//循环出每个column</span></span><br><span class="line">    <span class="keyword">val</span> columnName = rsmd.getColumnLabel(i + <span class="number">1</span>) <span class="comment">//返回列名：phoneSystemType</span></span><br><span class="line">    <span class="keyword">val</span> dataType = rsmd.getColumnType(i + <span class="number">1</span>) 	<span class="comment">//返回数据类型：12</span></span><br><span class="line">    <span class="keyword">val</span> typeName = rsmd.getColumnTypeName(i + <span class="number">1</span>) 	<span class="comment">//返回数据类型的名称：VARCHAR</span></span><br><span class="line">    <span class="keyword">val</span> fieldSize = rsmd.getPrecision(i + <span class="number">1</span>)  <span class="comment">//返回字段大小：64</span></span><br><span class="line">    <span class="keyword">val</span> fieldScale = rsmd.getScale(i + <span class="number">1</span>)	<span class="comment">//返回scale：0</span></span><br><span class="line">    <span class="keyword">val</span> isSigned = &#123; <span class="comment">//判断是否有符号</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        rsmd.isSigned(i + <span class="number">1</span>) <span class="comment">//是否有符号：false</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// Workaround for HIVE-14684:</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">SQLException</span> <span class="keyword">if</span></span><br><span class="line">        e.getMessage == <span class="string">"Method not supported"</span> &amp;&amp;</span><br><span class="line">          rsmd.getClass.getName == <span class="string">"org.apache.hive.jdbc.HiveResultSetMetaData"</span> =&gt; <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> nullable = <span class="keyword">if</span> (alwaysNullable) &#123; 	<span class="comment">//判断是否可为空</span></span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rsmd.isNullable(i + <span class="number">1</span>) != <span class="type">ResultSetMetaData</span>.columnNoNulls</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> metadata = <span class="keyword">new</span> <span class="type">MetadataBuilder</span>().putLong(<span class="string">"scale"</span>, fieldScale)</span><br><span class="line">    <span class="keyword">val</span> columnType =</span><br><span class="line">      dialect.getCatalystType(dataType, typeName, fieldSize, metadata).getOrElse(</span><br><span class="line">        getCatalystType(dataType, fieldSize, fieldScale, isSigned)) <span class="comment">// 传入参数拿到类型：StringType</span></span><br><span class="line">    fields(i) = <span class="type">StructField</span>(columnName, columnType, nullable) <span class="comment">//传入列名，数据类型，是否可为空，创建StructField，并加入到fields中</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">StructType</span>(fields) <span class="comment">//传入所有的StructField构建StructType，并返回，到这里拿到最终的Schema</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBCRelation (阶段一: 拿Schema)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>[sql] <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCRelation</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    override val schema: <span class="type">StructType</span>, //拿到<span class="type">Schema</span></span></span></span><br><span class="line"><span class="class"><span class="params">    parts: <span class="type">Array</span>[<span class="type">Partition</span>], //得到分区</span></span></span><br><span class="line"><span class="class"><span class="params">    jdbcOptions: <span class="type">JDBCOptions</span></span>)(<span class="params">@transient val sparkSession: <span class="type">SparkSession</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">BaseRelation</span> <span class="title">//实现BaseRelation，必然拿到了Schema</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">PrunedFilteredScan</span> <span class="title">//实现裁剪并且过滤的扫描表</span></span></span><br><span class="line"><span class="class">  <span class="keyword">with</span> <span class="title">InsertableRelation</span> </span>&#123; <span class="comment">//实现插入的模式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sqlContext</span></span>: <span class="type">SQLContext</span> = sparkSession.sqlContext</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> needConversion: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查JDBCRDD.compileFilter是否可以接受输入过滤器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unhandledFilters</span></span>(filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">Array</span>[<span class="type">Filter</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (jdbcOptions.pushDownPredicate) &#123;</span><br><span class="line">      filters.filter(<span class="type">JDBCRDD</span>.compileFilter(_, <span class="type">JdbcDialects</span>.get(jdbcOptions.url)).isEmpty)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      filters</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建Scan</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">buildScan</span></span>(requiredColumns: <span class="type">Array</span>[<span class="type">String</span>], filters: <span class="type">Array</span>[<span class="type">Filter</span>]): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;	<span class="comment">//requiredColumns：需要的列，filters：过滤条件</span></span><br><span class="line">    <span class="comment">// 依赖类型擦除：将RDD[InternalRow]传递回RDD[Row]</span></span><br><span class="line">    <span class="type">JDBCRDD</span>.scanTable(</span><br><span class="line">      sparkSession.sparkContext, <span class="comment">//上下文环境</span></span><br><span class="line">      schema, 	<span class="comment">//Schema</span></span><br><span class="line">      requiredColumns, <span class="comment">//需要的列</span></span><br><span class="line">      filters, <span class="comment">//过滤条件</span></span><br><span class="line">      parts,   <span class="comment">//分区</span></span><br><span class="line">      jdbcOptions).asInstanceOf[<span class="type">RDD</span>[<span class="type">Row</span>]] <span class="comment">//最终的结果转换成RDD[Row]类型</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">DataFrame</span>, overwrite: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    data.write</span><br><span class="line">      .mode(<span class="keyword">if</span> (overwrite) <span class="type">SaveMode</span>.<span class="type">Overwrite</span> <span class="keyword">else</span> <span class="type">SaveMode</span>.<span class="type">Append</span>)</span><br><span class="line">      .jdbc(jdbcOptions.url, jdbcOptions.tableOrQuery, jdbcOptions.asProperties)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> partitioningInfo = <span class="keyword">if</span> (parts.nonEmpty) <span class="string">s" [numPartitions=<span class="subst">$&#123;parts.length&#125;</span>]"</span> <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">    <span class="comment">// 计划输出中不应包含凭据，表信息就足够了。</span></span><br><span class="line">    <span class="string">s"JDBCRelation(<span class="subst">$&#123;jdbcOptions.tableOrQuery&#125;</span>)"</span> + partitioningInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scanTable (阶段二: 拿RDD[Row])</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanTable</span></span>(</span><br><span class="line">    sc: <span class="type">SparkContext</span>, </span><br><span class="line">    schema: <span class="type">StructType</span>,</span><br><span class="line">    requiredColumns: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">    filters: <span class="type">Array</span>[<span class="type">Filter</span>],</span><br><span class="line">    parts: <span class="type">Array</span>[<span class="type">Partition</span>],</span><br><span class="line">    options: <span class="type">JDBCOptions</span>): <span class="type">RDD</span>[<span class="type">InternalRow</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> url = options.url <span class="comment">//拿到客户端传入的rul</span></span><br><span class="line">    <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url) <span class="comment">//拿到方言</span></span><br><span class="line">    <span class="keyword">val</span> quotedColumns = requiredColumns.map(colName =&gt; dialect.quoteIdentifier(colName)) <span class="comment">//拿到需要的列</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">JDBCRDD</span>(	<span class="comment">//传入参数，返回RDD[InternalRow]</span></span><br><span class="line">        sc,</span><br><span class="line">        <span class="type">JdbcUtils</span>.createConnectionFactory(options),</span><br><span class="line">        pruneSchema(schema, requiredColumns),</span><br><span class="line">        quotedColumns,</span><br><span class="line">        filters,</span><br><span class="line">        parts,</span><br><span class="line">        url,</span><br><span class="line">        options)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBCRDD(阶段二: 拿RDD[Row])</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示通过JDBC访问的数据库中的表的RDD。</span></span><br><span class="line"><span class="keyword">private</span>[jdbc] <span class="class"><span class="keyword">class</span> <span class="title">JDBCRDD</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    sc: <span class="type">SparkContext</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    getConnection: (</span>) <span class="title">=&gt;</span> <span class="title">Connection</span>,</span></span><br><span class="line"><span class="class">    <span class="title">schema</span></span>: <span class="type">StructType</span>,</span><br><span class="line">    columns: <span class="type">Array</span>[<span class="type">String</span>],</span><br><span class="line">    filters: <span class="type">Array</span>[<span class="type">Filter</span>],</span><br><span class="line">    partitions: <span class="type">Array</span>[<span class="type">Partition</span>],</span><br><span class="line">    url: <span class="type">String</span>,</span><br><span class="line">    options: <span class="type">JDBCOptions</span>)</span><br><span class="line"><span class="keyword">extends</span> <span class="type">RDD</span>[<span class="type">InternalRow</span>](sc, <span class="type">Nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 索引与此RDD对应的分区列表。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartitions</span></span>: <span class="type">Array</span>[<span class="type">Partition</span>] = partitions</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `columns` 作为一个字符串注入到SQL查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> columnList: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sb = <span class="keyword">new</span> <span class="type">StringBuilder</span>()</span><br><span class="line">        columns.foreach(x =&gt; sb.append(<span class="string">","</span>).append(x))</span><br><span class="line">        <span class="keyword">if</span> (sb.isEmpty) <span class="string">"1"</span> <span class="keyword">else</span> sb.substring(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `filters`, 作为一个where语句注入到SQL查询</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> filterWhereClause: <span class="type">String</span> =</span><br><span class="line">    filters</span><br><span class="line">    .flatMap(<span class="type">JDBCRDD</span>.compileFilter(_, <span class="type">JdbcDialects</span>.get(url)))</span><br><span class="line">    .map(p =&gt; <span class="string">s"(<span class="subst">$p</span>)"</span>).mkString(<span class="string">" AND "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前分区有where语句，那么就拼接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getWhereClause</span></span>(part: <span class="type">JDBCPartition</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (part.whereClause != <span class="literal">null</span> &amp;&amp; filterWhereClause.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + <span class="string">s"(<span class="subst">$filterWhereClause</span>)"</span> + <span class="string">" AND "</span> + <span class="string">s"(<span class="subst">$&#123;part.whereClause&#125;</span>)"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part.whereClause != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + part.whereClause</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filterWhereClause.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="string">"WHERE "</span> + filterWhereClause</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对JDBC驱动程序运行SQL查询。</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(thePart: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">InternalRow</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> closed = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">var</span> rs: <span class="type">ResultSet</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> stmt: <span class="type">PreparedStatement</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> conn: <span class="type">Connection</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != rs) &#123;</span><br><span class="line">                    rs.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing resultset"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != stmt) &#123;</span><br><span class="line">                    stmt.close()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing statement"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != conn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!conn.isClosed &amp;&amp; !conn.getAutoCommit) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            conn.commit()</span><br><span class="line">                        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logWarning(<span class="string">"Exception committing transaction"</span>, e)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    conn.close()</span><br><span class="line">                &#125;</span><br><span class="line">                logInfo(<span class="string">"closed connection"</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logWarning(<span class="string">"Exception closing connection"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.addTaskCompletionListener[<span class="type">Unit</span>]&#123; context =&gt; close() &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> inputMetrics = context.taskMetrics().inputMetrics</span><br><span class="line">        <span class="keyword">val</span> part = thePart.asInstanceOf[<span class="type">JDBCPartition</span>]</span><br><span class="line">        conn = getConnection()</span><br><span class="line">        <span class="keyword">val</span> dialect = <span class="type">JdbcDialects</span>.get(url)</span><br><span class="line">        <span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br><span class="line">        dialect.beforeFetch(conn, options.asProperties.asScala.toMap)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这在通过JDBC读取表/查询之前执行一个通用的SQL语句(或PL/SQL块)。</span></span><br><span class="line">        <span class="comment">// 使用此功能初始化数据库会话环境，例如用于优化和/或故障排除。</span></span><br><span class="line">        options.sessionInitStatement <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(sql) =&gt;</span><br><span class="line">            <span class="keyword">val</span> statement = conn.prepareStatement(sql)</span><br><span class="line">            logInfo(<span class="string">s"Executing sessionInitStatement: <span class="subst">$sql</span>"</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.setQueryTimeout(options.queryTimeout)</span><br><span class="line">                statement.execute() <span class="comment">//最终执行的就是jdbc</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                statement.close()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回RDD[InternalRow]</span></span><br><span class="line">        <span class="type">CompletionIterator</span>[<span class="type">InternalRow</span>, <span class="type">Iterator</span>[<span class="type">InternalRow</span>]](</span><br><span class="line">            <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, rowsIterator), close())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终一套debug走下来，其实就是两步</p>
<ol>
<li>第二步通过jdbc查元数据，拿到Schema</li>
<li>第二步通过jdbc查数据拿到RDD[Row]</li>
</ol>
<p><strong>最终的创建DataFrame由框架解决</strong></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/13/spark/15/">RDD转换DadaFrame&amp;使用SQL操作数据源&amp;跨数据源join&amp;SQL与DF与DS的比较&amp;Spark元数据管理: catalog</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>RDD转换DadaFrame</li>
<li>使用SQL操作数据源</li>
<li>跨数据源join</li>
<li>SQL与DF与DS的比较</li>
<li>Spark元数据管理: catalog</li>
</ol>
<h2 id="RDD转换DadaFrame"><a href="#RDD转换DadaFrame" class="headerlink" title="RDD转换DadaFrame"></a>RDD转换DadaFrame</h2><ol>
<li><p>第一种方式是使用反射来推断包含特定对象类型的RDD的模式</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">reflect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/top.txt"</span></span><br><span class="line">        <span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = spark.sparkContext.textFile(in)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            people(words(<span class="number">0</span>), words(<span class="number">1</span>), words(<span class="number">2</span>).toInt)</span><br><span class="line">        &#125;)</span><br><span class="line">        mapRDD.toDF().show()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">people</span>(<span class="params">name:<span class="type">String</span>,subject:<span class="type">String</span>,grade:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过反射class的这种方式可以获得Schema创建DataFrame，简单通用，但是在<strong>创建外部数据源的场景下不适用</strong></p>
</li>
<li><p>第二种方法是通过编程接口，通过StructType可以构造Schema，然后将其应用于现有的RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).getOrCreate()</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/top.txt"</span></span><br><span class="line">        <span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = spark.sparkContext.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在原RDD上创建rowRDD</span></span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            <span class="type">Row</span>(words(<span class="number">0</span>), words(<span class="number">1</span>), words(<span class="number">2</span>).toDouble)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建和上一步对应的行结构类型的StructType</span></span><br><span class="line">        <span class="keyword">val</span> innerStruct =</span><br><span class="line">            <span class="type">StructType</span>(</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"name"</span>, <span class="type">StringType</span>, <span class="literal">false</span>) ::</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"subject"</span>, <span class="type">StringType</span>, <span class="literal">false</span>) ::</span><br><span class="line">            <span class="type">StructField</span>(<span class="string">"grade"</span>, <span class="type">DoubleType</span>, <span class="literal">false</span>) :: <span class="type">Nil</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将schema和Rows结合，创建出DF</span></span><br><span class="line">        <span class="keyword">val</span> df = spark.createDataFrame(mapRDD, innerStruct)</span><br><span class="line"></span><br><span class="line">        df.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<ol>
<li>在原RDD上创建rowRDD</li>
<li>创建和上一步对应的行结构类型的StructType</li>
<li>将schema和Rows结合，创建出DF</li>
</ol>
</li>
</ol>
<h2 id="使用SQL操作数据源"><a href="#使用SQL操作数据源" class="headerlink" title="使用SQL操作数据源"></a>使用SQL操作数据源</h2><p>在官网的<a href="http://spark.apache.org/docs/latest/sql-data-sources.html" target="_blank" rel="noopener">Data Sources</a> 下，每个数据源下都有一个Sql选项卡，其中就是对应的SQL采集源数据，并生成对应的SQL视图的代码，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">spark-sql (default)&gt; CREATE TEMPORARY VIEW jsonTable</span><br><span class="line">                   &gt; USING org.apache.spark.sql.json</span><br><span class="line">                   &gt; OPTIONS (</span><br><span class="line">                   &gt;   path "file:///home/hadoop/data/people.json"</span><br><span class="line">                   &gt; );</span><br><span class="line">Response code</span><br><span class="line"></span><br><span class="line">spark-sql (default)&gt; SELECT * FROM jsonTable;</span><br><span class="line">age	name</span><br><span class="line">NULL	Michael</span><br><span class="line">30	Andy</span><br><span class="line">19	Justin</span><br></pre></td></tr></table></figure>

<h2 id="跨数据源join"><a href="#跨数据源join" class="headerlink" title="跨数据源join"></a>跨数据源join</h2><p>跨数据源join是Spark非常好用的一个特性，从不同的数据源拿到spark中，再从spark写出去，简直轻而易举。</p>
<p>下面我们将验证从hive和mysql中分别拿出一个表join(在idea中操作时，需要先连上hive)</p>
<ol>
<li><p>jdbc</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> jdbcDF = spark.read</span><br><span class="line">    .format(<span class="string">"jdbc"</span>)</span><br><span class="line">    .option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://hadoop/?characterEncoding=utf-8&amp;useSSL=false"</span>)</span><br><span class="line">    .option(<span class="string">"dbtable"</span>, <span class="string">"tunan.dept"</span>)</span><br><span class="line">    .option(<span class="string">"user"</span>, <span class="string">"root"</span>)</span><br><span class="line">    .option(<span class="string">"password"</span>, <span class="string">"root"</span>)</span><br><span class="line">    .load()</span><br></pre></td></tr></table></figure>
</li>
<li><p>hive</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> hiveDF = spark.sql(<span class="string">"select * from default.emp"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>join</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> joinDF: <span class="type">DataFrame</span> = jdbcDF.join(hiveDF, <span class="string">"deptno"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&gt;&gt; joinDF.show(<span class="literal">false</span>)</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br><span class="line">|deptno|     dname|level|empno| ename|      job| jno|      date|   sal| prize|</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br><span class="line">|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">1700</span>| <span class="number">7566</span>| <span class="type">JONES</span>|  <span class="type">MANAGER</span>|<span class="number">7839</span>|  <span class="number">1981</span><span class="number">-4</span><span class="number">-2</span>|<span class="number">2975.0</span>|  <span class="literal">null</span>|</span><br><span class="line">|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">1700</span>| <span class="number">7521</span>|  <span class="type">WARD</span>| <span class="type">SALESMAN</span>|<span class="number">7698</span>| <span class="number">1981</span><span class="number">-2</span><span class="number">-22</span>|<span class="number">1250.0</span>| <span class="number">500.0</span>|</span><br><span class="line">|    <span class="number">20</span>|  <span class="type">RESEARCH</span>| <span class="number">1800</span>| <span class="number">7934</span>|<span class="type">MILLER</span>|    <span class="type">CLERK</span>|<span class="number">7782</span>| <span class="number">1982</span><span class="number">-1</span><span class="number">-23</span>|<span class="number">1300.0</span>|  <span class="literal">null</span>|</span><br><span class="line">|    <span class="number">20</span>|  <span class="type">RESEARCH</span>| <span class="number">1800</span>| <span class="number">7902</span>|  <span class="type">FORD</span>|  <span class="type">ANALYST</span>|<span class="number">7566</span>| <span class="number">1981</span><span class="number">-12</span><span class="number">-3</span>|<span class="number">3000.0</span>|  <span class="literal">null</span>|</span><br><span class="line">....</span><br><span class="line">+------+----------+-----+-----+------+---------+----+----------+------+------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们并不需要全部的数据，下面我们将经过处理选择我们需要的数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义视实体类</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">EmpDept</span>(<span class="params">deptno:<span class="type">String</span>,dname:<span class="type">String</span>,level:<span class="type">Int</span>,empno:<span class="type">String</span>,ename:<span class="type">String</span>,job:<span class="type">String</span>,jno:<span class="type">String</span>,date:<span class="type">String</span>,sal:<span class="type">Double</span>,prize:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Result</span>(<span class="params">empno:<span class="type">String</span>,ename:<span class="type">String</span>,deptno:<span class="type">String</span>,dname:<span class="type">String</span>,prize:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//DF转换成DS</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">joinDS</span></span>: <span class="type">Dataset</span>[<span class="type">EmpDept</span>] = joinDF.as[<span class="type">EmpDept</span>]</span><br><span class="line"><span class="comment">//从DS中拿到数据，反射的方式拿到Schema信息</span></span><br><span class="line"><span class="keyword">val</span> mapDS = joinDS.map(x =&gt; <span class="type">Result</span>(x.empno, x.ename, x.deptno, x.dname,x.prize))</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存到文件</span></span><br><span class="line">mapDS.write.format(<span class="string">"orc"</span>).save(<span class="string">"tunan-spark-sql/out"</span>)</span><br><span class="line"><span class="comment">// 保存到MySQL数据库</span></span><br><span class="line">mapDS.write.format(<span class="string">"jdbc"</span>)</span><br><span class="line">.option(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://hadoop/?characterEncoding=utf-8&amp;useSSL=false"</span>)</span><br><span class="line">.option(<span class="string">"dbtable"</span>, <span class="string">"tunan.join_result"</span>)</span><br><span class="line">.option(<span class="string">"user"</span>, <span class="string">"root"</span>)</span><br><span class="line">.option(<span class="string">"password"</span>, <span class="string">"root"</span>)</span><br><span class="line">.mode(<span class="string">"overwrite"</span>)</span><br><span class="line">.save()</span><br></pre></td></tr></table></figure>

<p>查看结果:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+-----+------+------+----------+------+</span><br><span class="line">|empno| ename|deptno|     dname| prize|</span><br><span class="line">+-----+------+------+----------+------+</span><br><span class="line">| <span class="number">7566</span>| <span class="type">JONES</span>|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>|  <span class="literal">null</span>|</span><br><span class="line">| <span class="number">7521</span>|  <span class="type">WARD</span>|    <span class="number">10</span>|<span class="type">ACCOUNTING</span>| <span class="number">500.0</span>|</span><br><span class="line">| <span class="number">7934</span>|<span class="type">MILLER</span>|    <span class="number">20</span>|  <span class="type">RESEARCH</span>|  <span class="literal">null</span>|</span><br><span class="line">| <span class="number">7902</span>|  <span class="type">FORD</span>|    <span class="number">20</span>|  <span class="type">RESEARCH</span>|  <span class="literal">null</span>|</span><br><span class="line">...</span><br><span class="line">+-----+------+------+----------+------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SQL与DF与DS的比较"><a href="#SQL与DF与DS的比较" class="headerlink" title="SQL与DF与DS的比较"></a>SQL与DF与DS的比较</h2><p>小问题：spark.read.load()   这句代码没用指定读取格式，那么它的默认格式是什么？</p>
<p>现在我们需要对比的是SQL、DF、DS三者对Syntax Errors和Analysis Errors的不同程度的响应</p>
<p>在上一步中，我们将joinDF转化成了joinDS，现在我们就看看他们在选择需要的列的时候，做了什么样的执行计划</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectDF: <span class="type">DataFrame</span> = joinDF.select(<span class="string">"ename"</span>)</span><br><span class="line"><span class="keyword">val</span> selectDS: <span class="type">Dataset</span>[<span class="type">String</span>] = joinDS.map(_.ename)</span><br><span class="line"></span><br><span class="line">println(selectDF.queryExecution.optimizedPlan.numberedTreeString)</span><br><span class="line">println(<span class="string">"-------------"</span>)</span><br><span class="line">println(selectDS.queryExecution.optimizedPlan.numberedTreeString)</span><br></pre></td></tr></table></figure>

<p>很明显selectDS做出了优化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="type">Project</span> [ename#<span class="number">7</span>]</span><br><span class="line"><span class="number">01</span> +- <span class="type">Join</span> <span class="type">Inner</span>, (deptno#<span class="number">0</span> = deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">02</span>    :- <span class="type">Project</span> [deptno#<span class="number">0</span>]</span><br><span class="line"><span class="number">03</span>    :  +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">0</span>)</span><br><span class="line"><span class="number">04</span>    :     +- <span class="type">Relation</span>[deptno#<span class="number">0</span>,dname#<span class="number">1</span>,level#<span class="number">2</span>] <span class="type">JDBCRelation</span>(tunan.dept) [numPartitions=<span class="number">1</span>]</span><br><span class="line"><span class="number">05</span>    +- <span class="type">Project</span> [ename#<span class="number">7</span>, deptno#<span class="number">13</span>]</span><br><span class="line"><span class="number">06</span>       +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">07</span>          +- <span class="type">HiveTableRelation</span> `<span class="keyword">default</span>`.`emp`, org.apache.hadoop.hive.serde2.<span class="keyword">lazy</span>.<span class="type">LazySimpleSerDe</span>, [empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>, deptno#<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="number">00</span> <span class="type">SerializeFromObject</span> [staticinvoke(<span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">spark</span>.<span class="title">unsafe</span>.<span class="title">types</span>.<span class="title">UTF8String</span>, <span class="title">StringType</span>, <span class="title">fromString</span>, <span class="title">input</span>[0, java.lang.<span class="type">String</span>, true], <span class="title">true</span>, <span class="title">false</span>) <span class="title">AS</span> <span class="title">value#47</span>]</span></span><br><span class="line"><span class="class">01 <span class="title">+-</span> <span class="title">MapElements</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$$$Lambda$1097/374205056@10f8e2d2</span>, <span class="title">class</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$EmpDept</span>, [<span class="type">StructField</span>(deptno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(dname,<span class="type">StringType</span>,true), <span class="type">StructField</span>(level,<span class="type">StringType</span>,true), <span class="type">StructField</span>(empno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(ename,<span class="type">StringType</span>,true), <span class="type">StructField</span>(job,<span class="type">StringType</span>,true), <span class="type">StructField</span>(jno,<span class="type">StringType</span>,true), <span class="type">StructField</span>(date,<span class="type">StringType</span>,true), <span class="type">StructField</span>(sal,<span class="type">DoubleType</span>,false), <span class="type">StructField</span>(prize,<span class="type">StringType</span>,true)], <span class="title">obj#46</span></span>: java.lang.<span class="type">String</span></span><br><span class="line"><span class="number">02</span>    +- <span class="type">DeserializeToObject</span> newInstance(<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tunan</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">join</span>.<span class="title">JdbcJoinHive$EmpDept</span>), <span class="title">obj#45</span></span>: com.tunan.spark.sql.join.<span class="type">JdbcJoinHive</span>$<span class="type">EmpDept</span></span><br><span class="line"><span class="number">03</span>       +- <span class="type">Project</span> [deptno#<span class="number">0</span>, dname#<span class="number">1</span>, level#<span class="number">2</span>, empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>]</span><br><span class="line"><span class="number">04</span>          +- <span class="type">Join</span> <span class="type">Inner</span>, (deptno#<span class="number">0</span> = deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">05</span>             :- <span class="type">Filter</span> isnotnull(deptno#<span class="number">0</span>)</span><br><span class="line"><span class="number">06</span>             :  +- <span class="type">Relation</span>[deptno#<span class="number">0</span>,dname#<span class="number">1</span>,level#<span class="number">2</span>] <span class="type">JDBCRelation</span>(tunan.dept) [numPartitions=<span class="number">1</span>]</span><br><span class="line"><span class="number">07</span>             +- <span class="type">Filter</span> isnotnull(deptno#<span class="number">13</span>)</span><br><span class="line"><span class="number">08</span>                +- <span class="type">HiveTableRelation</span> `<span class="keyword">default</span>`.`emp`, org.apache.hadoop.hive.serde2.<span class="keyword">lazy</span>.<span class="type">LazySimpleSerDe</span>, [empno#<span class="number">6</span>, ename#<span class="number">7</span>, job#<span class="number">8</span>, jno#<span class="number">9</span>, date#<span class="number">10</span>, sal#<span class="number">11</span>, prize#<span class="number">12</span>, deptno#<span class="number">13</span>]</span><br></pre></td></tr></table></figure>

<p>由此我们可以根据在Spark SQL应用中，选择列的时候，SQL、DF、DS三者做一个比较</p>
<table>
<thead>
<tr>
<th></th>
<th>SQL</th>
<th>DF</th>
<th>DS</th>
</tr>
</thead>
<tbody><tr>
<td>Syntax Errors</td>
<td>runtime</td>
<td>compile</td>
<td>compile</td>
</tr>
<tr>
<td>Analysis Errors</td>
<td>runtime</td>
<td>runtime</td>
<td>compile</td>
</tr>
</tbody></table>
<p>在执行SQL的时候，无论是语法错误还是运行错误，都无法在编译时就提前暴露出来</p>
<p>在执行DF的时候，算子如果写错了，会提前暴露出来，但是写的列名只有在运行的时候才会检查是否正确</p>
<p>在执行DS的时候，由于case class反射的机制，算子和列名都可以提前到代码编写时就检测到错误</p>
<p><strong>所以最优的执行顺序为 DS &gt; DF &gt; SQL</strong></p>
<h3 id="面试题：RDD、DS、DF的区别"><a href="#面试题：RDD、DS、DF的区别" class="headerlink" title="面试题：RDD、DS、DF的区别"></a>面试题：RDD、DS、DF的区别</h3><ol>
<li>RDD不支持SQL</li>
<li>DF每一行都是Row类型，不能直接访问字段，必须解析才行</li>
<li>DS每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获 得每一行的信息</li>
<li>DataFrame与Dataset均支持spark sql的操作，比如select，group by之类，还 能注册临时表/视窗，进行sql语句操作</li>
<li>可以看出，Dataset在需要访问列中的某个字段时是非常方便的，然而，如果要 写一些适配性很强的函数时，如果使用Dataset，行的类型又不确定，可能是各种case class，无法实现适配，这时候用DataFrame即Dataset[Row]就能比较好的解决问题。</li>
</ol>
<h3 id="面试题：RDD和Dataset-DataFrame中的Persist的默认缓存级别"><a href="#面试题：RDD和Dataset-DataFrame中的Persist的默认缓存级别" class="headerlink" title="面试题：RDD和Dataset/DataFrame中的Persist的默认缓存级别"></a>面试题：RDD和Dataset/DataFrame中的Persist的默认缓存级别</h3><ul>
<li>Dataset 中的缓存级别是 MEMORY_AND_DISK</li>
<li>RDD 中的缓存级别是 MEMORY_ONLY</li>
</ul>
<h3 id="面试题：Spark-RDD和Spark-SQL的的cache有什么区别"><a href="#面试题：Spark-RDD和Spark-SQL的的cache有什么区别" class="headerlink" title="面试题：Spark RDD和Spark SQL的的cache有什么区别"></a>面试题：Spark RDD和Spark SQL的的cache有什么区别</h3><ul>
<li><p>Spark RDD的cache是lazy的，需要action才会执行cache操作</p>
</li>
<li><p>Spark SQL的cache是egaer的，马上就cache了</p>
</li>
</ul>
<h2 id="Spark元数据管理-catalog"><a href="#Spark元数据管理-catalog" class="headerlink" title="Spark元数据管理: catalog"></a>Spark元数据管理: catalog</h2><p>拿到catalog</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().master(<span class="string">"local[2]"</span>).appName(<span class="keyword">this</span>.getClass.getSimpleName).enableHiveSupport().getOrCreate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> catalog: <span class="type">Catalog</span> = spark.catalog</span><br></pre></td></tr></table></figure>

<ol>
<li><p>展示所有数据库</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dbList: <span class="type">Dataset</span>[<span class="type">Database</span>] = catalog.listDatabases()</span><br><span class="line">dbList.show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前数据库</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.currentDatabase</span><br></pre></td></tr></table></figure>
</li>
<li><p>只展示名字</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line">dbList.map(_.name).show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>展示指定库的所有表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.setCurrentDatabase(<span class="string">"offline_dw"</span>)</span><br><span class="line">catalog.listTables().show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤表</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listTable = catalog.listTables()</span><br><span class="line">listTable.filter(<span class="symbol">'name</span> === <span class="string">"dws_country_traffic"</span>).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断某个表是否缓存</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.isCached(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.cacheTable(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.isCached(<span class="string">"dws_country_traffic"</span>)</span><br><span class="line">catalog.uncacheTable(<span class="string">"dws_country_traffic"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：catalog的cacheTable是lazy的</strong></p>
</li>
<li><p>展示所有函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">catalog.listFunctions().show(<span class="number">1000</span>，<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册函数，再次展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">spark.udf.register(<span class="string">"udf_string_length"</span>,(word:<span class="type">String</span>) =&gt; &#123;</span><br><span class="line">    word.split(<span class="string">","</span>).length</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">catalog.listFunctions().filter(<span class="symbol">'name</span> === <span class="string">"udf_string_length"</span>).show(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>





</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/14/">SparkCore之开发调优</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>调优概述</li>
<li>原则一：避免创建重复的RDD</li>
<li>原则二：尽可能复用同一个RDD</li>
<li>原则三：对多次使用的RDD进行持久化</li>
<li>原则四：尽量避免使用shuffle类算子</li>
<li>原则五：使用map-side预聚合的shuffle操作</li>
<li>原则六：使用高性能的算子</li>
<li>原则七：广播大变量</li>
<li>原则八：使用Kryo优化序列化性能</li>
<li>原则九：优化数据结构</li>
<li>原则十：Data Locality本地化级别</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在大数据计算领域，Spark已经成为了越来越流行、越来越受欢迎的计算平台之一。Spark的功能涵盖了大数据领域的离线批处理、SQL类处理、流式/实时计算、机器学习、图计算等各种不同类型的计算操作，应用范围与前景非常广泛。在美团•大众点评，已经有很多同学在各种项目中尝试使用Spark。大多数同学（包括笔者在内），最初开始尝试使用Spark的原因很简单，主要就是为了让大数据计算作业的执行速度更快、性能更高。</p>
<p>然而，通过Spark开发出高性能的大数据计算作业，并不是那么简单的。如果没有对Spark作业进行合理的调优，Spark作业的执行速度可能会很慢，这样就完全体现不出Spark作为一种快速大数据计算引擎的优势来。因此，想要用好Spark，就必须对其进行合理的性能优化。</p>
<p>Spark的性能调优实际上是由很多部分组成的，不是调节几个参数就可以立竿见影提升作业性能的。我们需要根据不同的业务场景以及数据情况，对Spark作业进行综合性的分析，然后进行多个方面的调节和优化，才能获得最佳性能。</p>
<p>笔者根据之前的Spark作业开发经验以及实践积累，总结出了一套Spark作业的性能优化方案。整套方案主要分为开发调优、资源调优、数据倾斜调优、shuffle调优几个部分。开发调优和资源调优是所有Spark作业都需要注意和遵循的一些基本原则，是高性能Spark作业的基础；数据倾斜调优，主要讲解了一套完整的用来解决Spark作业数据倾斜的解决方案；shuffle调优，面向的是对Spark的原理有较深层次掌握和研究的同学，主要讲解了如何对Spark作业的shuffle运行过程以及细节进行调优。</p>
<p>本文作为Spark性能优化指南的基础篇，主要讲解开发调优以及资源调优。</p>
<h2 id="调优概述"><a href="#调优概述" class="headerlink" title="调优概述"></a>调优概述</h2><p>Spark性能优化的第一步，就是要在开发Spark作业的过程中注意和应用一些性能优化的基本原则。开发调优，就是要让大家了解以下一些Spark基本开发原则，包括：RDD lineage设计、算子的合理使用、特殊操作的优化等。在开发过程中，时时刻刻都应该注意以上原则，并将这些原则根据具体的业务以及实际的应用场景，灵活地运用到自己的Spark作业中。</p>
<h2 id="原则一：避免创建重复的RDD"><a href="#原则一：避免创建重复的RDD" class="headerlink" title="原则一：避免创建重复的RDD"></a>原则一：避免创建重复的RDD</h2><p>通常来说，我们在开发一个Spark作业时，首先是基于某个数据源（比如Hive表或HDFS文件）创建一个初始的RDD；接着对这个RDD执行某个算子操作，然后得到下一个RDD；以此类推，循环往复，直到计算出最终我们需要的结果。在这个过程中，多个RDD会通过不同的算子操作（比如map、reduce等）串起来，这个“RDD串”，就是RDD lineage，也就是“RDD的血缘关系链”。</p>
<p>我们在开发过程中要注意：对于同一份数据，只应该创建一个RDD，不能创建多个RDD来代表同一份数据。</p>
<p>一些Spark初学者在刚开始开发Spark作业时，或者是有经验的工程师在开发RDD lineage极其冗长的Spark作业时，可能会忘了自己之前对于某一份数据已经创建过一个RDD了，从而导致对于同一份数据，创建了多个RDD。这就意味着，我们的Spark作业会进行多次重复计算来创建多个代表相同数据的RDD，进而增加了作业的性能开销。</p>
<p>一个简单的例子</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要对名为“hello.txt”的HDFS文件进行一次map操作，再进行一次reduce操作。也就是说，需要对一份数据执行两次算子操作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的做法：对于同一份数据执行多次算子操作时，创建多个RDD。</span></span><br><span class="line"><span class="comment">// 这里执行了两次textFile方法，针对同一个HDFS文件，创建了两个RDD出来，然后分别对每个RDD都执行了一个算子操作。</span></span><br><span class="line"><span class="comment">// 这种情况下，Spark需要从HDFS上两次加载hello.txt文件的内容，并创建两个单独的RDD；第二次加载HDFS文件以及创建RDD的性能开销，很明显是白白浪费掉的。</span></span><br><span class="line"><span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">"hdfs://192.168.0.1:9000/hello.txt"</span>)</span><br><span class="line">rdd1.map(...)</span><br><span class="line"><span class="keyword">val</span> rdd2 = sc.textFile(<span class="string">"hdfs://192.168.0.1:9000/hello.txt"</span>)</span><br><span class="line">rdd2.reduce(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的用法：对于一份数据执行多次算子操作时，只使用一个RDD。</span></span><br><span class="line"><span class="comment">// 这种写法很明显比上一种写法要好多了，因为我们对于同一份数据只创建了一个RDD，然后对这一个RDD执行了多次算子操作。</span></span><br><span class="line"><span class="comment">// 但是要注意到这里为止优化还没有结束，由于rdd1被执行了两次算子操作，第二次执行reduce操作的时候，还会再次从源头处重新计算一次rdd1的数据，因此还是会有重复计算的性能开销。</span></span><br><span class="line"><span class="comment">// 要彻底解决这个问题，必须结合“原则三：对多次使用的RDD进行持久化”，才能保证一个RDD被多次使用时只被计算一次。</span></span><br><span class="line"><span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">"hdfs://192.168.0.1:9000/hello.txt"</span>)</span><br><span class="line">rdd1.map(...)</span><br><span class="line">rdd1.reduce(...)</span><br></pre></td></tr></table></figure>

<h2 id="原则二：尽可能复用同一个RDD"><a href="#原则二：尽可能复用同一个RDD" class="headerlink" title="原则二：尽可能复用同一个RDD"></a>原则二：尽可能复用同一个RDD</h2><p>除了要避免在开发过程中对一份完全相同的数据创建多个RDD之外，在对不同的数据执行算子操作时还要尽可能地复用一个RDD。比如说，有一个RDD的数据格式是key-value类型的，另一个是单value类型的，这两个RDD的value数据是完全一样的。那么此时我们可以只使用key-value类型的那个RDD，因为其中已经包含了另一个的数据。对于类似这种多个RDD的数据有重叠或者包含的情况，我们应该尽量复用一个RDD，这样可以尽可能地减少RDD的数量，从而尽可能减少算子执行的次数。</p>
<p>一个简单的例子</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的做法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个&lt;Long, String&gt;格式的RDD，即rdd1。</span></span><br><span class="line"><span class="comment">// 接着由于业务需要，对rdd1执行了一个map操作，创建了一个rdd2，而rdd2中的数据仅仅是rdd1中的value值而已，也就是说，rdd2是rdd1的子集。</span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; rdd1 = ...</span><br><span class="line"><span class="type">JavaRDD</span>&lt;<span class="type">String</span>&gt; rdd2 = rdd1.map(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别对rdd1和rdd2执行了不同的算子操作。</span></span><br><span class="line">rdd1.reduceByKey(...)</span><br><span class="line">rdd2.map(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这个case中，其实rdd1和rdd2的区别无非就是数据格式不同而已，rdd2的数据完全就是rdd1的子集而已，却创建了两个rdd，并对两个rdd都执行了一次算子操作。</span></span><br><span class="line"><span class="comment">// 此时会因为对rdd1执行map算子来创建rdd2，而多执行一次算子操作，进而增加性能开销。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实在这种情况下完全可以复用同一个RDD。</span></span><br><span class="line"><span class="comment">// 我们可以使用rdd1，既做reduceByKey操作，也做map操作。</span></span><br><span class="line"><span class="comment">// 在进行第二个map操作时，只使用每个数据的tuple._2，也就是rdd1中的value值，即可。</span></span><br><span class="line"><span class="type">JavaPairRDD</span>&lt;<span class="type">Long</span>, <span class="type">String</span>&gt; rdd1 = ...</span><br><span class="line">rdd1.reduceByKey(...)</span><br><span class="line">rdd1.map(tuple._2...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式相较于第一种方式而言，很明显减少了一次rdd2的计算开销。</span></span><br><span class="line"><span class="comment">// 但是到这里为止，优化还没有结束，对rdd1我们还是执行了两次算子操作，rdd1实际上还是会被计算两次。</span></span><br><span class="line"><span class="comment">// 因此还需要配合“原则三：对多次使用的RDD进行持久化”进行使用，才能保证一个RDD被多次使用时只被计算一次。</span></span><br></pre></td></tr></table></figure>

<h2 id="原则三：对多次使用的RDD进行持久化"><a href="#原则三：对多次使用的RDD进行持久化" class="headerlink" title="原则三：对多次使用的RDD进行持久化"></a>原则三：对多次使用的RDD进行持久化</h2><p>当你在Spark代码中多次对一个RDD做了算子操作后，恭喜，你已经实现Spark作业第一步的优化了，也就是尽可能复用RDD。此时就该在这个基础之上，进行第二步优化了，也就是要保证对一个RDD执行多次算子操作时，这个RDD本身仅仅被计算一次。</p>
<p>Spark中对于一个RDD执行多次算子的默认原理是这样的：每次你对一个RDD执行一个算子操作时，都会重新从源头处计算一遍，计算出那个RDD来，然后再对这个RDD执行你的算子操作。这种方式的性能是很差的。</p>
<p>因此对于这种情况，我们的建议是：对多次使用的RDD进行持久化。此时Spark就会根据你的持久化策略，将RDD中的数据保存到内存或者磁盘中。以后每次对这个RDD进行算子操作时，都会直接从内存或磁盘中提取持久化的RDD数据，然后执行算子，而不会从源头处重新计算一遍这个RDD，再执行算子操作。</p>
<p>对多次使用的RDD进行持久化的代码示例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果要对一个RDD进行持久化，只要对这个RDD调用cache()和persist()即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法。</span></span><br><span class="line"><span class="comment">// cache()方法表示：使用非序列化的方式将RDD中的数据全部尝试持久化到内存中。</span></span><br><span class="line"><span class="comment">// 此时再对rdd1执行两次算子操作时，只有在第一次执行map算子时，才会将这个rdd1从源头处计算一次。</span></span><br><span class="line"><span class="comment">// 第二次执行reduce算子时，就会直接从内存中提取数据进行计算，不会重复计算一个rdd。</span></span><br><span class="line"><span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">"hdfs://192.168.0.1:9000/hello.txt"</span>).cache()</span><br><span class="line">rdd1.map(...)</span><br><span class="line">rdd1.reduce(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// persist()方法表示：手动选择持久化级别，并使用指定的方式进行持久化。</span></span><br><span class="line"><span class="comment">// 比如说，StorageLevel.MEMORY_AND_DISK_SER表示，内存充足时优先持久化到内存中，内存不充足时持久化到磁盘文件中。</span></span><br><span class="line"><span class="comment">// 而且其中的_SER后缀表示，使用序列化的方式来保存RDD数据，此时RDD中的每个partition都会序列化成一个大的字节数组，然后再持久化到内存或磁盘中。</span></span><br><span class="line"><span class="comment">// 序列化的方式可以减少持久化的数据对内存/磁盘的占用量，进而避免内存被持久化数据占用过多，从而发生频繁GC。</span></span><br><span class="line"><span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">"hdfs://192.168.0.1:9000/hello.txt"</span>).persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK_SER</span>)</span><br><span class="line">rdd1.map(...)</span><br><span class="line">rdd1.reduce(...)</span><br></pre></td></tr></table></figure>

<p>对于persist()方法而言，我们可以根据不同的业务场景选择不同的持久化级别。</p>
<h3 id="Spark的持久化级别"><a href="#Spark的持久化级别" class="headerlink" title="Spark的持久化级别"></a>Spark的持久化级别</h3><table>
<thead>
<tr>
<th>持久化级别</th>
<th>含义解释</th>
</tr>
</thead>
<tbody><tr>
<td>MEMORY_ONLY</td>
<td>使用未序列化的Java对象格式，将数据保存在内存中。如果内存不够存放所有的数据，则数据可能就不会进行持久化。那么下次对这个RDD执行算子操作时，那些没有被持久化的数据，需要从源头处重新计算一遍。这是默认的持久化策略，使用cache()方法时，实际就是使用的这种持久化策略。</td>
</tr>
<tr>
<td>MEMORY_AND_DISK</td>
<td>使用未序列化的Java对象格式，优先尝试将数据保存在内存中。如果内存不够存放所有的数据，会将数据写入磁盘文件中，下次对这个RDD执行算子时，持久化在磁盘文件中的数据会被读取出来使用。</td>
</tr>
<tr>
<td>MEMORY_ONLY_SER</td>
<td>基本含义同MEMORY_ONLY。唯一的区别是，会将RDD中的数据进行序列化，RDD的每个partition会被序列化成一个字节数组。这种方式更加节省内存，从而可以避免持久化的数据占用过多内存导致频繁GC。</td>
</tr>
<tr>
<td>MEMORY_AND_DISK_SER</td>
<td>基本含义同MEMORY_AND_DISK。唯一的区别是，会将RDD中的数据进行序列化，RDD的每个partition会被序列化成一个字节数组。这种方式更加节省内存，从而可以避免持久化的数据占用过多内存导致频繁GC。</td>
</tr>
<tr>
<td>DISK_ONLY</td>
<td>使用未序列化的Java对象格式，将数据全部写入磁盘文件中。</td>
</tr>
<tr>
<td>MEMORY_ONLY_2, MEMORY_AND_DISK_2, 等等.</td>
<td>对于上述任意一种持久化策略，如果加上后缀_2，代表的是将每个持久化的数据，都复制一份副本，并将副本保存到其他节点上。这种基于副本的持久化机制主要用于进行容错。假如某个节点挂掉，节点的内存或磁盘中的持久化数据丢失了，那么后续对RDD计算时还可以使用该数据在其他节点上的副本。如果没有副本的话，就只能将这些数据从源头处重新计算一遍了。</td>
</tr>
</tbody></table>
<h3 id="如何选择一种最合适的持久化策略"><a href="#如何选择一种最合适的持久化策略" class="headerlink" title="如何选择一种最合适的持久化策略"></a>如何选择一种最合适的持久化策略</h3><ul>
<li>默认情况下，性能最高的当然是MEMORY_ONLY，但前提是你的内存必须足够足够大，可以绰绰有余地存放下整个RDD的所有数据。因为不进行序列化与反序列化操作，就避免了这部分的性能开销；对这个RDD的后续算子操作，都是基于纯内存中的数据的操作，不需要从磁盘文件中读取数据，性能也很高；而且不需要复制一份数据副本，并远程传送到其他节点上。但是这里必须要注意的是，在实际的生产环境中，恐怕能够直接用这种策略的场景还是有限的，如果RDD中数据比较多时（比如几十亿），直接用这种持久化级别，会导致JVM的OOM内存溢出异常。</li>
<li>如果使用MEMORY_ONLY级别时发生了内存溢出，那么建议尝试使用MEMORY_ONLY_SER级别。该级别会将RDD数据序列化后再保存在内存中，此时每个partition仅仅是一个字节数组而已，大大减少了对象数量，并降低了内存占用。这种级别比MEMORY_ONLY多出来的性能开销，主要就是序列化与反序列化的开销。但是后续算子可以基于纯内存进行操作，因此性能总体还是比较高的。此外，可能发生的问题同上，如果RDD中的数据量过多的话，还是可能会导致OOM内存溢出的异常。</li>
<li>如果纯内存的级别都无法使用，那么建议使用MEMORY_AND_DISK_SER策略，而不是MEMORY_AND_DISK策略。因为既然到了这一步，就说明RDD的数据量很大，内存无法完全放下。序列化后的数据比较少，可以节省内存和磁盘的空间开销。同时该策略会优先尽量尝试将数据缓存在内存中，内存缓存不下才会写入磁盘。</li>
<li>通常不建议使用DISK_ONLY和后缀为_2的级别：因为完全基于磁盘文件进行数据的读写，会导致性能急剧降低，有时还不如重新计算一次所有RDD。后缀为_2的级别，必须将所有数据都复制一份副本，并发送到其他节点上，数据复制以及网络传输会导致较大的性能开销，除非是要求作业的高可用性，否则不建议使用。</li>
</ul>
<h2 id="原则四：尽量避免使用shuffle类算子"><a href="#原则四：尽量避免使用shuffle类算子" class="headerlink" title="原则四：尽量避免使用shuffle类算子"></a>原则四：尽量避免使用shuffle类算子</h2><p>如果有可能的话，要尽量避免使用shuffle类算子。因为Spark作业运行过程中，最消耗性能的地方就是shuffle过程。shuffle过程，简单来说，就是将分布在集群中多个节点上的同一个key，拉取到同一个节点上，进行聚合或join等操作。比如reduceByKey、join等算子，都会触发shuffle操作。</p>
<p>shuffle过程中，各个节点上的相同key都会先写入本地磁盘文件中，然后其他节点需要通过网络传输拉取各个节点上的磁盘文件中的相同key。而且相同key都拉取到同一个节点进行聚合操作时，还有可能会因为一个节点上处理的key过多，导致内存不够存放，进而溢写到磁盘文件中。因此在shuffle过程中，可能会发生大量的磁盘文件读写的IO操作，以及数据的网络传输操作。磁盘IO和网络数据传输也是shuffle性能较差的主要原因。</p>
<p>因此在我们的开发过程中，能避免则尽可能避免使用reduceByKey、join、distinct、repartition等会进行shuffle的算子，尽量使用map类的非shuffle算子。这样的话，没有shuffle操作或者仅有较少shuffle操作的Spark作业，可以大大减少性能开销。</p>
<p>Broadcast与map进行join代码示例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统的join操作会导致shuffle操作。</span></span><br><span class="line"><span class="comment">// 因为两个RDD中，相同的key都需要通过网络拉取到一个节点上，由一个task进行join操作。</span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd1.join(rdd2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Broadcast+map的join操作，不会导致shuffle操作。</span></span><br><span class="line"><span class="comment">// 使用Broadcast将一个数据量较小的RDD作为广播变量。</span></span><br><span class="line"><span class="keyword">val</span> rdd2Data = rdd2.collect()</span><br><span class="line"><span class="keyword">val</span> rdd2DataBroadcast = sc.broadcast(rdd2Data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在rdd1.map算子中，可以从rdd2DataBroadcast中，获取rdd2的所有数据。</span></span><br><span class="line"><span class="comment">// 然后进行遍历，如果发现rdd2中某条数据的key与rdd1的当前数据的key是相同的，那么就判定可以进行join。</span></span><br><span class="line"><span class="comment">// 此时就可以根据自己需要的方式，将rdd1当前数据与rdd2中可以连接的数据，拼接在一起（String或Tuple）。</span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd1.map(rdd2DataBroadcast...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，以上操作，建议仅仅在rdd2的数据量比较少（比如几百M，或者一两G）的情况下使用。</span></span><br><span class="line"><span class="comment">// 因为每个Executor的内存中，都会驻留一份rdd2的全量数据。</span></span><br></pre></td></tr></table></figure>

<h2 id="原则五：使用map-side预聚合的shuffle操作"><a href="#原则五：使用map-side预聚合的shuffle操作" class="headerlink" title="原则五：使用map-side预聚合的shuffle操作"></a>原则五：使用map-side预聚合的shuffle操作</h2><p>如果因为业务需要，一定要使用shuffle操作，无法用map类的算子来替代，那么尽量使用可以map-side预聚合的算子。</p>
<p>所谓的map-side预聚合，说的是在每个节点本地对相同的key进行一次聚合操作，类似于MapReduce中的本地combiner。map-side预聚合之后，每个节点本地就只会有一条相同的key，因为多条相同的key都被聚合起来了。其他节点在拉取所有节点上的相同key时，就会大大减少需要拉取的数据数量，从而也就减少了磁盘IO以及网络传输开销。通常来说，在可能的情况下，建议使用reduceByKey或者aggregateByKey算子来替代掉groupByKey算子。因为reduceByKey和aggregateByKey算子都会使用用户自定义的函数对每个节点本地的相同key进行预聚合。而groupByKey算子是不会进行预聚合的，全量的数据会在集群的各个节点之间分发和传输，性能相对来说比较差。</p>
<p>比如如下两幅图，就是典型的例子，分别基于reduceByKey和groupByKey进行单词计数。其中第一张图是groupByKey的原理图，可以看到，没有进行任何本地聚合时，所有数据都会在集群节点之间传输；第二张图是reduceByKey的原理图，可以看到，每个节点本地的相同key数据，都进行了预聚合，然后才传输到其他节点上进行全局聚合。</p>
<p><img src="https://yerias.github.io/spark_img/shuffle1.png" alt="shuffle1"></p>
<p><img src="https://yerias.github.io/spark_img/shuffle2.png" alt="shuffle2"></p>
<h2 id="原则六：使用高性能的算子"><a href="#原则六：使用高性能的算子" class="headerlink" title="原则六：使用高性能的算子"></a>原则六：使用高性能的算子</h2><p>除了shuffle相关的算子有优化原则之外，其他的算子也都有着相应的优化原则。</p>
<h3 id="使用reduceByKey-aggregateByKey替代groupByKey"><a href="#使用reduceByKey-aggregateByKey替代groupByKey" class="headerlink" title="使用reduceByKey/aggregateByKey替代groupByKey"></a>使用reduceByKey/aggregateByKey替代groupByKey</h3><p>详情见“原则五：使用map-side预聚合的shuffle操作”。</p>
<h3 id="使用mapPartitions替代普通map"><a href="#使用mapPartitions替代普通map" class="headerlink" title="使用mapPartitions替代普通map"></a>使用mapPartitions替代普通map</h3><p>mapPartitions类的算子，一次函数调用会处理一个partition所有的数据，而不是一次函数调用处理一条，性能相对来说会高一些。但是有的时候，使用mapPartitions会出现OOM（内存溢出）的问题。因为单次函数调用就要处理掉一个partition所有的数据，如果内存不够，垃圾回收时是无法回收掉太多对象的，很可能出现OOM异常。所以使用这类操作时要慎重！</p>
<h3 id="使用foreachPartitions替代foreach"><a href="#使用foreachPartitions替代foreach" class="headerlink" title="使用foreachPartitions替代foreach"></a>使用foreachPartitions替代foreach</h3><p>原理类似于“使用mapPartitions替代map”，也是一次函数调用处理一个partition的所有数据，而不是一次函数调用处理一条数据。在实践中发现，foreachPartitions类的算子，对性能的提升还是很有帮助的。比如在foreach函数中，将RDD中所有数据写MySQL，那么如果是普通的foreach算子，就会一条数据一条数据地写，每次函数调用可能就会创建一个数据库连接，此时就势必会频繁地创建和销毁数据库连接，性能是非常低下；但是如果用foreachPartitions算子一次性处理一个partition的数据，那么对于每个partition，只要创建一个数据库连接即可，然后执行批量插入操作，此时性能是比较高的。实践中发现，对于1万条左右的数据量写MySQL，性能可以提升30%以上。</p>
<h3 id="使用filter之后进行coalesce操作"><a href="#使用filter之后进行coalesce操作" class="headerlink" title="使用filter之后进行coalesce操作"></a>使用filter之后进行coalesce操作</h3><p>通常对一个RDD执行filter算子过滤掉RDD中较多数据后（比如30%以上的数据），建议使用coalesce算子，手动减少RDD的partition数量，将RDD中的数据压缩到更少的partition中去。因为filter之后，RDD的每个partition中都会有很多数据被过滤掉，此时如果照常进行后续的计算，其实每个task处理的partition中的数据量并不是很多，有一点资源浪费，而且此时处理的task越多，可能速度反而越慢。因此用coalesce减少partition数量，将RDD中的数据压缩到更少的partition之后，只要使用更少的task即可处理完所有的partition。在某些场景下，对于性能的提升会有一定的帮助。</p>
<h3 id="使用repartitionAndSortWithinPartitions替代repartition与sort类操作"><a href="#使用repartitionAndSortWithinPartitions替代repartition与sort类操作" class="headerlink" title="使用repartitionAndSortWithinPartitions替代repartition与sort类操作"></a>使用repartitionAndSortWithinPartitions替代repartition与sort类操作</h3><p>repartitionAndSortWithinPartitions是Spark官网推荐的一个算子，官方建议，如果需要在repartition重分区之后，还要进行排序，建议直接使用repartitionAndSortWithinPartitions算子。因为该算子可以一边进行重分区的shuffle操作，一边进行排序。shuffle与sort两个操作同时进行，比先shuffle再sort来说，性能可能是要高的。</p>
<h2 id="原则七：广播大变量"><a href="#原则七：广播大变量" class="headerlink" title="原则七：广播大变量"></a>原则七：广播大变量</h2><p>有时在开发过程中，会遇到需要在算子函数中使用外部变量的场景（尤其是大变量，比如100M以上的大集合），那么此时就应该使用Spark的广播（Broadcast）功能来提升性能。</p>
<p>在算子函数中使用到外部变量时，默认情况下，Spark会将该变量复制多个副本，通过网络传输到task中，此时每个task都有一个变量副本。如果变量本身比较大的话（比如100M，甚至1G），那么大量的变量副本在网络中传输的性能开销，以及在各个节点的Executor中占用过多内存导致的频繁GC，都会极大地影响性能。</p>
<p>因此对于上述情况，如果使用的外部变量比较大，建议使用Spark的广播功能，对该变量进行广播。广播后的变量，会保证每个Executor的内存中，只驻留一份变量副本，而Executor中的task执行时共享该Executor中的那份变量副本。这样的话，可以大大减少变量副本的数量，从而减少网络传输的性能开销，并减少对Executor内存的占用开销，降低GC的频率。</p>
<p>广播大变量的代码示例</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码在算子函数中，使用了外部的变量。</span></span><br><span class="line"><span class="comment">// 此时没有做任何特殊操作，每个task都会有一份list1的副本。</span></span><br><span class="line"><span class="keyword">val</span> list1 = ...</span><br><span class="line">rdd1.map(list1...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码将list1封装成了Broadcast类型的广播变量。</span></span><br><span class="line"><span class="comment">// 在算子函数中，使用广播变量时，首先会判断当前task所在Executor内存中，是否有变量副本。</span></span><br><span class="line"><span class="comment">// 如果有则直接使用；如果没有则从Driver或者其他Executor节点上远程拉取一份放到本地Executor内存中。</span></span><br><span class="line"><span class="comment">// 每个Executor内存中，就只会驻留一份广播变量副本。</span></span><br><span class="line"><span class="keyword">val</span> list1 = ...</span><br><span class="line"><span class="keyword">val</span> list1Broadcast = sc.broadcast(list1)</span><br><span class="line">rdd1.map(list1Broadcast...)</span><br></pre></td></tr></table></figure>

<h2 id="原则八：使用Kryo优化序列化性能"><a href="#原则八：使用Kryo优化序列化性能" class="headerlink" title="原则八：使用Kryo优化序列化性能"></a>原则八：使用Kryo优化序列化性能</h2><p>在Spark中，主要有三个地方涉及到了序列化：</p>
<ul>
<li>在算子函数中使用到外部变量时，该变量会被序列化后进行网络传输（见“原则七：广播大变量”中的讲解）。</li>
<li>将自定义的类型作为RDD的泛型类型时（比如JavaRDD，Student是自定义类型），所有自定义类型对象，都会进行序列化。因此这种情况下，也要求自定义的类必须实现Serializable接口。</li>
<li>使用可序列化的持久化策略时（比如MEMORY_ONLY_SER），Spark会将RDD中的每个partition都序列化成一个大的字节数组。</li>
</ul>
<p>对于这三种出现序列化的地方，我们都可以通过使用Kryo序列化类库，来优化序列化和反序列化的性能。Spark默认使用的是Java的序列化机制，也就是ObjectOutputStream/ObjectInputStream API来进行序列化和反序列化。但是Spark同时支持使用Kryo序列化库，Kryo序列化类库的性能比Java序列化类库的性能要高很多。官方介绍，Kryo序列化机制比Java序列化机制，性能高10倍左右。Spark之所以默认没有使用Kryo作为序列化类库，是因为Kryo要求最好要注册所有需要进行序列化的自定义类型，因此对于开发者来说，这种方式比较麻烦。</p>
<p>以下是使用Kryo的代码示例，我们只要设置序列化类，再注册要序列化的自定义类型即可（比如算子函数中使用到的外部变量类型、作为RDD泛型类型的自定义类型等）：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建SparkConf对象。</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(...).setAppName(...)</span><br><span class="line"><span class="comment">// 设置序列化器为KryoSerializer。</span></span><br><span class="line">conf.set(<span class="string">"spark.serializer"</span>, <span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line"><span class="comment">// 注册要序列化的自定义类型。</span></span><br><span class="line">conf.registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">MyClass1</span>], classOf[<span class="type">MyClass2</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="原则九：优化数据结构"><a href="#原则九：优化数据结构" class="headerlink" title="原则九：优化数据结构"></a>原则九：优化数据结构</h2><p>Java中，有三种类型比较耗费内存：</p>
<ul>
<li>对象，每个Java对象都有对象头、引用等额外的信息，因此比较占用内存空间。</li>
<li>字符串，每个字符串内部都有一个字符数组以及长度等额外信息。</li>
<li>集合类型，比如HashMap、LinkedList等，因为集合类型内部通常会使用一些内部类来封装集合元素，比如Map.Entry。</li>
</ul>
<p>因此Spark官方建议，在Spark编码实现中，特别是对于算子函数中的代码，尽量不要使用上述三种数据结构，尽量使用字符串替代对象，使用原始类型（比如Int、Long）替代字符串，使用数组替代集合类型，这样尽可能地减少内存占用，从而降低GC频率，提升性能。</p>
<p>但是在笔者的编码实践中发现，要做到该原则其实并不容易。因为我们同时要考虑到代码的可维护性，如果一个代码中，完全没有任何对象抽象，全部是字符串拼接的方式，那么对于后续的代码维护和修改，无疑是一场巨大的灾难。同理，如果所有操作都基于数组实现，而不使用HashMap、LinkedList等集合类型，那么对于我们的编码难度以及代码可维护性，也是一个极大的挑战。因此笔者建议，在可能以及合适的情况下，使用占用内存较少的数据结构，但是前提是要保证代码的可维护性。</p>
<h2 id="原则十：Data-Locality本地化级别"><a href="#原则十：Data-Locality本地化级别" class="headerlink" title="原则十：Data Locality本地化级别"></a>原则十：Data Locality本地化级别</h2><p><strong>PROCESS_LOCAL</strong>：进程本地化，代码和数据在同一个进程中，也就是在同一个executor中；计算数据的task由executor执行，数据在executor的BlockManager中；性能最好</p>
<p><strong>NODE_LOCAL</strong>：节点本地化，代码和数据在同一个节点中；比如说，数据作为一个HDFS block块，就在节点上，而task在节点上某个executor中运行；或者是，数据和task在一个节点上的不同executor中；数据需要在进程间进行传输<br><strong>NO_PREF</strong>：对于task来说，数据从哪里获取都一样，没有好坏之分<br><strong>RACK_LOCAL</strong>：机架本地化，数据和task在一个机架的两个节点上；数据需要通过网络在节点之间进行传输<br><strong>ANY</strong>：数据和task可能在集群中的任何地方，而且不在一个机架中，性能最差</p>
<p>spark.locality.wait，默认是3s</p>
<p>Spark在Driver上，对Application的每一个stage的task，进行分配之前，都会计算出每个task要计算的是哪个分片数据，RDD的某个partition；Spark的task分配算法，优先，会希望每个task正好分配到它要计算的数据所在的节点，这样的话，就不用在网络间传输数据；</p>
<p>但是可能task没有机会分配到它的数据所在的节点，因为可能那个节点的计算资源和计算能力都满了；所以呢，这种时候，通常来说，Spark会等待一段时间，默认情况下是3s钟（不是绝对的，还有很多种情况，对不同的本地化级别，都会去等待），到最后，实在是等待不了了，就会选择一个比较差的本地化级别，比如说，将task分配到靠它要计算的数据所在节点，比较近的一个节点，然后进行计算。</p>
<p>但是对于第二种情况，通常来说，肯定是要发生数据传输，task会通过其所在节点的BlockManager来获取数据，BlockManager发现自己本地没有数据，会通过一个getRemote()方法，通过TransferService（网络数据传输组件）从数据所在节点的BlockManager中，获取数据，通过网络传输回task所在节点。</p>
<p>对于我们来说，当然不希望是类似于第二种情况的了。最好的，当然是task和数据在一个节点上，直接从本地executor的BlockManager中获取数据，纯内存，或者带一点磁盘IO；如果要通过网络传输数据的话，那么实在是，性能肯定会下降的，大量网络传输，以及磁盘IO，都是性能的杀手。</p>
<p><strong>什么时候要调节这个参数？</strong><br>观察日志，spark作业的运行日志，推荐大家在测试的时候，先用client模式，在本地就直接可以看到比较全的日志。<br>日志里面会显示，starting task。。。，PROCESS LOCAL、NODE LOCAL，观察大部分task的数据本地化级别。</p>
<p>如果大多都是PROCESS_LOCAL，那就不用调节了<br>如果是发现，好多的级别都是NODE_LOCAL、ANY，那么最好就去调节一下数据本地化的等待时长<br>调节完，应该是要反复调节，每次调节完以后，再来运行，观察日志<br>看看大部分的task的本地化级别有没有提升；看看，整个spark作业的运行时间有没有缩短</p>
<p>但是注意别本末倒置，本地化级别倒是提升了，但是因为大量的等待时长，spark作业的运行时间反而增加了，那就还是不要调节了。</p>
<p>spark.locality.wait，默认是3s；可以改成6s，10s</p>
<p>默认情况下，下面3个的等待时长，都是跟上面那个是一样的，都是3s</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">spark.locality.wait.process<span class="comment">//建议60s</span></span><br><span class="line">spark.locality.wait.node<span class="comment">//建议30s</span></span><br><span class="line">spark.locality.wait.rack<span class="comment">//建议20s</span></span><br></pre></td></tr></table></figure>

<hr>
<p>转载自: <a href="https://tech.meituan.com/spark-tuning-basic.html" target="_blank" rel="noopener">https://tech.meituan.com/spark-tuning-basic.html</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/13/">Spark源码之解读spark-shell脚本</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>该篇文章主要分析一下Spark源码中启动spark-shell脚本的处理逻辑，从spark-shell一步步深入进去看看任务提交的整体流程</p>
<ol>
<li><p>spark-shell脚本解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化cygwin=<span class="literal">false</span></span></span><br><span class="line">cygwin=false</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查你的系统是否属于cygwin</span></span><br><span class="line">case "$(uname)" in</span><br><span class="line">  CYGWIN*) cygwin=true;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置shell的模式为POSIX标准模式</span></span><br><span class="line">set -o posix</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测是否设置过SPARK_HOME环境变量</span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">export _SPARK_CMD_USAGE="Usage: ./bin/spark-shell [options]</span><br><span class="line">Scala REPL options:</span><br><span class="line">  -I &lt;file&gt;                   preload &lt;file&gt;, enforcing line-by-line interpretation"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">scala默认不会使用java classpath，需要手动设置一下让scala使用java</span></span><br><span class="line">SPARK_SUBMIT_OPTS="$SPARK_SUBMIT_OPTS -Dscala.usejavacp=true"</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 判断是否是cygwin</span></span><br><span class="line">  if $cygwin; then</span><br><span class="line">    # 关闭echo回显，设置读操作最少1个字符</span><br><span class="line">    stty -icanon min 1 -echo &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">    export SPARK_SUBMIT_OPTS="$SPARK_SUBMIT_OPTS -Djline.terminal=unix"</span><br><span class="line">    # 启动spark-submit 执行org.apache.spark.repl.Main类，并设置应用的名字，传递参数</span><br><span class="line">    "$&#123;SPARK_HOME&#125;"/bin/spark-submit --class org.apache.spark.repl.Main --name "Spark shell" "$@"</span><br><span class="line">    # 开启echo回显</span><br><span class="line">    stty icanon echo &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">  else</span><br><span class="line">    export SPARK_SUBMIT_OPTS</span><br><span class="line">    # 启动spark-submit 执行org.apache.spark.repl.Main类，并设置应用的名字，传递参数</span><br><span class="line">    "$&#123;SPARK_HOME&#125;"/bin/spark-submit --class org.apache.spark.repl.Main --name "Spark shell" "$@"</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit_status=127</span><br><span class="line">saved_stty=""</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> restore stty settings (<span class="built_in">echo</span> <span class="keyword">in</span> particular)</span></span><br><span class="line">function restoreSttySettings() &#123;</span><br><span class="line">  stty $saved_stty</span><br><span class="line">  saved_stty=""</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断是否恢复终端设置</span></span><br><span class="line">function onExit() &#123;</span><br><span class="line">  if [[ "$saved_stty" != "" ]]; then</span><br><span class="line">    restoreSttySettings</span><br><span class="line">  fi</span><br><span class="line">  exit $exit_status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 捕获INT中断信号，然就执行onExit方法</span></span><br><span class="line">trap onExit INT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存了当前的终端配置</span></span><br><span class="line">saved_stty=$(stty -g 2&gt;/dev/null)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果收到退出命令，就恢复stty状态</span></span><br><span class="line">if [[ ! $? ]]; then</span><br><span class="line">  saved_stty=""</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用main方法，并传递所有的参数</span></span><br><span class="line">main "$@"</span><br><span class="line"></span><br><span class="line">exit_status=$?</span><br><span class="line">onExit</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面启动了spark-submit，接下来我们解读该脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查是否设置了<span class="variable">$&#123;SPARK_HOME&#125;</span></span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在Python 3.3+中禁用字符串的随机哈希</span></span><br><span class="line">export PYTHONHASHSEED=0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动spark-class，并传递了org.apache.spark.deploy.SparkSubmit作为第一个参数，然后把前面Spark-shell的参数都传给spark-class</span></span><br><span class="line">exec "$&#123;SPARK_HOME&#125;"/bin/spark-class org.apache.spark.deploy.SparkSubmit "$@"</span><br></pre></td></tr></table></figure>
</li>
<li><p>在spark-submit中又启动了spark-class，继续解读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查/设置SPARK_HOME</span></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置一些环境变量</span></span><br><span class="line">. "$&#123;SPARK_HOME&#125;"/bin/load-spark-env.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到bin/java,并赋值给RUNNER变量</span></span><br><span class="line">if [ -n "$&#123;JAVA_HOME&#125;" ]; then</span><br><span class="line">  RUNNER="$&#123;JAVA_HOME&#125;/bin/java"</span><br><span class="line">else</span><br><span class="line">  if [ "$(command -v java)" ]; then</span><br><span class="line">    RUNNER="java"</span><br><span class="line">  else</span><br><span class="line">    echo "JAVA_HOME is not set" &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">  fi  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到Spark的Jar包</span></span><br><span class="line">if [ -d "$&#123;SPARK_HOME&#125;/jars" ]; then</span><br><span class="line">  SPARK_JARS_DIR="$&#123;SPARK_HOME&#125;/jars"</span><br><span class="line">else</span><br><span class="line">  SPARK_JARS_DIR="$&#123;SPARK_HOME&#125;/assembly/target/scala-$SPARK_SCALA_VERSION/jars"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -d "$SPARK_JARS_DIR" ] &amp;&amp; [ -z "$SPARK_TESTING$SPARK_SQL_TESTING" ]; then</span><br><span class="line">  echo "Failed to find Spark jars directory ($SPARK_JARS_DIR)." 1&gt;&amp;2</span><br><span class="line">  echo "You need to build Spark with the target \"package\" before running this program." 1&gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">else</span><br><span class="line">  LAUNCH_CLASSPATH="$SPARK_JARS_DIR/*"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要，将启动程序构建目录添加到类路径。</span></span><br><span class="line">if [ -n "$SPARK_PREPEND_CLASSES" ]; then</span><br><span class="line">  LAUNCH_CLASSPATH="$&#123;SPARK_HOME&#125;/launcher/target/scala-$SPARK_SCALA_VERSION/classes:$LAUNCH_CLASSPATH"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">if [[ -n "$SPARK_TESTING" ]]; then</span><br><span class="line">  unset YARN_CONF_DIR</span><br><span class="line">  unset HADOOP_CONF_DIR</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 封装了真正的执行的spark的类</span></span><br><span class="line">build_command() &#123;</span><br><span class="line">  "$RUNNER" -Xmx128m -cp "$LAUNCH_CLASSPATH" org.apache.spark.launcher.Main "$@"</span><br><span class="line">  printf "%d\0" $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭posix模式，因为它不允许进程替换</span></span><br><span class="line">set +o posix</span><br><span class="line"></span><br><span class="line">CMD=()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先循环读取ARG参数，加入到CMD中</span></span><br><span class="line">while IFS= read -d '' -r ARG; do</span><br><span class="line">  CMD+=("$ARG")</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行Spark的类</span></span><br><span class="line">done &lt; &lt;(build_command "$@")</span><br><span class="line">COUNT=$&#123;#CMD[@]&#125;</span><br><span class="line">LAST=$((COUNT - 1))</span><br><span class="line">LAUNCHER_EXIT_CODE=$&#123;CMD[$LAST]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if ! [[ $LAUNCHER_EXIT_CODE =~ ^[0-9]+$ ]]; then</span><br><span class="line">  echo "$&#123;CMD[@]&#125;" | head -n-1 1&gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $LAUNCHER_EXIT_CODE != 0 ]; then</span><br><span class="line">  exit $LAUNCHER_EXIT_CODE</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">CMD=("$&#123;CMD[@]:0:$LAST&#125;")</span><br><span class="line">exec "$&#123;CMD[@]&#125;"</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到虽然是执行了spark-shell，但是最终执行的是<code>org.apache.spark.launcher.Main</code>类，也就是说spark-shell的最底层是使用java来启动的</p>
<p>他们的执行流程大致如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">spark-shell&#123;</span><br><span class="line">	spark-submit&#123;</span><br><span class="line">		spark-class&#123;</span><br><span class="line">			   build_command() &#123;</span><br><span class="line">			   	"$RUNNER" -Xmx128m -cp "$LAUNCH_CLASSPATH" org.apache.spark.launcher.Main "$@"</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/azkaban/2/">Azkaban配置Plugin实现Spark作业提交(非Shell)</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Azkaban/">Azkaban</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Azkaban/">Azkaban</a></span><div class="content"><p>第一步，我们要打开azkaban的<a href="https://github.com/azkaban/azkaban/tree/master/az-hadoop-jobtype-plugin/src/jobtypes" target="_blank" rel="noopener">官网</a>，配置一些文件和参数，如图所示</p>
<p><img src="https://yerias.github.io/azkaban_img/az%E9%85%8D%E7%BD%AESpark%E6%8F%90%E4%BA%A4.jpg" alt="az配置Spark提交"></p>
<p>将<code>spark</code>、<code>common.properties</code>、<code>commonprivate.properties</code>拷贝到服务器中对应的目录，最终的文件展示如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span> jobtypes]$ tree</span><br><span class="line">.</span><br><span class="line">├── commonprivate.properties</span><br><span class="line">├── common.properties</span><br><span class="line">└── spark</span><br><span class="line">    ├── plugin.properties</span><br><span class="line">    └── <span class="keyword">private</span>.properties</span><br></pre></td></tr></table></figure>

<ol>
<li><p>配置commonprivate.properties中hadoop.home和spark.home指定的家目录</p>
</li>
<li><p>配置common.properties中hadoop.home和spark.home指定的家目录</p>
</li>
<li><p>修改private.properties文件中的参数(临时方案，可行)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">jobtype.classpath=$&#123;hadoop.classpath&#125;:$&#123;spark.home&#125;/conf:$&#123;spark.home&#125;/lib<span class="comment">/*</span></span><br><span class="line"><span class="comment">===&gt;</span></span><br><span class="line"><span class="comment">jobtype.classpath=hadoop.classpath:$&#123;spark.home&#125;/conf:$&#123;spark.home&#125;/lib/*</span></span><br></pre></td></tr></table></figure>

<p>这么做的原因是我们以上的文件中没有配置hadoop.classpath，官方也没有说明hadoop.classpath应该配置什么参数，目前修改掉引用不影响程序的使用。</p>
</li>
</ol>
<p>第二步，在conf/azkaban.properties文件下增加一个配置，主机名:端口号(随意修改)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">azkaban.webserver.url=https:<span class="comment">//hadoop:8666</span></span><br></pre></td></tr></table></figure>

<p>第三步，提交作业，所配的参数需要参考<a href="https://github.com/azkaban/azkaban/blob/master/az-hadoop-jobtype-plugin/src/main/java/azkaban/jobtype/SparkJobArg.java" target="_blank" rel="noopener">官网</a></p>
<p>测试案例:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">    user.to.proxy: hadoop</span><br><span class="line">nodes:</span><br><span class="line">  - name: sparkwc</span><br><span class="line">    <span class="class"><span class="keyword">type</span></span>: spark</span><br><span class="line">    config:</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>: com.data.spark.wc.<span class="type">SparkWC</span></span><br><span class="line">      master: yarn</span><br><span class="line">      deploy-mode: client</span><br><span class="line">      executor-memory: <span class="number">512</span>M</span><br><span class="line">      driver-memory: <span class="number">512</span>M</span><br><span class="line">      conf.spark.testing.memory: <span class="number">471859200</span></span><br><span class="line">      execution-jar: tunan-spark-utils<span class="number">-1.0</span>.jar</span><br><span class="line">      jars: tunan-spark-core<span class="number">-1.0</span>.jar</span><br><span class="line">      params: hdfs:<span class="comment">//hadoop:9000/input/wc.txt hdfs://hadoop:9000/out</span></span><br></pre></td></tr></table></figure>

<p>注意配置文件中的 jar 没有写路径，这么提交<strong>需要把 jar 包和配置文件一起打成zip包</strong>，提交到AZ的Web界面</p>
<p>第四步，查看结果</p>
<p><em>20200413更新：</em>  数据下标越界问题：hadoop下的/share/hadoop/common/lib/paranamer-2.3.jar过时，使用–jars传spark下的/jars/paranamer-2.8.jar    </p>
<p><em>20200423更新：</em> 所有参数都可以使用conf传递，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution_jar  对应的是appjar</span><br><span class="line">jars 对应的是 依赖jar</span><br><span class="line">params: $&#123;execution_jar&#125; 参数<span class="number">1</span> 参数<span class="number">2</span></span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/12/">Spark中的序列化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>在写Spark应用时，常常会碰到序列化的问题。例如，在Driver端的程序中创建了一个对象，而在各个Executor端会用到这个对象——由于Driver端的代码和Executor端的代码在不同的JVM中，甚至在不同的节点上，因此必然要有相应</p>
<h2 id="Java框架进行序列化"><a href="#Java框架进行序列化" class="headerlink" title="Java框架进行序列化"></a>Java框架进行序列化</h2><p>在默认情况下，Spark会使用Java的ObjectOutputStream框架对对象进行序列化，并且可以与任何实现java.io.Serializable的类一起工作。您还可以通过扩展java.io.Externalizable来更紧密地控制序列化的性能。Java序列化是灵活的，但通常相当慢，并且会导致许多类的大型序列化格式。</p>
<p>测试代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SerializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"SerializationDemo"</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stduentArr = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Student</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">1000000</span>) &#123;</span><br><span class="line">            stduentArr += (<span class="type">Student</span>(i + <span class="string">""</span>, i + <span class="string">"a"</span>, <span class="number">10</span>, <span class="string">"male"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">JavaSerialization</span> = sc.parallelize(stduentArr)</span><br><span class="line">        <span class="type">JavaSerialization</span>.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Web界面查看：33.2M</p>
<h2 id="Kryo框架进行序列化"><a href="#Kryo框架进行序列化" class="headerlink" title="Kryo框架进行序列化"></a>Kryo框架进行序列化</h2><p>Spark还可以使用Kryo库（Spark 2.x）来更快地序列化对象。Kryo比Java（通常多达10倍）要快得多，也更紧凑，但是不支持所有可串行化类型，并且要求您提前注册您将在程序中使用的类，以获得最佳性能。</p>
<ol>
<li><p>不注册使用的类测试</p>
<p>在conf中配置spark.serializer = org.apache.spark.serializer.KryoSerializer来使用kryo序列化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SerializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">        .setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        .setAppName(<span class="string">"SerializationDemo"</span>)</span><br><span class="line">        .set(<span class="string">"spark.serializer"</span>,<span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stduentArr = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Student</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">1000000</span>) &#123;</span><br><span class="line">            stduentArr += (<span class="type">Student</span>(i + <span class="string">""</span>, i + <span class="string">"a"</span>, <span class="number">10</span>, <span class="string">"male"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">JavaSerialization</span> = sc.parallelize(stduentArr)</span><br><span class="line">        <span class="type">JavaSerialization</span>.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Web界面查看：53.2M</p>
<p>这是因为使用Kryo时，不将使用的类注册，往往会得到比java序列化占用更大的内存</p>
</li>
<li><p>注册使用的类测试</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">id: <span class="type">String</span>, name: <span class="type">String</span>, age: <span class="type">Int</span>, gender: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">SerializationDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">        .setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        .setAppName(<span class="string">"SerializationDemo"</span>)</span><br><span class="line">        .set(<span class="string">"spark.serializer"</span>,<span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">        .registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">Student</span>])) <span class="comment">// 将自定义的类注册到Kryo</span></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stduentArr = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Student</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">1000000</span>) &#123;</span><br><span class="line">            stduentArr += (<span class="type">Student</span>(i + <span class="string">""</span>, i + <span class="string">"a"</span>, <span class="number">10</span>, <span class="string">"male"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">JavaSerialization</span> = sc.parallelize(stduentArr)</span><br><span class="line">        <span class="type">JavaSerialization</span>.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span>.sleep(<span class="number">10000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Web界面查看：21.7 M</p>
<p>在conf中注册</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(...).setAppName(...)</span><br><span class="line">conf.registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">MyClass1</span>], classOf[<span class="type">MyClass2</span>]))</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="总结及拓展"><a href="#总结及拓展" class="headerlink" title="总结及拓展"></a>总结及拓展</h2><p>Kryo serialization 性能和序列化大小都比默认提供的 Java serialization 要好，但是<strong>使用Kryo需要将自定义的类先注册进去</strong>，使用起来比 Java serialization麻烦。自从Spark 2.x 以来，我们在使用简单类型、简单类型数组或字符串类型的简单类型来调整RDDs时，在内部使用Kryo序列化器。</p>
<p>通过查找sparkcontext初始化的源码，可以发现某些类型已经在sparkcontext初始化的时候被注册进去。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Component which configures serialization, compression and encryption for various Spark</span></span><br><span class="line"><span class="comment"> * components, including automatic selection of which [[Serializer]] to use for shuffles.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">SerializerManager</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    defaultSerializer: <span class="type">Serializer</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    encryptionKey: <span class="type">Option</span>[<span class="type">Array</span>[<span class="type">Byte</span>]]</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(defaultSerializer: <span class="type">Serializer</span>, conf: <span class="type">SparkConf</span>) = <span class="keyword">this</span>(defaultSerializer, conf, <span class="type">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> kryoSerializer = <span class="keyword">new</span> <span class="type">KryoSerializer</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> stringClassTag: <span class="type">ClassTag</span>[<span class="type">String</span>] = implicitly[<span class="type">ClassTag</span>[<span class="type">String</span>]]</span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> primitiveAndPrimitiveArrayClassTags: <span class="type">Set</span>[<span class="type">ClassTag</span>[_]] = &#123;</span><br><span class="line">        <span class="keyword">val</span> primitiveClassTags = <span class="type">Set</span>[<span class="type">ClassTag</span>[_]](</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Boolean</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Byte</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Char</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Double</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Float</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Int</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Long</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Null</span>,</span><br><span class="line">            <span class="type">ClassTag</span>.<span class="type">Short</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> arrayClassTags = primitiveClassTags.map(_.wrap)</span><br><span class="line">        primitiveClassTags ++ arrayClassTags</span><br></pre></td></tr></table></figure>

<p>也就是说，Boolean、Byte、Char、Double、Float、Int、Long、Null、Short这些类型修饰的属性，自动使用kryo序列化。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/10/spark/10/">Spark之分组TopN模块</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><p>在Spark中，分组TopN好写，但是如果想写出性能好的代码却也很难。下面我们将通过写TopN的方式，找出问题，解决问题。</p>
<ol>
<li><p>直接reduceByKey完成分组求和排序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"file:///home/hadoop/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)	<span class="comment">//((domain,url),1)</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = mapRDD.reduceByKey(_ + _).groupBy(x =&gt; x._1._1).mapValues( x=&gt; x.toList.sortBy(x =&gt; -x._2).map(x =&gt; (x._1._1,x._1._2,x._2)).take(<span class="number">2</span>))</span><br><span class="line">    result.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法虽然直接，但是在reduceByKey和groupBy分别进过了shuffle，而且x.toList是一个非常吃内存的操作，如果数据量大，直接OOM</p>
</li>
<li><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> domains = <span class="type">Array</span>(<span class="string">"www.google.com"</span>, <span class="string">"www.ruozedata.com"</span>, <span class="string">"www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (domain &lt;- domains)&#123;</span><br><span class="line">        mapRDD.filter(x =&gt; x._1._1.equals(domain)).reduceByKey(_+_).sortBy(x =&gt; -x._2).take(<span class="number">2</span>).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心思想：把需要分组分类的数据提前拿出来，在filter中过滤，每次执行一个分组，虽然减少了一次shuffle，但是我们不可能每次都把需要的数据都能提前拿到数据</p>
</li>
<li><p>使用ditinct.collect返回的数组替换人为创建的数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> domains = mapRDD.map(x =&gt; x._1._1).distinct().collect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (domain &lt;- domains)&#123;</span><br><span class="line">        mapRDD.filter( x =&gt; domain.equals(x._1._1)).reduceByKey(_+_).sortBy(x =&gt; -x._2).take(<span class="number">2</span>).foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人说distinct性能不好，但是我们这里使用去重的是domain，这个数据量并不是很大，可以勉强接受，现在每次都使用for循环来处理数据，能不能更加优化一下呢</p>
</li>
<li><p>使用分区执行替换for循环</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">    <span class="comment">//连接SparkMaster</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">        ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> domains = mapRDD.map(x =&gt; x._1._1).distinct().collect()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapPartRDD = mapRDD.reduceByKey(<span class="keyword">new</span> <span class="type">MyPartitioner</span>(domains), _ + _).mapPartitions(partition =&gt; &#123;</span><br><span class="line">        partition.toList.sortBy(x =&gt; -x._2).take(<span class="number">2</span>).iterator</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    mapPartRDD.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的分区类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span>(<span class="params">domains:<span class="type">Array</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">Partitioner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map = mutable.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">0</span> until (domains.length))&#123;</span><br><span class="line">        map(domains(i)) = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = domains.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> domain = key.asInstanceOf[(<span class="type">String</span>, <span class="type">String</span>)]._1</span><br><span class="line">        map(domain)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么做的好处是原本一起计算的RDD，现在每个分区里面去计算了，虽然toList内存占用大，但是还凑合，最终的版本就是把toList替换掉。</p>
</li>
<li><p>使用TreeSet替换toList实现最终的排序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-core/data/site.log"</span></span><br><span class="line">        <span class="comment">//连接SparkMaster</span></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="keyword">this</span>.getClass.getSimpleName).setMaster(<span class="string">"local[2]"</span>)</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> fileRDD = sc.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> mapRDD = fileRDD.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">"\t"</span>)</span><br><span class="line">            ((words(<span class="number">0</span>), words(<span class="number">1</span>)), <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> domains = mapRDD.map(x =&gt; x._1._1).distinct().collect()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> ord: <span class="type">Ordering</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = <span class="keyword">new</span> <span class="type">Ordering</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)]() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: ((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>), y: ((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)): <span class="type">Int</span> = &#123;</span><br><span class="line">                <span class="keyword">if</span> (!x._1.equals(y._1) &amp;&amp; x._2 == y._2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  降序排</span></span><br><span class="line">                y._2 - x._2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> treeSort = mapRDD.reduceByKey(<span class="keyword">new</span> <span class="type">MyPartitioner</span>(domains), _ + _).mapPartitions(partition =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> set = mutable.<span class="type">TreeSet</span>.empty(ord)</span><br><span class="line">            partition.foreach(x =&gt; &#123;</span><br><span class="line">                set.add(x)</span><br><span class="line">                <span class="keyword">if</span> (set.size &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    set.remove(set.lastKey) <span class="comment">//移除最后一个</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            set.toIterator</span><br><span class="line">        &#125;).collect()</span><br><span class="line">        treeSort.foreach(println)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用TreeSet实现自定义排序器，使之每次维护的只有需要的极少量数据，这样占用内存少，效率最高。</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/03/spark/11/">SparkSQL&amp;DataFrame的read和write&amp;SparkSQL做统计分析&amp;UDF函数&amp;存储格式的转换</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>SparkSQL</li>
<li>DataFrame的read和write</li>
<li>SparkSQL做统计分析</li>
<li>UDF函数</li>
<li>存储格式的转换</li>
</ol>
<h2 id="SparkSQL"><a href="#SparkSQL" class="headerlink" title="SparkSQL"></a>SparkSQL</h2><h3 id="认识SparkSQL"><a href="#认识SparkSQL" class="headerlink" title="认识SparkSQL"></a>认识SparkSQL</h3><ol>
<li><p>SparkSQL的进化之路</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.0以前：</span><br><span class="line">   Shark</span><br><span class="line">1.1.x开始：</span><br><span class="line">   SparkSQL(只是测试性的) SQL</span><br><span class="line">1.3.x:</span><br><span class="line">   SparkSQL(正式版本)+Dataframe</span><br><span class="line">1.5.x:</span><br><span class="line">SparkSQL 钨丝计划</span><br><span class="line">1.6.x：</span><br><span class="line">   SparkSQL+DataFrame+DataSet(测试版本)</span><br><span class="line">2.x.x:</span><br><span class="line">   SparkSQL+DataFrame+DataSet(正式版本)</span><br><span class="line">   SparkSQL:还有其他的优化</span><br><span class="line">   StructuredStreaming(DataSet)</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是SparkSQL?</p>
<p>spark SQL是spark的一个模块，主要用于进行结构化数据的处理。它提供的最核心的编程抽象就是DataFrame。</p>
</li>
<li><p>SparkSQL的作用</p>
<p>提供一个编程抽象（DataFrame） 并且作为分布式 SQL 查询引擎</p>
<p>DataFrame：它可以根据很多源进行构建，包括：<strong>结构化的数据文件，hive中的表，外部的关系型数据库，以及RDD</strong></p>
</li>
<li><p>运行原理</p>
<p>将 Spark SQL 转化为 RDD， 然后提交到集群执行</p>
</li>
<li><p>特点</p>
<ol>
<li>容易整合</li>
<li>统一的数据访问方式</li>
<li>兼容 Hive</li>
<li>标准的数据连接</li>
</ol>
</li>
<li><p>spark-sql</p>
<p>spark-sql是一个Spark专属的SQL命令行交互工具，在使用spark-sql之前要把hive-site.xml 拷贝到Spark/Conf下，spark-sql和spark-shell用法一样，但是在引入外部依赖的时候，spark-sql需要用–jars和–driver-class-path同时引入依赖才不会报错</p>
</li>
<li><p>持久化</p>
<p>在spark-sql中的持久化Table命令是: cache table xxx，清除持久化 uncache table xxx</p>
<p>spark-SQL中的cache和uncache都是eager的，立即执行的</p>
<p><strong>考点：RDD和SparkSQL的cache有什么区别？</strong></p>
<ul>
<li>RDD中的cache是lazy的 spark-SQL中的cache是eager的</li>
</ul>
</li>
<li><p>遗留问题</p>
<p>–files/–jars    传进去的东西清不掉</p>
</li>
</ol>
<h3 id="SparkSession"><a href="#SparkSession" class="headerlink" title="SparkSession"></a>SparkSession</h3><p>SparkSession是Spark 2.0引如的新概念。SparkSession为用户提供了统一的切入点，来让用户学习spark的各项功能。 </p>
<p>在spark的早期版本中，SparkContext是spark的主要切入点，由于RDD是主要的API，我们通过sparkcontext来创建和操作RDD。对于每个其他的API，我们需要使用不同的context。例如，对于Streming，我们需要使用StreamingContext；对于sql，使用sqlContext；对于Hive，使用hiveContext。但是随着DataSet和DataFrame的API逐渐成为标准的API，就需要为他们建立接入点。所以在spark2.0中，引入SparkSession作为DataSet和DataFrame API的切入点，SparkSession封装了SparkConf、SparkContext和SQLContext。为了向后兼容，SQLContext和HiveContext也被保存下来。 </p>
<p>SparkSession实质上是SQLContext和HiveContext的组合（未来可能还会加上StreamingContext），所以在SQLContext和HiveContext上可用的API在SparkSession上同样是可以使用的。SparkSession内部封装了sparkContext，所以计算实际上是由sparkContext完成的。</p>
<p>特点：</p>
<ol>
<li><p><strong>为用户提供一个统一的切入点使用Spark 各项功能</strong></p>
</li>
<li><p><strong>允许用户通过它调用 DataFrame 和 Dataset 相关 API 来编写程序</strong></p>
</li>
<li><p><strong>减少了用户需要了解的一些概念，可以很容易的与 Spark 进行交互</strong></p>
</li>
<li><p><strong>与 Spark 交互之时不需要显示的创建 SparkConf, SparkContext 以及 SQlContext，这些对象已经封闭在 SparkSession 中</strong></p>
</li>
</ol>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格。DataFrame与RDD的主要区别在于，前者带有schema元信息，即DataFrame所表示的二维表数据集的每一列都带有名称和类型。这使得Spark SQL得以洞察更多的结构信息，从而对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观RDD，由于无从得知所存数据元素的具体内部结构，Spark Core只能在stage层面进行简单、通用的流水线优化。</p>
<p><img src="https://yerias.github.io/spark_img/RDD%E5%92%8CDataFrame%E7%9A%84%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9%E6%AF%94%E8%BE%83.png" alt="RDD和DataFrame的存储内容比较"></p>
<h2 id="DataFrame的read和write"><a href="#DataFrame的read和write" class="headerlink" title="DataFrame的read和write"></a>DataFrame的read和write</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><ol>
<li><p>数据的读取[DataFrameReader]</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">rdd2df</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.json"</span></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line">		<span class="comment">//  读取json数据</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"json"</span>).load(in)</span><br><span class="line">        <span class="comment">//  使用$"" 导入隐式转换</span></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="comment">//  可以使用UDF</span></span><br><span class="line">        df.select($<span class="string">"name"</span>,$<span class="string">"age"</span>).show(<span class="number">2</span>,<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">//  不可以使用UDF 适合大部分场景</span></span><br><span class="line">        df.select(<span class="string">"name"</span>,<span class="string">"age"</span>).show()</span><br><span class="line">        <span class="comment">//  不推介，写着复杂</span></span><br><span class="line">        df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).show(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select方法用于选择要输出的列，推介使用 $”col” 和 “col” 的方法</p>
<ol>
<li>使用select可以选取打印的列，空值为null</li>
<li>show()默认打印20条数据，可以指定条数</li>
<li>truncate默认为true，截取长度，可以设置为false</li>
</ol>
<p>select方法有三种不同的写法，fliter也有</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).filter(<span class="symbol">'name</span> === <span class="string">"Andy"</span>).show()	<span class="comment">//推介使用</span></span><br><span class="line">df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).filter(df(<span class="string">"name"</span>) === <span class="string">"Andy"</span>).show()</span><br><span class="line">df.select(df(<span class="string">"name"</span>),df(<span class="string">"age"</span>)).filter(<span class="string">"name = 'Andy'"</span>).show()</span><br></pre></td></tr></table></figure>

<p>printSchema()方法可以查看数据的Schema信息</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">df.printSchema()</span><br><span class="line">------------------------------------------------</span><br><span class="line">root</span><br><span class="line"> |-- age: long (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- name: string (nullable = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据的存储[DataFrameWriter]</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectDf: <span class="type">DataFrame</span> = df.select($<span class="string">"name"</span>, $<span class="string">"age"</span>)</span><br><span class="line"><span class="comment">//  写出json数据</span></span><br><span class="line">selectDf.write.format(<span class="string">"json"</span>).mode(<span class="string">"overwrite"</span>).save(out)</span><br></pre></td></tr></table></figure>

<p>这里需要知道的一个概念是Save Modes</p>
<p>Save操作可以选择使用SaveMode，它指定目标如果存在，如何处理现有数据。重要的是要认识到，这些保存模式不利用任何锁定，也不是原子性的。此外，在执行覆盖时，在写入新数据之前将删除数据。</p>
<table>
<thead>
<tr>
<th align="left">Scala/Java</th>
<th align="left">Any Language</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SaveMode.ErrorIfExists</code> (default)</td>
<td align="left"><code>&quot;error&quot; or &quot;errorifexists&quot;</code> (default)</td>
<td align="left">在将DataFrame保存到数据源时，如果数据已经存在，则会抛出error。</td>
</tr>
<tr>
<td align="left"><code>SaveMode.Append</code></td>
<td align="left"><code>&quot;append&quot;</code></td>
<td align="left">在将DataFrame保存到数据源时，如果数据/表已经存在，则DataFrame的内容将被append到现有数据中。</td>
</tr>
<tr>
<td align="left"><code>SaveMode.Overwrite</code></td>
<td align="left"><code>&quot;overwrite&quot;</code></td>
<td align="left">overwrite模式意味着在将DataFrame保存到数据源时，如果数据/表已经存在，则现有数据将被DataFrame的内容覆盖。</td>
</tr>
<tr>
<td align="left"><code>SaveMode.Ignore</code></td>
<td align="left"><code>&quot;ignore&quot;</code></td>
<td align="left">ignore模式意味着在将DataFrame保存到数据源时，如果数据已经存在，则save操作不保存DataFrame的内容，也不更改现有数据。这类似于SQL中的<code>CREATE TABLE IF NOT EXISTS</code>。</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><ol>
<li><p>数据的读取</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">text2df</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.txt"</span></span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-sql/out"</span></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DataFrame不能直接split，且调用map返回的是一个Dataset</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"text"</span>).load(in)</span><br><span class="line">        <span class="keyword">val</span> mapDF: <span class="type">Dataset</span>[(<span class="type">String</span>, <span class="type">String</span>)] = df.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.toString().split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">        mapDF.show()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DataFrame转换为RDD后，再toDF，返回的是一个DataFrame</span></span><br><span class="line">        <span class="keyword">val</span> mapRDD2DF: <span class="type">DataFrame</span> = df.rdd.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.toString().split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;).toDF()</span><br><span class="line">        mapRDD2DF.show()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用textFile方法读取文本文件直接返回的是一个Dataset</span></span><br><span class="line">        <span class="keyword">val</span> ds: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(in)</span><br><span class="line">        <span class="keyword">val</span> mapDs: <span class="type">Dataset</span>[(<span class="type">String</span>, <span class="type">String</span>)] = ds.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">        mapDs.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文本数据读进来的一行在一个字段里面，所以要使用map算子，在map中split</p>
<ol>
<li>直接read.format()读进来的是DataFrame，map中不能直接split</li>
<li>DataFrame通过.rdd的方式转换成RDD，map中也不能直接split</li>
<li>通过read.textFile()的方式读进来的是Dataset，map中可以split</li>
</ol>
</li>
<li><p>数据的存储</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.format(<span class="string">"text"</span>).load(in)</span><br><span class="line"><span class="keyword">val</span> mapDF = df.map(row =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> words = row.toString().split(<span class="string">","</span>)</span><br><span class="line">    <span class="comment">// 拼接成一列</span></span><br><span class="line">    words(<span class="number">0</span>) +<span class="string">","</span>+words(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mapDF.write.format(<span class="string">"text"</span>).mode(<span class="string">"overwrite"</span>).save(out)</span><br></pre></td></tr></table></figure>

<p>文本数据写出去的时候</p>
<ol>
<li>不支持int类型，如果存在int类型，会报错，解决办法是toString，转换成字符串</li>
<li>只能作为一列输出，如果是多列，会报错，解决办法是拼接起来，组成一列</li>
</ol>
<p><strong>文本数据压缩输出，只要是Spark支持的压缩的格式，都可以指定</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">mapDF.write</span><br><span class="line">    .format(<span class="string">"text"</span>)</span><br><span class="line">    <span class="comment">// 添加压缩操作</span></span><br><span class="line">    .option(<span class="string">"compression"</span>,<span class="string">"gzip"</span>)</span><br><span class="line">    .mode(<span class="string">"overwrite"</span>)</span><br><span class="line">    .save(out)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h3><ol>
<li><p>数据的读取</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">csv2df</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.csv"</span></span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-sql/out"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read</span><br><span class="line">            .format(<span class="string">"csv"</span>)</span><br><span class="line">            .option(<span class="string">"header"</span>, <span class="string">"true"</span>)</span><br><span class="line">            .option(<span class="string">"sep"</span>, <span class="string">";"</span>)</span><br><span class="line">            .option(<span class="string">"interSchema"</span>,<span class="string">"true"</span>)</span><br><span class="line">            .load(in)</span><br><span class="line">        df.show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>csv读取数据注意使用几个参数</p>
<ol>
<li>指定表头：<code>option(&quot;header&quot;, &quot;true&quot;)</code></li>
<li>指定分隔符：<code>option(&quot;sep&quot;, &quot;;&quot;)</code></li>
<li>类型自动推测：<code>option(&quot;interSchema&quot;,&quot;true&quot;)</code></li>
</ol>
</li>
</ol>
<h3 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h3><p>在操作jdbc之前要导入两个依赖，一个是mysql-jdbc，用来连接mysql，一个是config，用来解决硬编码的问题</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.typesafe<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.conf文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.<span class="keyword">default</span>.driver=<span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">db.<span class="keyword">default</span>.url=<span class="string">"jdbc:mysql://hadoop/listener?characterEncoding=utf-8&amp;useSSL=false"</span></span><br><span class="line">db.<span class="keyword">default</span>.user=<span class="string">"root"</span></span><br><span class="line">db.<span class="keyword">default</span>.password=<span class="string">"root"</span></span><br><span class="line">db.<span class="keyword">default</span>.source=<span class="string">"dws_ad_phone_type_dist"</span></span><br><span class="line">db.<span class="keyword">default</span>.target=<span class="string">"dws_ad_phone_type_dist_1"</span></span><br><span class="line">db.<span class="keyword">default</span>.db=<span class="string">"access_dw"</span></span><br><span class="line"></span><br><span class="line"># Connection Pool settings</span><br><span class="line">db.<span class="keyword">default</span>.poolInitialSize=<span class="number">10</span></span><br><span class="line">db.<span class="keyword">default</span>.poolMaxSize=<span class="number">20</span></span><br><span class="line">db.<span class="keyword">default</span>.connectionTimeoutMillis=<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>数据的读取</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">mysql2df</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取配置文件中的值，db.default开头</span></span><br><span class="line">        <span class="keyword">val</span> conf = <span class="type">ConfigFactory</span>.load()</span><br><span class="line">        <span class="keyword">val</span> driver = conf.getString(<span class="string">"db.default.driver"</span>)</span><br><span class="line">        <span class="keyword">val</span> url = conf.getString(<span class="string">"db.default.url"</span>)</span><br><span class="line">        <span class="keyword">val</span> user = conf.getString(<span class="string">"db.default.user"</span>)</span><br><span class="line">        <span class="keyword">val</span> password = conf.getString(<span class="string">"db.default.password"</span>)</span><br><span class="line">        <span class="keyword">val</span> source = conf.getString(<span class="string">"db.default.source"</span>)</span><br><span class="line">        <span class="keyword">val</span> target = conf.getString(<span class="string">"db.default.target"</span>)</span><br><span class="line">        <span class="keyword">val</span> db = conf.getString(<span class="string">"db.default.db"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据库的内容</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read</span><br><span class="line">            .format(<span class="string">"jdbc"</span>)</span><br><span class="line">            .option(<span class="string">"url"</span>, url)</span><br><span class="line">            .option(<span class="string">"dbtable"</span>, <span class="string">s"<span class="subst">$db</span>.<span class="subst">$source</span>"</span>)	<span class="comment">//库名.源表</span></span><br><span class="line">            .option(<span class="string">"user"</span>, user)</span><br><span class="line">            .option(<span class="string">"password"</span>, password)</span><br><span class="line">            .option(<span class="string">"driver"</span>, driver)</span><br><span class="line">            .load()</span><br><span class="line">        <span class="comment">//使用DataFrame创建临时表提供spark.sql查询</span></span><br><span class="line">        df.createOrReplaceTempView(<span class="string">"phone_type_dist"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//spark.sql写SQL返回一个DataFrame</span></span><br><span class="line">        <span class="keyword">val</span> sqlDF: <span class="type">DataFrame</span> = spark.sql(<span class="string">"select * from phone_type_dist where phoneSystemType = 'IOS'"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用df.createOrReplaceTempView()方法创建一个DataFrame数据生成的临时表，提供spark.sql()使用SQL操作数据，返回的也是一个DataFrame</li>
</ul>
</li>
<li><p>数据的存储</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接着上面返回的sqlDF: DataFrame</span></span><br><span class="line">sqlDF.write</span><br><span class="line">    .format(<span class="string">"jdbc"</span>)</span><br><span class="line">    .option(<span class="string">"url"</span>, url)</span><br><span class="line">    .option(<span class="string">"dbtable"</span>, <span class="string">s"<span class="subst">$db</span>.<span class="subst">$target</span>"</span>)	<span class="comment">//库名.目标表</span></span><br><span class="line">    .option(<span class="string">"user"</span>, user)</span><br><span class="line">    .option(<span class="string">"password"</span>, password)</span><br><span class="line">    .option(<span class="string">"driver"</span>,driver)</span><br><span class="line">    .save()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SparkSQL做统计分析"><a href="#SparkSQL做统计分析" class="headerlink" title="SparkSQL做统计分析"></a>SparkSQL做统计分析</h2><ol>
<li><p>数据</p>
</li>
<li><p>需求：求每个国家的每个域名的访问流量排名前2</p>
</li>
<li><p>SQL实现</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">GroupTopN</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">        <span class="keyword">val</span> ds = spark.read.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="comment">//为生成需要的表格做准备</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = ds.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">3</span>), words(<span class="number">12</span>), words(<span class="number">15</span>).toLong)</span><br><span class="line">        &#125;).toDF(<span class="string">"country"</span>, <span class="string">"domain"</span>, <span class="string">"traffic"</span>)</span><br><span class="line"></span><br><span class="line">        df.createOrReplaceTempView(<span class="string">"access"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个国家的域名流量前2</span></span><br><span class="line">        <span class="keyword">val</span> topNSQL=<span class="string">""</span><span class="string">"select</span></span><br><span class="line"><span class="string">                      |	*</span></span><br><span class="line"><span class="string">                      |from (</span></span><br><span class="line"><span class="string">                      |		select</span></span><br><span class="line"><span class="string">                      |			t.*,row_number() over(partition by country order by sum_traffic desc) r</span></span><br><span class="line"><span class="string">                      |		from</span></span><br><span class="line"><span class="string">                      |			(</span></span><br><span class="line"><span class="string">                      |				select country,domain,sum(traffic) as sum_traffic from access group by country,domain</span></span><br><span class="line"><span class="string">                      |			) t</span></span><br><span class="line"><span class="string">                      |	) rt</span></span><br><span class="line"><span class="string">                      |where rt.r &lt;=2 "</span><span class="string">""</span>.stripMargin</span><br><span class="line"></span><br><span class="line">        spark.sql(topNSQL).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果只要求traffic的降序，可以使用API直接写出来</p>
<p>分组，求和，别名，降序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//traffic降序排序</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.functions._</span><br><span class="line">df.groupBy(<span class="string">"country"</span>,<span class="string">"domain"</span>).agg(sum(<span class="string">"traffic"</span>).as(<span class="string">"sum_traffic"</span>)).sort($<span class="string">"sum_traffic"</span>.desc).show()</span><br></pre></td></tr></table></figure>

<p><strong>注意看源码中案例仿写</strong></p>
</li>
<li><p>结果展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+----------------+-----------------+-----------+---+</span><br><span class="line">|         country|           domain|sum_traffic|  r|</span><br><span class="line">+----------------+-----------------+-----------+---+</span><br><span class="line">|            中国| www.bilibili.com|   <span class="number">24265886</span>|  <span class="number">1</span>|</span><br><span class="line">|            中国|www.ruozedata.com|    <span class="number">4187637</span>|  <span class="number">2</span>|</span><br><span class="line">|          利比亚| www.bilibili.com|      <span class="number">22816</span>|  <span class="number">1</span>|</span><br><span class="line">|          利比亚|  ruoze.ke.qq.com|      <span class="number">15970</span>|  <span class="number">2</span>|</span><br><span class="line">|            加纳| www.bilibili.com|     <span class="number">138659</span>|  <span class="number">1</span>|</span><br><span class="line">|            加纳|www.ruozedata.com|      <span class="number">17988</span>|  <span class="number">2</span>|</span><br><span class="line">|        利比里亚| www.bilibili.com|      <span class="number">20593</span>|  <span class="number">1</span>|</span><br><span class="line">|        利比里亚|  ruoze.ke.qq.com|       <span class="number">7466</span>|  <span class="number">2</span>|</span><br><span class="line">+----------------+-----------------+-----------+---+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="UDF函数"><a href="#UDF函数" class="headerlink" title="UDF函数"></a>UDF函数</h2><ol>
<li><p>数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大狗	小破车,渣团,热刺,我纯</span><br><span class="line">桶子	利物浦</span><br><span class="line">二娃	南大王,西班牙人</span><br></pre></td></tr></table></figure>
</li>
<li><p>需求：求出每个人的爱好的个数</p>
</li>
<li><p>SQLs实现</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LoveLength</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取文本内容</span></span><br><span class="line">        <span class="keyword">val</span> ds: <span class="type">Dataset</span>[<span class="type">String</span>] = spark.read.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文本转换成DF</span></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = ds.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">"\t"</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;).toDF(<span class="string">"name"</span>, <span class="string">"love"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建UDF</span></span><br><span class="line">        spark.udf.register(<span class="string">"length"</span>, (love: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">            love.split(<span class="string">","</span>).length</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//DF创建临时表</span></span><br><span class="line">        df.createOrReplaceTempView(<span class="string">"udf_love"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在sql中使用UDF函数</span></span><br><span class="line">        spark.sql(<span class="string">"select name,love,length(love) as love_length from udf_love"</span>).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面是使用SQL的解决方案，还可以使用API的方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的udf需要返回值</span></span><br><span class="line"><span class="keyword">val</span> loveLengthUDF: <span class="type">UserDefinedFunction</span> = spark.udf.register(<span class="string">"length"</span>, (love: <span class="type">String</span>) =&gt; &#123;</span><br><span class="line">    love.split(<span class="string">","</span>).length</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//df.select中传入UDF函数</span></span><br><span class="line">df.select($<span class="string">"name"</span>,$<span class="string">"love"</span>,loveLengthUDF($<span class="string">"love"</span>)).show()</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果展示</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">+----+---------------------+----------------+</span><br><span class="line">|大狗|小破车,渣团,热刺,我纯   |               <span class="number">4</span>|</span><br><span class="line">|桶子|               利物浦 |               <span class="number">1</span>|</span><br><span class="line">|二娃|      南大王,西班牙人  |               <span class="number">2</span>|</span><br><span class="line">+----+---------------------+----------------+</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="存储格式的转换"><a href="#存储格式的转换" class="headerlink" title="存储格式的转换"></a>存储格式的转换</h2><p>Spark读text文件进行清洗，清洗完以后直接以我们想要的列式存储格式输出，如果按以前的方式要经过很多复杂的步骤</p>
<p>用Spark的时候只需要在<code>df.write.format(&quot;orc&quot;).mode().save()</code>中指定格式即可，如orc，现在就很方便了，想转成什么格式，只要format支持就ok</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">text2orc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">            .builder()</span><br><span class="line">            .master(<span class="string">"local[2]"</span>)</span><br><span class="line">            .appName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">            .config(<span class="string">"spark.some.config.option"</span>, <span class="string">"some-value"</span>)</span><br><span class="line">            .getOrCreate()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> in = <span class="string">"tunan-spark-sql/data/people.txt"</span></span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-sql/out"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> df = spark.read.textFile(in)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> spark.implicits._</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对文本文件做处理</span></span><br><span class="line">        df.map(row =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = row.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>),words(<span class="number">1</span>))</span><br><span class="line">        &#125;)</span><br><span class="line">            .toDF(<span class="string">"name"</span>,<span class="string">"age"</span>)	<span class="comment">//这一步解决了数据没有表头的问题</span></span><br><span class="line">            .write</span><br><span class="line">            .mode(<span class="string">"overwrite"</span>)	<span class="comment">//save mode</span></span><br><span class="line">            .format(<span class="string">"orc"</span>)	<span class="comment">//save format</span></span><br><span class="line">            .save(out)	<span class="comment">//save path</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>20200416更新：</em> df.write.format(“…”).option(“compression”,”…”)   ==&gt; 存储格式+压缩格式</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/04/02/spark/9/">经典案例&amp;多目录输出&amp;计数器&amp;持久化&amp;广播变量</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-02</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>经典案例</li>
<li>多目录输出</li>
<li>计数器</li>
<li>持久化</li>
<li>广播变量</li>
</ol>
<h2 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户     节目            展示 点击</span></span><br><span class="line"><span class="comment"> * 001,一起看|电视剧|军旅|亮剑,1,1</span></span><br><span class="line"><span class="comment"> * 001,一起看|电视剧|军旅|亮剑,1,0</span></span><br><span class="line"><span class="comment"> * 002,一起看|电视剧|军旅|士兵突击,1,1</span></span><br><span class="line"><span class="comment"> * ==&gt;</span></span><br><span class="line"><span class="comment"> * 001,一起看,2,1</span></span><br><span class="line"><span class="comment"> * 001,电视剧,2,1</span></span><br><span class="line"><span class="comment"> * 001,军旅,2,1</span></span><br><span class="line"><span class="comment"> * 001,亮剑,2,1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">exercise02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> linesRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"tunan-spark-core/data/test2.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用map返回的是一个数组，我不要数组，就使用flatMap</span></span><br><span class="line">        <span class="keyword">import</span> com.tunan.spark.utils.<span class="type">ImplicitAspect</span>.rdd2RichRDD</span><br><span class="line">        <span class="keyword">val</span> map2RDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">Int</span>))] = linesRDD.flatMap(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words: <span class="type">Array</span>[<span class="type">String</span>] = line.split(<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">val</span> programs: <span class="type">Array</span>[<span class="type">String</span>] = words(<span class="number">1</span>).split(<span class="string">"\\|"</span>)</span><br><span class="line">            <span class="keyword">val</span> mapRDD: <span class="type">Array</span>[((<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">Int</span>))] = programs.map(program =&gt; ((words(<span class="number">0</span>), program), (words(<span class="number">2</span>).toInt, words(<span class="number">3</span>).toInt)))</span><br><span class="line">            mapRDD</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Iterable</span>[(<span class="type">Int</span>, <span class="type">Int</span>)])] = map2RDD.groupByKey()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是mapValues很好的一个使用案例</span></span><br><span class="line">        <span class="keyword">val</span> mapVRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), (<span class="type">Int</span>, <span class="type">Int</span>))] = groupRDD.mapValues(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> imps: <span class="type">Int</span> = x.map(_._1).sum</span><br><span class="line">            <span class="keyword">val</span> check: <span class="type">Int</span> = x.map(_._2).sum</span><br><span class="line">            (imps, check)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化输出</span></span><br><span class="line">        mapVRDD.map(x =&gt; &#123;</span><br><span class="line">            (x._1._1,x._1._2,x._2._1,x._2._1)</span><br><span class="line">        &#125;).print()</span><br><span class="line"></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多目录输出"><a href="#多目录输出" class="headerlink" title="多目录输出"></a>多目录输出</h2><ol>
<li><p>实现多目录输出自定义类</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.<span class="type">NullWritable</span></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapred.lib.<span class="type">MultipleTextOutputFormat</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMultipleTextOutputFormat</span> <span class="keyword">extends</span> <span class="title">MultipleTextOutputFormat</span>[<span class="type">Any</span>,<span class="type">Any</span>] </span>&#123;</span><br><span class="line">    <span class="comment">//生成最终生成的key的类型，这里不要，给Null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">generateActualKey</span></span>(key: <span class="type">Any</span>, value: <span class="type">Any</span>): <span class="type">Any</span> = <span class="type">NullWritable</span>.get()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成最终生成的value的类型，这里是String</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">generateActualValue</span></span>(key: <span class="type">Any</span>, value: <span class="type">Any</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">        value.asInstanceOf[<span class="type">String</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成文件名</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">generateFileNameForKeyValue</span></span>(key: <span class="type">Any</span>, value: <span class="type">Any</span>, name: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="string">s"<span class="subst">$key</span>/<span class="subst">$name</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主类，使用<code>saveAsHadoopFile(path, keyClass, valueClass, fm.runtimeClass.asInstanceOf[Class[F]])</code>方法保存数据，指定参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MultipleDirectory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> out = <span class="string">"tunan-spark-core/out"</span></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="type">CheckHDFSOutPath</span>.ifExistsDeletePath(sc.hadoopConfiguration,out)</span><br><span class="line">        <span class="comment">//读取数组，转换成键值对的格式</span></span><br><span class="line">        <span class="keyword">val</span> lines = sc.textFile(<span class="string">"tunan-spark-core/ip/access-result/*"</span>)</span><br><span class="line">        <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = lines.map(line =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = line.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">12</span>), line)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//多目录保存文件</span></span><br><span class="line">        mapRDD.saveAsHadoopFile(out,classOf[<span class="type">String</span>],classOf[<span class="type">String</span>],classOf[<span class="type">MyMultipleTextOutputFormat</span>])</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="https://yerias.github.io/spark_img/%E5%A4%9A%E7%9B%AE%E5%BD%95%E8%BE%93%E5%87%BA.jpg" alt="多目录输出"></p>
</li>
</ol>
<p>在spark程序中，当一个传递给Spark操作(例如map和reduce)的函数在远程节点上面运行时，Spark操作实际上操作的是这个函数所用变量的一个<strong>独立副本</strong>。这些变量会被复制到每台机器上，并且这些变量在远程机器上的所有更新都不会传递回驱动程序。通常跨任务的读写变量是低效的，但是，Spark还是为两种常见的使用模式提供了两种有限的共享变量：广播变量（broadcast variable）和累加器（accumulator）</p>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><h3 id="为什么要定义计数器？"><a href="#为什么要定义计数器？" class="headerlink" title="为什么要定义计数器？"></a>为什么要定义计数器？</h3><p>在spark应用程序中，我们经常会有这样的需求，如<em>异常监控</em>，<em>调试</em>，<em>记录符合某特性的数据的数目</em>，这种需求都需要用到计数器，如果一个变量不被声明为一个累加器，那么它将在被改变时不会再driver端进行全局汇总，即在分布式运行时每个task运行的只是原始变量的一个副本，并不能改变原始变量的值，但是当这个变量被声明为累加器后，该变量就会有分布式计数的功能。</p>
<h3 id="图解计数器"><a href="#图解计数器" class="headerlink" title="图解计数器"></a>图解计数器</h3><p>错误的图解</p>
<p><img src="https://yerias.github.io/spark_img/%E7%B4%AF%E5%8A%A0%E5%99%A8%E9%94%99%E8%AF%AF%E7%9A%84%E5%9B%BE%E8%A7%A3.png" alt="累加器错误的图解"></p>
<p>正确的图解</p>
<p><img src="https://yerias.github.io/spark_img/%E7%B4%AF%E5%8A%A0%E5%99%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%9B%BE%E8%A7%A3.png" alt="累加器正确的图解"></p>
<p>计数器种类很多，但是经常用的就是两种，<code>longAccumulator</code>和<code>collectionAccumulator</code></p>
<p><strong>需要注意的是计数器是lazy的，只有触发action才会进行计数，在不持久化的情况下重复触发action，计数器会重复累加</strong></p>
<h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><p>Accumulators 是只能通过associative和commutative操作“added”的变量，因此可以有效地并行支持。它们可用于实现计数器(如MapReduce)和Spark本身支持数字类型的累加器，程序员还<strong>可以添加对新类型的支持</strong>。</p>
<p><code>longAccumulator</code>通过累加的方式计数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyLongAccumulator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="keyword">var</span> acc = sc.longAccumulator(<span class="string">"计数"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> rdd = sc.parallelize(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="comment">// 计数器做累加</span></span><br><span class="line">            acc.add(<span class="number">1</span>L)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// action操作 </span></span><br><span class="line">        forRDD.count()</span><br><span class="line">       </span><br><span class="line">        println(acc.value)	<span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>longAccumulator</code>做计数的时候要小心重复执行action导致的acc.value的变化</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyLongAccumulatorV2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="comment">//生成计数器</span></span><br><span class="line">        <span class="keyword">val</span> acc = sc.longAccumulator(<span class="string">"计数"</span>)</span><br><span class="line">        <span class="keyword">val</span> rdd = sc.parallelize(<span class="number">1</span> to <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="comment">//计数器做累加</span></span><br><span class="line">            acc.add(<span class="number">1</span>L)</span><br><span class="line">        &#125;)</span><br><span class="line">        forRDD.count()</span><br><span class="line">        println(acc.value)	<span class="comment">//8</span></span><br><span class="line">        forRDD.count()</span><br><span class="line">        println(acc.value)	<span class="comment">//16</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于重复执行了count()，累加器的数量成倍增长，解决这种错误累加也很简单，就是在count之前调用forRDD的cache方法(或persist)，这样在count后数据集就会被缓存下来，reduce操作就会读取缓存的数据集，而无需从头开始计算。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyLongAccumulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">        <span class="comment">//生成计数器</span></span><br><span class="line">        <span class="keyword">val</span> acc = sc.longAccumulator(<span class="string">"计数"</span>)</span><br><span class="line">        <span class="keyword">val</span> rdd = sc.parallelize(<span class="number">1</span> to <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="comment">//计数器做累加</span></span><br><span class="line">            acc.add(<span class="number">1</span>L)</span><br><span class="line">        &#125;)</span><br><span class="line">        forRDD.cache().count()</span><br><span class="line">        println(acc.value)	<span class="comment">//8</span></span><br><span class="line">        forRDD.count()</span><br><span class="line">        println(acc.value)	<span class="comment">//8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CollectionAccumulator"><a href="#CollectionAccumulator" class="headerlink" title="CollectionAccumulator"></a>CollectionAccumulator</h3><p><code>collectionAccumulator</code>，集合计数器，计数器中保存的是集合元素，通过泛型指定。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：id后三位相同的加入计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyCollectionAccumulator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc  = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成集合计数器</span></span><br><span class="line">        <span class="keyword">val</span> acc = sc.collectionAccumulator[<span class="type">People</span>](<span class="string">"集合计数器"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成RDD</span></span><br><span class="line">        <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">People</span>] = sc.parallelize(<span class="type">Array</span>(<span class="type">People</span>(<span class="string">"tunan"</span>, <span class="number">100000</span>), <span class="type">People</span>(<span class="string">"xiaoqi"</span>, <span class="number">100001</span>), <span class="type">People</span>(<span class="string">"张三"</span>, <span class="number">100222</span>), <span class="type">People</span>(<span class="string">"李四"</span>, <span class="number">100003</span>)))</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">//map操作</span></span><br><span class="line">        rdd.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> id2 = x.id.toString.reverse</span><br><span class="line">            <span class="comment">//满足条件就加入计数器，</span></span><br><span class="line">            <span class="keyword">if</span> (id2(<span class="number">0</span>) == id2(<span class="number">1</span>) &amp;&amp; id2(<span class="number">0</span>) ==id2(<span class="number">2</span>))&#123;</span><br><span class="line">                acc.add(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).count()	<span class="comment">//触发action</span></span><br><span class="line"></span><br><span class="line">        println(acc.value)	<span class="comment">//[People(张三,100222), People(tunan,100000)]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span>(<span class="params">name:<span class="type">String</span>,id:<span class="type">Long</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ol>
<li><p>计数器在Driver端定义赋初始值，计数器只能在Driver端读取最后的值，在Excutor端更新。</p>
</li>
<li><p>计数器不是一个调优的操作，因为如果不这样做，结果是错的</p>
</li>
</ol>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Spark中最重要的功能之一是跨操作在内存中持久化数据集。持久化一个RDD时，每个节点在内存中存储它计算的任何分区，并在该数据集(或从中派生的数据集)的其他操作中重构它们。这使得将来的操作要快得多(通常超过10倍)。缓存是迭代算法和快速交互使用的关键工具。</p>
<p>可以使用其上的persist()或cache()方法将RDD标记为持久的。第一次在操作中计算它时，它将保存在节点的内存中。Spark的缓存是容错的——如果一个RDD的任何分区丢失了，它将使用最初创建它的转换自动重新计算。</p>
<p>持久化的存储级别很多，常用的是MEMORY_ONLY、MEMORY_ONLY_SER、MEMORY_AND_DISK</p>
<table>
<thead>
<tr>
<th align="left">Storage Level</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">MEMORY_ONLY</td>
<td align="left">将RDD作为不序列化的Java对象存储在JVM中。如果RDD不适合内存，那么一些分区将不会被缓存，而是在需要它们时动态地重新计算。这是默认级别。</td>
</tr>
<tr>
<td align="left">MEMORY_AND_DISK</td>
<td align="left">将RDD作为不序列化的Java对象存储在JVM中。如果RDD不适合内存，那么将不适合的分区存储在磁盘上，并在需要时从那里读取它们。</td>
</tr>
<tr>
<td align="left">MEMORY_ONLY_SER (Java and Scala)</td>
<td align="left">将RDD存储为序列化的Java对象(每个分区一个字节数组)。这通常比反序列化对象更节省空间，特别是在使用快速序列化器时，但读取时需要更多cpu。</td>
</tr>
</tbody></table>
<h3 id="如何选择它们？"><a href="#如何选择它们？" class="headerlink" title="如何选择它们？"></a><strong>如何选择它们？</strong></h3><p>Storage Level的选择是内存和CPU的权衡</p>
<ol>
<li>内存多：MEMORY_ONLY (不进行序列化)</li>
<li>CPU跟的上：MEMORY_ONLY_SER (进行了序列化，推介)</li>
<li>不建议写Disk</li>
</ol>
<p>使用cache()和persist()进行持久化操作，它们都是<strong>lazy</strong>的，需要action才能触发，默认使用MEMORY_ONLY</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> forRDD.cache</span></span><br><span class="line">res18: forRDD.type = MapPartitionsRDD[9] at map at &lt;console&gt;:27</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> forRDD.count</span></span><br><span class="line">res19: Long = 8</span><br></pre></td></tr></table></figure>

<p>结果可以在Web UI的<strong>Storage</strong>中查看</p>
<p>如果需要<strong>清除缓存</strong>，使用unpersist()，清除缓存数据是立即执行的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">scala&gt;</span><span class="bash"> forRDD.unpersist()</span></span><br><span class="line">res8: forRDD.type = MapPartitionsRDD[3] at map at &lt;console&gt;:28</span><br></pre></td></tr></table></figure>

<p><strong>怎么修改存储级别？</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> forRDD = rdd.map(x =&gt; &#123;</span><br><span class="line">    <span class="comment">//计数器做累加</span></span><br><span class="line">    acc.add(<span class="number">1</span>L)</span><br><span class="line">&#125;).persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY_SER</span>).count()</span><br></pre></td></tr></table></figure>

<p>StorageLevel是个object，需要的级别都可以从里面拿出来</p>
<h4 id="考点：cache和persist有什么区别？"><a href="#考点：cache和persist有什么区别？" class="headerlink" title="考点：cache和persist有什么区别？"></a><strong>考点：cache和persist有什么区别？</strong></h4><ul>
<li>cache调用的persist，persist调用的persist(storage level)</li>
</ul>
<h4 id="考点：序列化和非序列化有什么区别？"><a href="#考点：序列化和非序列化有什么区别？" class="headerlink" title="考点：序列化和非序列化有什么区别？"></a><strong>考点：序列化和非序列化有什么区别？</strong></h4><ul>
<li>序列化将对象转换成字节数组了，节省空间，占CPU</li>
</ul>
<h3 id="Removing-Data"><a href="#Removing-Data" class="headerlink" title="Removing Data"></a>Removing Data</h3><p>Spark自动监视每个节点上的缓存使用情况，并以最近最少使用(LRU)的方式删除旧的数据分区。如果想要手动删除一个RDD，而不是等待它从缓存中消失，那么可以使用RDD.unpersist()方法。</p>
<p>伪代码以及画图表示出什么是LRU？</p>
<h2 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h2><h3 id="为什么要将变量定义成广播变量？"><a href="#为什么要将变量定义成广播变量？" class="headerlink" title="为什么要将变量定义成广播变量？"></a>为什么要将变量定义成广播变量？</h3><p>如果我们要在分布式计算里面分发大对象，例如：<em>字典</em>，<em>集合</em>，<em>黑白名单</em>等，这个都会由Driver端进行分发，一般来讲，如果这个变量不是广播变量，那么每个task就会分发一份，这在<strong>task数目十分多的情况下Driver的带宽会成为系统的瓶颈，而且会大量消耗task服务器上的资源</strong>，如果将这个变量声明为广播变量，那么知识每个executor拥有一份，这个executor启动的task会共享这个变量，节省了通信的成本和服务器的资源。</p>
<h3 id="广播变量图解"><a href="#广播变量图解" class="headerlink" title="广播变量图解"></a>广播变量图解</h3><p>错误的，不使用广播变量</p>
<p><img src="https://yerias.github.io/spark_img/%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F.png" alt="不使用广播变量"></p>
<p>正确的，使用广播变量的情况</p>
<p><img src="https://yerias.github.io/spark_img/%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F.png" alt="使用广播变量"></p>
<h3 id="小表广播案例"><a href="#小表广播案例" class="headerlink" title="小表广播案例"></a>小表广播案例</h3><p>使用广播变量的场景很多， 我们都知道spark 一种常见的优化方式就是小表广播， 使用 map join 来代替 reduce join， 我们通过把小的数据集广播到各个节点上，节省了一次特别 expensive 的 shuffle 操作。</p>
<p>比如driver 上有一张数据量很小的表， 其他节点上的task 都需要 lookup 这张表， 那么 driver 可以先把这张表 copy 到这些节点，这样 task 就可以在本地查表了。</p>
<ol>
<li><p>Fact table  航线(起点机场, 终点机场, 航空公司, 起飞时间)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SEA,JFK,DL,7:00</span><br><span class="line">SFO,LAX,AA,7:05</span><br><span class="line">SFO,JFK,VX,7:05</span><br><span class="line">JFK,LAX,DL,7:10</span><br><span class="line">LAX,SEA,DL,7:10</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dimension table 机场(简称, 全称, 城市, 所处城市简称)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JFK,John F. Kennedy International Airport,New York,NY</span><br><span class="line">LAX,Los Angeles International Airport,Los Angeles,CA</span><br><span class="line">SEA,Seattle-Tacoma International Airport,Seattle,WA</span><br><span class="line">SFO,San Francisco International Airport,San Francisco,CA</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dimension table  航空公司(简称,全称)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AA,American Airlines</span><br><span class="line">DL,Delta Airlines</span><br><span class="line">VX,Virgin America</span><br></pre></td></tr></table></figure>
</li>
<li><p>思路：将机场维度表和航空公司维度表进行广播，生成Map，航线事实表从广播变量中通过key拿到value(计算在每个executor上)</p>
</li>
<li><p>代码</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">BroadcastApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="type">ContextUtils</span>.getSparkContext(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fact table  航线(起点机场, 终点机场, 航空公司, 起飞时间)</span></span><br><span class="line">        <span class="keyword">val</span> flights = sc.textFile(<span class="string">"tunan-spark-core/broadcast/flights.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dimension table 机场(简称, 全称, 城市, 所处城市简称)</span></span><br><span class="line">        <span class="keyword">val</span> airports: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"tunan-spark-core/broadcast/airports.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dimension table  航空公司(简称,全称)</span></span><br><span class="line">        <span class="keyword">val</span> airlines = sc.textFile(<span class="string">"tunan-spark-core/broadcast/airlines.txt"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最终统计结果：</span></span><br><span class="line"><span class="comment">         * 出发城市           终点城市           航空公司名称         起飞时间</span></span><br><span class="line"><span class="comment">         * Seattle           New York       Delta Airlines          7:00</span></span><br><span class="line"><span class="comment">         * San Francisco     Los Angeles    American Airlines       7:05</span></span><br><span class="line"><span class="comment">         * San Francisco     New York       Virgin America          7:05</span></span><br><span class="line"><span class="comment">         * New York          Los Angeles    Delta Airlines          7:10</span></span><br><span class="line"><span class="comment">         * Los Angeles       Seattle        Delta Airlines          7:10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//广播Dimension Table airport，生成Map</span></span><br><span class="line">        <span class="keyword">val</span> airportsBC = sc.broadcast(airports.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = x.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">2</span>))</span><br><span class="line">        &#125;).collectAsMap())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广播Dimension Table airlines，生成Map</span></span><br><span class="line">        <span class="keyword">val</span> airlinesBC = sc.broadcast(airlines.map(x =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = x.split(<span class="string">","</span>)</span><br><span class="line">            (words(<span class="number">0</span>), words(<span class="number">1</span>))</span><br><span class="line">        &#125;).collectAsMap())</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过key获取value</span></span><br><span class="line">        flights.map(lines =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> words = lines.split(<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">val</span> a = airportsBC.value.get(words(<span class="number">0</span>)).get</span><br><span class="line">            <span class="keyword">val</span> b = airportsBC.value.get(words(<span class="number">1</span>)).get</span><br><span class="line">            <span class="keyword">val</span> c = airlinesBC.value.get(words(<span class="number">2</span>)).get</span><br><span class="line">            a+<span class="string">"    "</span>+b+<span class="string">"    "</span>+c+<span class="string">"    "</span>+words(<span class="number">3</span>)</span><br><span class="line">        &#125;).foreach(println)</span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">New York    	Los Angeles     Delta Airlines    7:10</span><br><span class="line">Los Angeles     Seattle    		Delta Airlines    7:10</span><br><span class="line">Seattle    		New York    	Delta Airlines    7:00</span><br><span class="line">San Francisco   Los Angeles     American Airlines 7:05</span><br><span class="line">San Francisco   New York    	Virgin America    7:05</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="为什么只能-broadcast-只读的变量"><a href="#为什么只能-broadcast-只读的变量" class="headerlink" title="为什么只能 broadcast 只读的变量"></a>为什么只能 broadcast 只读的变量</h3><p>这就涉及一致性的问题，如果变量可以被更新，那么一旦变量被某个节点更新，其他节点要不要一块更新？如果多个节点同时在更新，更新顺序是什么？怎么做同步？ 仔细想一下， 每个都很头疼， spark 目前就索性搞成了只读的。  因为分布式强一致性真的很蛋疼</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>变量一旦被定义为一个广播变量，那么这个变量只能读，不能修改</p>
</li>
<li><p>能不能将一个RDD使用广播变量广播出去？因为RDD是不存储数据的。<strong>可以将RDD的结果广播出去。</strong></p>
</li>
<li><p>广播变量只能在Driver端定义，<strong>不能在Executor端定义。</strong></p>
</li>
<li><p>在Driver端可以修改广播变量的值，<strong>在Executor端无法修改广播变量的值。</strong></p>
</li>
<li><p>如果executor端用到了Driver的变量，<strong>不使用广播变量在Executor有多少task就有多少Driver端的变量副本。</strong></p>
</li>
<li><p>如果Executor端用到了Driver的变量，<strong>使用广播变量在每个Executor中只有一份Driver端的变量副本。</strong></p>
</li>
</ol>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/">&lt;&lt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/">&gt;&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>