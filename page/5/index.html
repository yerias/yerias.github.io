<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BigData Developer"><meta name="keywords" content="yerias,TUNANのBlog,BigData"><meta name="author" content="Tunan"><meta name="copyright" content="Tunan"><title>感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017 | TUNANのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Tunan</div><div class="author-info__description text-center">BigData Developer</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">129</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">26</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">TUNANのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">TUNANのBlog</div><div id="site-sub-title">感谢若老、J哥、师兄、前辈、同学、朋友、陌生人，在我行走在大数据道路上给我的谆谆教诲，同时此博客仅作为学习笔记存在，严禁任何人以何种理由商用，作者QQ: 971118017</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/24/spark/2/">Spark之Transformations&amp;Action</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>Transformations</li>
<li>Action</li>
</ol>
<h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p>Transformations的特点是lazy的，和Scala中的lazy该念一致：延迟/懒加载，也就是不会立刻执行，只有等待遇到第一个action才会去提交作业到Spark上</p>
<h3 id="转换算子"><a href="#转换算子" class="headerlink" title="转换算子"></a>转换算子</h3><p><strong>map</strong> 作用到每一个元素</p>
<p>输入:任意类型的函数，输出:泛型U类型的函数，返回RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>

<p><strong>mapPartitions</strong> 作用到每一个分区</p>
<p>输入:一个可迭代的类型T，输出:一个可迭代的类型U，返回RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitions</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">    f: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],</span><br><span class="line">    preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>

<p><strong>mapPartitionsWithIndex</strong> 作用到每一个分区并打印分区数</p>
<p>输入:分区索引，可迭代的类型T，输出:可迭代的类型U，返回RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitionsWithIndex</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">    f: (<span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],</span><br><span class="line">    preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>

<p><strong>glom()</strong> 按分区返回数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">glom</span></span>(): <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">T</span>]]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">listRDD.glom().collect().foreach(f=&gt;f.foreach(x =&gt; println(_)))</span><br></pre></td></tr></table></figure>

<p><strong>filter()</strong> 过滤</p>
<p>输入:输入一个函数T，输出:一个布尔值，返回一个RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p><strong>sample()</strong> 取样</p>
<p>输入:是否放回的布尔值，抽出来的概率，返回一个RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(</span><br><span class="line">      withReplacement: <span class="type">Boolean</span>,</span><br><span class="line">      fraction: <span class="type">Double</span>,</span><br><span class="line">      seed: <span class="type">Long</span> = <span class="type">Utils</span>.random.nextLong): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p><strong>distinct(x)</strong> 去重 ==&gt; numPartitions可指定分区</p>
<p>输入的必须是RDD，返回的也是一个RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distinct</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dist: <span class="type">RDD</span>[<span class="type">Int</span>] = listRDD3.distinct()</span><br></pre></td></tr></table></figure>

<p><strong>coalesce(x)</strong> 重点(小文件相关场景大量使用):   ==&gt; reduce数量决定最终输出的文件数，coalesce的作用是减少到指定分区数(x)，减少分区是窄依赖<br>==&gt; Spark作业遇到shuffle 会切分stage<br>输入一个分区数，返回一个重分区后的RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coalesce</span></span>(numPartitions: <span class="type">Int</span>, shuffle: <span class="type">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">               partitionCoalescer: <span class="type">Option</span>[<span class="type">PartitionCoalescer</span>] = <span class="type">Option</span>.empty)</span><br><span class="line">              (<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>)</span><br><span class="line">      : <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">listRDD2.coalesce(<span class="number">1</span>).getNumPartitions</span><br></pre></td></tr></table></figure>

<h3 id="双value算子"><a href="#双value算子" class="headerlink" title="双value算子"></a>双value算子</h3><p><strong>zip()</strong> 拉链 ==&gt; 不同分区和不同元素都不能用</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>, <span class="type">B</span>, <span class="type">That</span>](that: <span class="type">GenIterable</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, (<span class="type">A1</span>, <span class="type">B</span>), <span class="type">That</span>]): <span class="type">That</span></span><br></pre></td></tr></table></figure>

<p><strong>zipWithIndex()</strong> 打印拉链所在的分区</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zipWithIndex</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>, <span class="type">That</span>](<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, (<span class="type">A1</span>, <span class="type">Int</span>), <span class="type">That</span>]): <span class="type">That</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="type">List</span>(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>)</span><br><span class="line"><span class="keyword">val</span> age = <span class="type">List</span>(<span class="number">19</span>, <span class="number">26</span>, <span class="number">38</span>)</span><br><span class="line"><span class="keyword">val</span> zipRDD: <span class="type">List</span>[((<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Int</span>)] = name.zip(age).zipWithIndex</span><br></pre></td></tr></table></figure>

<p><strong>union()</strong> 并集 ==&gt; 分区数相加</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">union</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>, <span class="type">That</span>](that: <span class="type">GenSeq</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, <span class="type">B</span>, <span class="type">That</span>]): <span class="type">That</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = <span class="type">List</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">val</span> ints: <span class="type">List</span>[<span class="type">Int</span>] = list1.union(list2)</span><br></pre></td></tr></table></figure>

<p><strong>intersection()</strong> 交集</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersect</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](that: <span class="type">GenSeq</span>[<span class="type">B</span>]): <span class="type">Repr</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> inter: <span class="type">List</span>[<span class="type">Int</span>] = list1.intersect(list2)</span><br></pre></td></tr></table></figure>

<p><strong>subtract()</strong> 差集</p>
<p>输入的必须是RDD，返回的也是一个RDD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def subtract(other: RDD[T]): RDD[T]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sub: <span class="type">RDD</span>[<span class="type">Int</span>] = listRDD2.subtract(listRDD3)</span><br></pre></td></tr></table></figure>

<p><strong>cartesian()</strong> 笛卡尔积</p>
<p>输入的必须是RDD，返回的也是一个RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cartesian</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](other: <span class="type">RDD</span>[<span class="type">U</span>]): <span class="type">RDD</span>[(<span class="type">T</span>, <span class="type">U</span>)]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> car = listRDD2.cartesian(listRDD3)</span><br></pre></td></tr></table></figure>

<h3 id="kv算子"><a href="#kv算子" class="headerlink" title="kv算子"></a>kv算子</h3><p><strong>mapValues</strong> 得到所有ky的函数</p>
<p>输入:一个函数V，输出:一个值U，返回key为K，value为U的键函数对RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapValues</span></span>[<span class="type">U</span>](f: <span class="type">V</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">U</span>)]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">mapRDD.groupByKey().mapValues(_.sum).print()</span><br></pre></td></tr></table></figure>

<p><strong>sortBy(x)</strong> 降序指定-x，指定任意参数</p>
<p>输入键值对，指定排序的值，默认升序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBy</span></span>[<span class="type">K</span>](</span><br><span class="line">      f: (<span class="type">T</span>) =&gt; <span class="type">K</span>,</span><br><span class="line">      ascending: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">      numPartitions: <span class="type">Int</span> = <span class="keyword">this</span>.partitions.length)</span><br><span class="line">      (<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">K</span>], ctag: <span class="type">ClassTag</span>[<span class="type">K</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p><strong>sortByKey(true|false)</strong> 只能根据key排序</p>
<p>默认升序为true，可指定降序为false</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortByKey</span></span>(ascending: <span class="type">Boolean</span> = <span class="literal">true</span>, numPartitions: <span class="type">Int</span> = self.partitions.length)</span><br><span class="line">      : <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">mapRDD.map(x=&gt;(x._2,x._1)).sortByKey(<span class="literal">false</span>).map(x=&gt;(x._2,x._1)).print()</span><br></pre></td></tr></table></figure>

<p><strong>groupByKey</strong> 返回的kv对中的函数可迭代<br>    ==&gt;每个数据都经过shuffle，到reduce聚合，数据量大</p>
<p>可指定分区数，返回一个PariRDD，包含一个Key和一个可迭代的Value</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">mapRDD.groupByKey().mapValues(_.sum).print()</span><br></pre></td></tr></table></figure>

<p><strong>reduceByKey()</strong> 对value做指定的操作，直接返回函数<br>    ==&gt;map端有Combiner先进行了一次预聚合操作，减少了网络IO传输的数据量，所以比groupByKey快<br>    ==&gt;groupByKey的shuffle数据量明显多于reduceByKey，所以建议使用reduceByKey</p>
<p>输入两个值，输出一个值，返回一个PariRDD，包含一个明确的Key和一个明确的Value</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>

<p><strong>join()</strong></p>
<p>两个RDDjoin，返回一个PariRDD包含一个key，两个Value</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> mapRDD2 = sc.parallelize(<span class="type">List</span>((<span class="string">"zhaoliu"</span>, <span class="number">18</span>), (<span class="string">"zhangsan"</span>, <span class="number">22</span>), (<span class="string">"list"</span>, <span class="number">21</span>), (<span class="string">"wangwu"</span>, <span class="number">26</span>)))</span><br><span class="line"><span class="keyword">val</span> mapRDD3 = sc.parallelize(<span class="type">List</span>((<span class="string">"hongqi"</span>, <span class="string">"男"</span>), (<span class="string">"zhangsan"</span>, <span class="string">"男"</span>), (<span class="string">"list"</span>, <span class="string">"女"</span>), (<span class="string">"wangwu"</span>, <span class="string">"男"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">W</span>))]</span><br></pre></td></tr></table></figure>

<p><strong>leftOuterJoin</strong></p>
<p>两个RDDjoin，返回一个PariRDD包含一个key，一个确定的左表Value值，一个Option类型的右表Value值，即可能为空</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftOuterJoin</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">Option</span>[<span class="type">W</span>]))]</span><br></pre></td></tr></table></figure>

<p><strong>rightOuterJoin</strong></p>
<p>两个RDDjoin，返回一个PariRDD包含一个key，一个确定的右表Value值，一个Option类型的左表Value值，即可能为空</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightOuterJoin</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Option</span>[<span class="type">V</span>], <span class="type">W</span>))]</span><br></pre></td></tr></table></figure>

<p><strong>fullOuterJoin</strong></p>
<p>两个RDDjoin，返回一个PariRDD包含一个key，一个Option类型的右表Value值，一个Option类型的左表Value值，即都可能为空</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullOuterJoin</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Option</span>[<span class="type">V</span>], <span class="type">Option</span>[<span class="type">W</span>]))]</span><br></pre></td></tr></table></figure>

<p><strong>cogroup</strong> </p>
<p>作用和join类似，不同的是返回的结果是可迭代的，而join返回的是值，原因是join底层调用了cogroup</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W</span>]))]</span><br></pre></td></tr></table></figure>

<p>面试题：Spark Core 不使用distinct去重</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listRDD3 = sc.parallelize(<span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line">listRDD3.map(x=&gt;(x,<span class="literal">null</span>)).reduceByKey((x,y)=&gt;x).map(_._1).print()</span><br></pre></td></tr></table></figure>

<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p><strong>first()</strong></p>
<p>返回第一个元素，等于take(1)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(): <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p><strong>take()</strong>    </p>
<p>拿出指定的前N个元素,返回一个数组，结果为原始顺序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(num: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p><strong>count()</strong></p>
<p>返回元素数量，是个Long型</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(): <span class="type">Long</span> = sc.runJob(<span class="keyword">this</span>, <span class="type">Utils</span>.getIteratorSize _).sum</span><br></pre></td></tr></table></figure>

<p><strong>sum</strong> </p>
<p>求和，返回一个Double型</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(): <span class="type">Double</span></span><br></pre></td></tr></table></figure>

<p><strong>max</strong> </p>
<p>返回最大值，结果通过隐式转换排序过</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>()(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p><strong>min</strong></p>
<p>返回最小值，结果通过隐式转换排序过</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>()(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p><strong>top()</strong></p>
<p>先排降序再返回前N个元素组成的<strong>数组</strong>，字典序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span></span>(num: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>案例：升序排序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">listRDD.top(<span class="number">3</span>)(<span class="type">Ordering</span>.by(x =&gt; -x)).foreach(println)</span><br></pre></td></tr></table></figure>

<p><strong>takeOrdered</strong></p>
<p>先排降序再返回N个元素组成的<strong>数组</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeOrdered</span></span>(num: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>案例：升序排序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">listRDD.takeOrdered(<span class="number">3</span>)(<span class="type">Ordering</span>.by(x =&gt; x)).foreach(println)</span><br></pre></td></tr></table></figure>

<p><strong>reduce</strong></p>
<p>聚合，输入两个元素输出一个元素，类型相同</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(f: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure>

<p><strong>foreach</strong></p>
<p>循环输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foreach(f: T =&gt; Unit): Unit</span><br></pre></td></tr></table></figure>

<p><strong>foreachPartition</strong></p>
<p>分区循环输出</p>
<p>输入的是一个可迭代的类型T，输出Unit</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreachPartition</span></span>(f: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">Unit</span>): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">listRDD.foreachPartition(x=&gt;x.foreach(println))</span><br></pre></td></tr></table></figure>

<p><strong>countByKey</strong></p>
<p>根据key统计个数，用作<strong>检测数据倾斜</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countByKey</span></span>(): <span class="type">Map</span>[<span class="type">K</span>, <span class="type">Long</span>]</span><br></pre></td></tr></table></figure>

<p><strong>lookup</strong></p>
<p>根据map中的键来取出相应的值的，</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(key: <span class="type">K</span>): <span class="type">Seq</span>[<span class="type">V</span>]</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">mapRDD.lookup(<span class="string">"zhangsan"</span>).foreach(println)</span><br></pre></td></tr></table></figure>

</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/24/spark/1/">编译Spark&amp;Idea配置Spark环境&amp;RDD五大特点&amp;Spark参数管理&amp;数据的读写</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>编译Spark</li>
<li>Idea配置Spark环境</li>
<li>RDD五大特点</li>
<li>Spark参数管理</li>
<li>数据的读写</li>
</ol>
<h2 id="编译Spark"><a href="#编译Spark" class="headerlink" title="编译Spark"></a>编译Spark</h2><p>作为一个Spark玩的6的攻城狮，第一步就是要学会如何编译Spark</p>
<ol>
<li><p>下载spark源码: <a href="http://spark.apache.org/" target="_blank" rel="noopener">官网</a>或者<a href="https://github.com/apache/spark" target="_blank" rel="noopener">github</a></p>
</li>
<li><p>查看官网<a href="看官方文档http://spark.apache.org/docs/latest/building-spark.html">编译文档</a>，切记注意版本号，不同版本号编译方式区别很大</p>
</li>
<li><p>修改相关配置</p>
<ol>
<li><p>注释掉make-distribution.sh脚本中的128行左右一下，使用固定的版本替代</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">VERSION=2.4.5</span><br><span class="line">SCALA_VERSION=2.12.10</span><br><span class="line">SPARK_HADOOP_VERSION=2.6.0-cdh5.16.2</span><br><span class="line">SPARK_HIVE=1</span><br></pre></td></tr></table></figure>

<p>替代==&gt;</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#VERSION=$("$MVN" help:evaluate -Dexpression=project.version $@ 2&gt;/dev/null\</span><br><span class="line">#    | grep -v "INFO"\</span><br><span class="line">#    | grep -v "WARNING"\</span><br><span class="line">#    | tail -n 1)</span><br><span class="line">#SCALA_VERSION=$("$MVN" help:evaluate -Dexpression=scala.binary.version $@ 2&gt;/dev/null\</span><br><span class="line">#    | grep -v "INFO"\</span><br><span class="line">#    | grep -v "WARNING"\</span><br><span class="line">#    | tail -n 1)</span><br><span class="line">#SPARK_HADOOP_VERSION=$("$MVN" help:evaluate -Dexpression=hadoop.version $@ 2&gt;/dev/null\</span><br><span class="line">#    | grep -v "INFO"\</span><br><span class="line">#    | grep -v "WARNING"\</span><br><span class="line">#    | tail -n 1)</span><br><span class="line">#140 #SPARK_HIVE=$("$MVN" help:evaluate -Dexpression=project.activeProfiles -pl sql/hive $@ 2&gt;/dev/null\</span><br><span class="line">#    | grep -v "INFO"\</span><br><span class="line">#    | grep -v "WARNING"\</span><br><span class="line">#    | fgrep --count "<span class="tag">&lt;<span class="name">id</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">id</span>&gt;</span>";\</span><br><span class="line">#    # Reset exit status to 0, otherwise the script stops here if the last grep finds nothing\</span><br><span class="line">#    # because we use "set -o pipefail"</span><br><span class="line">#    echo -n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改maven仓库地址，在253行左右，pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Maven Repository</span><br><span class="line"><span class="comment">&lt;!--&lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">加上cdh的下载地址</span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>开始编译</p>
<p>maven编译前执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">export MAVEN_OPTS=<span class="string">"-Xmx2g -XX:ReservedCodeCacheSize=1g"</span></span><br></pre></td></tr></table></figure>

<p>make-distribution.sh编译不需要执行，我们这里使用make-distribution.sh编译，它的脚本自动执行了这句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./dev/change-scala-version.sh <span class="number">2.12</span></span><br><span class="line">./dev/make-distribution.sh --name <span class="number">2.6</span><span class="number">.0</span>-cdh5<span class="number">.16</span><span class="number">.2</span> --tgz -Pyarn -Phive -Phive-thriftserver -Pscala-<span class="number">2.12</span> -Phadoop-<span class="number">2.6</span> -Dhadoop.version=<span class="number">2.6</span><span class="number">.0</span>-cdh5<span class="number">.16</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看生成的jar包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/home/hadoop/app/spark-<span class="number">2.4</span><span class="number">.5</span>/spark-<span class="number">2.4</span><span class="number">.5</span>-bin-<span class="number">2.6</span><span class="number">.0</span>-cdh5<span class="number">.16</span><span class="number">.2</span>.tgz</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Idea配置Spark环境"><a href="#Idea配置Spark环境" class="headerlink" title="Idea配置Spark环境"></a>Idea配置Spark环境</h2><ol>
<li><p>idae引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hadoop.version</span>&gt;</span>2.6.0-cdh5.16.2<span class="tag">&lt;/<span class="name">hadoop.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.12.10<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scala.tools.version</span>&gt;</span>2.12<span class="tag">&lt;/<span class="name">scala.tools.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spark.version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">spark.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hadoop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.spark/spark-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_$&#123;scala.tools.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置阿里云和cdh的仓库地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>cloudera<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.cloudera.com/artifactory/cloudera-repos/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否开启发布版构件下载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否开启快照版构件下载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="RDD五大特点"><a href="#RDD五大特点" class="headerlink" title="RDD五大特点"></a>RDD五大特点</h2><p>先看官方介绍:</p>
<p>弹性分布式数据集(RDD)，是Spark的基本抽象。表示可以并行操作的不可变的、分区的元素集合。这个类包含所有RDDS上可用的基本操作，如<code>map</code>、<code>filter</code>和<code>filter</code>。</p>
<p><code>[[org.apache.spark.rdd.PairRDDFunctions]]</code>，包含仅在键值对的RDDs上可用的操作，如<code>groupByKey</code> 和<code>join</code> ; </p>
<p><code>[[org.apache.spark.rdd.DoubleRDDFunctions]]</code> ，包含仅在双精度的RDDs上可用的操作;</p>
<p><code>[[org.apache.spark.rdd.SequenceFileRDDFunctions]]</code>，包含可在RDDs上使用的操作，这些操作可以保存为序列文件。</p>
<p>所有的操作都可以通过隐式转换的方式在任何正确类型的RDD上自动使用(例如RDD[(Int, Int)]);</p>
<p>RDD: resilient distributed dataset(弹性分布式数据集)，</p>
<ol>
<li><p>弹性表示容错</p>
</li>
<li><p>分布式表示分区</p>
</li>
<li><p>数据集表示集</p>
</li>
</ol>
<p><strong>每个RDD有五个主要特征:</strong></p>
<ol>
<li>一个RDD由很多partition构成(block块对应partition)，在spark中，有多少partition就对应有多少个task来执行。</li>
<li>对RDD做计算，相当于对RDD的每个partition或split做计算</li>
<li>RDD之间有依赖关系，可溯源，容错机制</li>
<li>如果RDD里面存的数据是key-value形式，则可以进行重新分区</li>
<li>最优位置计算，也就是数据的本地性，移动计算而不是移动数据。</li>
</ol>
<p>RDD是一个顶级的抽象类，它有五个抽象方法，分别实现了这五个特性</p>
<ol>
<li><p>分区</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implemented by subclasses to return the set of partitions in this RDD. This method will only</span></span><br><span class="line"><span class="comment"> * be called once, so it is safe to implement a time-consuming computation in it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The partitions in this array must satisfy the following property:</span></span><br><span class="line"><span class="comment"> *   `rdd.partitions.zipWithIndex.forall &#123; case (partition, index) =&gt; partition.index == index &#125;`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartitions</span></span>: <span class="type">Array</span>[<span class="type">Partition</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * :: DeveloperApi ::</span></span><br><span class="line"><span class="comment">  * Implemented by subclasses to compute a given partition.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implemented by subclasses to return how this RDD depends on parent RDDs. This method will only</span></span><br><span class="line"><span class="comment">  * be called once, so it is safe to implement a time-consuming computation in it.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">getDependencies</span></span>: <span class="type">Seq</span>[<span class="type">Dependency</span>[_]] = deps</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新分区</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Optionally overridden by subclasses to specify how they are partitioned. */</span></span><br><span class="line"><span class="meta">@transient</span> <span class="keyword">val</span> partitioner: <span class="type">Option</span>[<span class="type">Partitioner</span>] = <span class="type">None</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最优位置</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Optionally overridden by subclasses to specify placement preferences.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">getPreferredLocations</span></span>(split: <span class="type">Partition</span>): <span class="type">Seq</span>[<span class="type">String</span>] = <span class="type">Nil</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Spark参数管理"><a href="#Spark参数管理" class="headerlink" title="Spark参数管理"></a>Spark参数管理</h2><ol>
<li><p>如果想要定义自己的参数传递到spark中去，一定要以<code>spark.</code>开头</p>
</li>
<li><p>如果想要获取spark中的参数的值，使用<code>sc.getConf.get(key)</code></p>
</li>
</ol>
<h2 id="数据的读写"><a href="#数据的读写" class="headerlink" title="数据的读写"></a>数据的读写</h2><ol>
<li><p>读本地数据：<br><code>sc.textFile(&quot;file://&quot;)</code> 需要添加<code>file://</code></p>
</li>
<li><p>读hdfs数据：<br><code>sc.textFile(&quot;&quot;)</code>  默认读hdfs 不需要加前缀<br>注意：textFile() 可以使用通配符匹配目录、指定文件、指定文件夹</p>
</li>
<li><p>wholeTextFiles()</p>
<p>如果使用的是wholeTextFiles() ，它会返回路径+内容</p>
</li>
<li><p>写本地</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">rdd.saveAsTestFile(<span class="string">"path"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>写HDFS需要配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setProperty(<span class="string">"HADOOP_USER_NAME"</span>, <span class="string">"hadoop"</span>);</span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">conf.set(<span class="string">"fs.defaultFS"</span>, <span class="string">"hdfs://192.168.91.10:9000"</span>);</span><br><span class="line">conf.set(<span class="string">"dfs.client.use.datanode.hostname"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩写</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">saveAsTestFile(out,classOf[<span class="type">BZip2Codec</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象写</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span>(<span class="params">name:<span class="type">String</span>,age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">p1</span> </span>= (<span class="string">"张三"</span>,<span class="number">18</span>)</span><br><span class="line"><span class="keyword">val</span> p2 = (<span class="string">"李四"</span>,<span class="number">21</span>)</span><br><span class="line">parallelize(<span class="type">List</span>(p1,p2)).saveAsObjectFile(<span class="string">"out"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象读</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">sc.objectFile[<span class="type">Persion</span>](<span class="string">"out"</span>).collect().foreach(println)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/23/scala/4/">Scala之闭包&amp;柯里化</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Scala/">Scala</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Scala/">Scala</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>闭包</li>
<li>方法与函数的区别</li>
<li>柯里化</li>
</ol>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>说到柯里化必先说起闭包，我们先不关心闭包和柯里化是什么，而是看一个transformation</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> init:<span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = list.foldLeft[<span class="type">Int</span>](init)((x,y) =&gt; &#123;</span><br><span class="line">    println(<span class="string">s"init = <span class="subst">$init</span> | x = <span class="subst">$x</span> | y = <span class="subst">$y</span>"</span> )</span><br><span class="line">    x+y</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">println(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">init = <span class="number">10</span> | x = <span class="number">10</span> | y = <span class="number">1</span></span><br><span class="line">init = <span class="number">10</span> | x = <span class="number">11</span> | y = <span class="number">2</span></span><br><span class="line">init = <span class="number">10</span> | x = <span class="number">13</span> | y = <span class="number">3</span></span><br><span class="line">init = <span class="number">10</span> | x = <span class="number">16</span> | y = <span class="number">4</span></span><br><span class="line">init = <span class="number">10</span> | x = <span class="number">20</span> | y = <span class="number">5</span></span><br><span class="line">init = <span class="number">10</span> | x = <span class="number">25</span> | y = <span class="number">6</span></span><br><span class="line"><span class="number">31</span></span><br></pre></td></tr></table></figure>

<p>从结果来看 <code>foldLeft</code> 需要三个参数，<code>init</code>初始值，变量x，变量y，然后将他们累加(不考虑其他运算规则)</p>
<p>现在我们来看看闭包的解释：</p>
<ol>
<li><p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。</p>
</li>
<li><p>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p>
</li>
</ol>
<p><code>val i = list.foldLeft[Int](init)((x,y))</code> 是一个闭包，返回值依赖声明在函数外的<code>init</code></p>
<p>如果我们把<code>foldLeft[Int](init)((x,y))</code> 拆分成两个函数的话，一个是有明确参数引用的 <code>foldLeft[Int](init)</code>， 另外一个是匿名函数<code>((x,y))</code>，如果我们观察仔细的话，会发现上面的代码中，第一次输出的结果 <code>init = x</code>  我们就可以简单的认为匿名函数<code>((x,y))</code>访问了<code>flodLeft</code>中的局部变量<code>init</code> ,事实上，<code>x</code>第一次的值就是拿的<code>init</code> 。</p>
<p>我们现在可以总结闭包就是在函数外面声明了一个变量，在函数中引用了这个变量，就称之为闭包，其他函数可以依赖闭包(函数)中的这个变量。由于闭包是把外部变量包了进来，所以这个变量的生命周期和闭包的生命周期一致。</p>
<p>最后在看一个案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> factor = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> multiplier = (i:<span class="type">Int</span>) =&gt; i * factor</span><br><span class="line">println(multiplier(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>没错，<strong>函数的返回值依赖于声明在函数外部的一个或多个变量就是闭包。</strong></p>
<h2 id="方法与函数的区别"><a href="#方法与函数的区别" class="headerlink" title="方法与函数的区别"></a>方法与函数的区别</h2><p>还需要讲一下方法与函数区别，因为柯里化指的是将原来接受两个参数的方法变成新的接受一个参数的函数的过程。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">method</span> </span>= (x:<span class="type">Int</span>,y:<span class="type">Int</span>) =&gt; x+y</span><br><span class="line">method: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>	<span class="comment">//方法</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> func = (x:<span class="type">Int</span>,y:<span class="type">Int</span>) =&gt; x+y</span><br><span class="line">func: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = $$<span class="type">Lambda</span>$<span class="number">1307</span>/<span class="number">1309775952</span>@<span class="number">32</span>a1aabf	<span class="comment">//函数</span></span><br></pre></td></tr></table></figure>

<ol>
<li>首先应该要知道=号右边的内容 <code>(x: Int, y: Int) =&gt; x + y</code>是一个函数体。</li>
<li>方法只能用def修饰，函数可以用def修饰，也可以用val修饰。</li>
<li>当函数用def来接收之后，不再显示为function，转换为方法。</li>
<li>方法可以省略参数，函数不可以。</li>
<li>函数可以作为方法的参数。</li>
</ol>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>理解闭包后，我们看一个复杂的闭包案例：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">addBase</span></span>(x:<span class="type">Int</span>) = (y:<span class="type">Int</span>) =&gt; x+y</span><br><span class="line">addBase: (x: <span class="type">Int</span>)<span class="type">Int</span> =&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>

<p>首先我们看到<code>addBase</code>是一个方法，<code>(y:Int) =&gt; x+y</code>是一个函数体，下面我们试试执行<code>addBase(x:Int)</code></p>
<p>会返回什么?</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; addBase(<span class="number">3</span>)</span><br><span class="line">res27: <span class="type">Int</span> =&gt; <span class="type">Int</span> = $$<span class="type">Lambda</span>$<span class="number">1308</span>/<span class="number">761477414</span>@<span class="number">553</span>f7b1e</span><br></pre></td></tr></table></figure>

<p>返回了一个函数，现在我们明白了，<code>addBase(x:Int)</code>是一个<strong>方法</strong>，在传入具体的值后，返回了一个具体的<strong>函数</strong></p>
<p>到现在 “=” 号后面的 <code>(y:Int) =&gt; x+y</code> 这段还没有使用到，但是我们知道 “=” 号后面是一个函数体，给函数中传入y 返回 x+y? 我们试试。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> addThree = addBase(<span class="number">3</span>)	<span class="comment">//使用个变量接收函数</span></span><br><span class="line">addThree: <span class="type">Int</span> =&gt; <span class="type">Int</span> = $$<span class="type">Lambda</span>$<span class="number">1308</span>/<span class="number">761477414</span>@<span class="number">65e1</span>c98c</span><br><span class="line">scala&gt; addThree(<span class="number">4</span>)	<span class="comment">//传入4</span></span><br><span class="line">res29: <span class="type">Int</span> = <span class="number">7</span>	<span class="comment">//输出7</span></span><br></pre></td></tr></table></figure>

<p>等等。。。这就是一个闭包啊，x=3是外部传入的给函数<code>addBase</code>的，这时的<code>addBase</code>就是函数，它的内部维护了一个变量x=3，这时另外一个函数<code>addThree</code> 在输出x+y前，访问了<code>addBase</code>中的x=3。</p>
<p>完全符合闭包的定义规则，<strong>函数的返回值依赖于声明在函数外部的一个或多个变量就是闭包</strong>。</p>
<p>上面的<code>addBase</code>方法使我们一次传入一个3一次传入一个4，那么有没有办法一次传入呢？</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; addBase(<span class="number">3</span>)(<span class="number">4</span>)</span><br><span class="line">res34: <span class="type">Int</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>没错，这就是柯里化，<strong>柯里化指的是将原来接受两个参数的方法变成新的接受一个参数的函数的过程。并且新的函数返回一个以原有第二个参数作为参数的函数。</strong></p>
<p>我们发现了上面闭包的代码其实就是柯里化的过程</p>
<p>现在我们总结下柯里化是什么?</p>
<ol>
<li><p>柯里化指的是将原来接受两个参数的方法变成新的接受一个参数的函数的过程。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">sum1</span></span>(x:<span class="type">Int</span>): <span class="type">Int</span> =&gt; <span class="type">Int</span> = (y:<span class="type">Int</span>)=&gt;x+y</span><br><span class="line">sum1: (x: <span class="type">Int</span>)<span class="type">Int</span> =&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> res1 = sum1(<span class="number">3</span>)</span><br><span class="line">res1: <span class="type">Int</span> =&gt; <span class="type">Int</span> = $$<span class="type">Lambda</span>$<span class="number">1321</span>/<span class="number">962341885</span>@<span class="number">41</span>d283de</span><br><span class="line"></span><br><span class="line">scala&gt; res1(<span class="number">4</span>)</span><br><span class="line">res38: <span class="type">Int</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>==&gt;上面是接受两个参数，下面是接受一个参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">sum2</span></span>(x:<span class="type">Int</span>)(y:<span class="type">Int</span>): <span class="type">Int</span> = x+y</span><br><span class="line">sum2: (x: <span class="type">Int</span>)(y: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; sum2(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">res39: <span class="type">Int</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新的函数返回一个以原有第二个参数作为参数的函数。</p>
<p>意思就是原来要分两步做的事情，现在分一步就做好了，底层自动调用和返回。在这个过程中，使用了闭包。</p>
</li>
</ol>
<p>懵逼之余。。。返回最开始的<code>foldLeft</code>案例，看<code>foldLeft</code> 方法源码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(<span class="meta">@deprecatedName</span>(<span class="symbol">'f</span>) op: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br></pre></td></tr></table></figure>

<p>这其实就是一个柯里化应用</p>
<ol>
<li><p>折叠操作是一个递归的过程，将上一次的计算结果代入到函数中 </p>
</li>
<li><p>作为结果的参数在<code>foldLeft</code>是第一个参数，下个参数在<code>foldRight</code>是第二个参数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> i = list.foldLeft[<span class="type">Int</span>](init)(_+_)</span><br></pre></td></tr></table></figure>

<p>==&gt;<code>init</code> = 10 作为初始值只用一次，然后(_+_)累加，累加的结果放在第一个参数位置</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span> | y = <span class="number">1</span></span><br><span class="line">x = <span class="number">11</span> | y = <span class="number">2</span></span><br><span class="line">x = <span class="number">13</span> | y = <span class="number">3</span></span><br><span class="line">x = <span class="number">16</span> | y = <span class="number">4</span></span><br><span class="line">x = <span class="number">20</span> | y = <span class="number">5</span></span><br><span class="line">x = <span class="number">25</span> | y = <span class="number">6</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><p>柯里化技术在提高适用性还是在延迟执行或者固定易变因素等方面有着重要重要的作用，加上scala语言本身就是推崇简洁编码，使得同样功能的函数在定义与转换的时候会更加灵活多样。另外在Spark的源码中有大量运用scala柯里化技术的情况，需要掌握好该技术才能看得懂相关的源代码。</p>
</li>
<li><p>在scala柯里化中，闭包也发挥着重要的作用。所谓的闭包就是变量出了函数的定义域外在其他代码块还能其作用，这样的情况称之为闭包。就上述讨论的案例而言，如果没有闭包作用，那么转换后函数其实返回的匿名函数是无法在与第一个参数x相关结合的，自然也就无法保证其所实现的功能是跟原来一致的。</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/20/spark/3/">Spark之WC产生多少个RDD</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Spark/">Spark</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Spark/">Spark</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>WC产生多少个RDD</li>
</ol>
<h2 id="WC产生多少个RDD"><a href="#WC产生多少个RDD" class="headerlink" title="WC产生多少个RDD"></a>WC产生多少个RDD</h2><p>一句标准的WC产生了多少个RDD？</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result = sc.textFile(<span class="string">"E:\\Java\\spark\\tunan-spark\\tunan-spark-core\\data\\wc.txt"</span>).flatMap(_.split(<span class="string">"\t"</span>)).map((_, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line">result.saveAsTextFile(<span class="string">"out"</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用<code>toDebugString</code>方法查看RDD的数量</p>
<p>result.toDebugString(不包括<code>saveAsTextFile</code>方法)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>) <span class="type">ShuffledRDD</span>[<span class="number">4</span>] at reduceByKey at wordcount.scala:<span class="number">11</span> []</span><br><span class="line"> +-(<span class="number">2</span>) <span class="type">MapPartitionsRDD</span>[<span class="number">3</span>] at map at wordcount.scala:<span class="number">11</span> []</span><br><span class="line">    |  <span class="type">MapPartitionsRDD</span>[<span class="number">2</span>] at flatMap at wordcount.scala:<span class="number">11</span> []</span><br><span class="line">    |  <span class="type">E</span>:\<span class="type">Java</span>\spark\tunan-spark\tunan-spark-core\data\wc.txt <span class="type">MapPartitionsRDD</span>[<span class="number">1</span>] at textFile at wordcount.scala:<span class="number">11</span> []</span><br><span class="line">    |  <span class="type">E</span>:\<span class="type">Java</span>\spark\tunan-spark\tunan-spark-core\data\wc.txt <span class="type">HadoopRDD</span>[<span class="number">0</span>] at textFile at wordcount.scala:<span class="number">11</span> []</span><br></pre></td></tr></table></figure>

<p>上面的方法中：textFile算子中有HadoopRDD和MapPartitionsRDD；flatMap方法有MapPartitionsRDD；map方法有MapPartitionsRDD；reduceByKey方法有ShuffledRDD。</p>
<p>这里一共是5个RDD，如果加上saveAsTextFile方法中的一个MapPartitionsRDD，则一共是6个RDD，如果加上sort方法也是一样的算法。</p>
</li>
<li><p>查看源码的方式计算RDD的数量</p>
<p><code>sc.textFile(&quot;...&quot;)</code></p>
<p>textFile的作用是从HDFS、本地文件系统(在所有节点上可用)或任何hadoop支持的文件系统URI读取文本文件，并将其作为字符串的RDD返回。</p>
<p>path：受支持的文件系统上的文本文件的路径</p>
<p>minPartitions：建议的结果RDD的最小分区数，默认值是2</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textFile</span></span>(</span><br><span class="line">    path: <span class="type">String</span>,</span><br><span class="line">    minPartitions: <span class="type">Int</span> = defaultMinPartitions): <span class="type">RDD</span>[<span class="type">String</span>] = withScope &#123;</span><br><span class="line">    assertNotStopped()</span><br><span class="line">    hadoopFile(path, classOf[<span class="type">TextInputFormat</span>], classOf[<span class="type">LongWritable</span>], classOf[<span class="type">Text</span>],</span><br><span class="line">               minPartitions).map(pair =&gt; pair._2.toString).setName(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在textFile值调用了hadoopFile方法，该方法传入了<code>path</code>，<code>TextInputFormat</code>(也就是mapreduce中的FileInputFormat方法，特点是按行读取)，<code>LongWritable</code>(mapreduce计算中的key，记录的是offset)，<code>Text</code>(mapreduce计算中的key，记录的是每行的内容)，<code>minPartitions</code>(分区数)，然后返回一个tuple，tuple记录的是key和value，我们这里做了一个处理，<code>.map(pair =&gt; pair._2.toString)</code>方法让结果只有内容，而忽略掉了offset。</p>
<p>继续看hadoopFile的源码</p>
<p>使用任意的InputFormat获取Hadoop文件的RDD，返回一个RDD类型的包含(offset，value)的元组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hadoopFile</span></span>[<span class="type">K</span>, <span class="type">V</span>](</span><br><span class="line">      path: <span class="type">String</span>,		<span class="comment">//目录下的输入数据文件，路径可以用逗号分隔路径作为输入列表</span></span><br><span class="line">      inputFormatClass: <span class="type">Class</span>[_ &lt;: <span class="type">InputFormat</span>[<span class="type">K</span>, <span class="type">V</span>]],	<span class="comment">//要读取的数据的存储格式</span></span><br><span class="line">      keyClass: <span class="type">Class</span>[<span class="type">K</span>],	<span class="comment">//key的类型</span></span><br><span class="line">      valueClass: <span class="type">Class</span>[<span class="type">V</span>],	<span class="comment">//value的类型</span></span><br><span class="line">      minPartitions: <span class="type">Int</span> = defaultMinPartitions): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]	<span class="comment">//分区数，默认值是2</span></span><br><span class="line">		= withScope &#123;assertNotStopped()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一种强制加载hdfs-site.xml的方法</span></span><br><span class="line">    <span class="type">FileSystem</span>.getLocal(hadoopConfiguration)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个Hadoop的配置文件大概10 KB,这是相当大的,所以广播它</span></span><br><span class="line">    <span class="keyword">val</span> confBroadcast = broadcast(<span class="keyword">new</span> <span class="type">SerializableConfiguration</span>(hadoopConfiguration))</span><br><span class="line">    <span class="keyword">val</span> setInputPathsFunc = (jobConf: <span class="type">JobConf</span>) =&gt; 						<span class="type">FileInputFormat</span>.setInputPaths(jobConf, path)	<span class="comment">//设置作业环境</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">HadoopRDD</span>(	<span class="comment">//创建一个HadoopRDD</span></span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      confBroadcast,	<span class="comment">//广播配置</span></span><br><span class="line">      <span class="type">Some</span>(setInputPathsFunc),	<span class="comment">//作业环境也许可能出错，所以使用Some()</span></span><br><span class="line">      inputFormatClass,	<span class="comment">//读取文件的格式化类</span></span><br><span class="line">      keyClass,	<span class="comment">//key类型</span></span><br><span class="line">      valueClass,	<span class="comment">//value类型</span></span><br><span class="line">      minPartitions).setName(path)	<span class="comment">//分片数</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因为Hadoop的RecordReader类为每条记录使用相同的Writable对象，直接保存或者直接使用aggregation或者shuffle将会产生很多对同一个对象的引用，所以我们保存、排序或者聚合操作writable对象前，要使用map方法做一个映射。</p>
<p>回到上一步的textFile方法中，Hadoop的返回值是一个包含offset和value的元组，我们只需要内容，所以使用map方法做一个映射，只拿元祖中的value即可</p>
<p><code>.map(pair =&gt; pair._2.toString)</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)	<span class="comment">//初始化检查</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))	==&gt;(context, pid, iter) ==&gt; hadoopRDD, 分区<span class="type">ID</span>, 迭代器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该map方法又创建一个MapPartitionsRDD，将map算子应用于每个分区的子RDD。这应用到了RDD五大特性之一的，对每个RDD做计算，实际上是对每个RDD的partition或者split做计算。由于MapPartitionsRDD较为复杂，暂不解析。</p>
<p><strong><em>到此，textFile产生了两个RDD，分别是HadoopRDD和MapPartitionsRDD。共两个RDD</em></strong></p>
</li>
</ol>
<p>   <code>.flatMap(_.split(&quot;\t&quot;))</code></p>
<p>   flatMap首先作用在每一个元素上，然后将结果扁平化，最后返回一个新的RDD</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">TraversableOnce</span>[<span class="type">U</span>]): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.flatMap(cleanF))	<span class="comment">//对RDD的所有分区做计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong><em>到此，flatMap产生了一个RDD，是MapPartitionsRDD。共三个RDD</em></strong></p>
<p>   <code>.map((_, 1))</code></p>
<p>   将map作用在每一个元素上，然后返回一个新的RDD</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong><em>到此，map产生了一个RDD，是MapPartitionsRDD。共四个RDD</em></strong></p>
<p>   <code>.reduceByKey(_ + _)</code></p>
<p>   使用联合和交换reduce函数合并每个键的值。<strong>在将结果发送到reduce之前，这也将在每个mapper上本地执行合并，类似于MapReduce中的“combiner”。</strong>输出将使用现有分区器/并行度级别进行哈希分区。</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = self.withScope &#123;</span><br><span class="line">    reduceByKey(defaultPartitioner(self), func)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   继续查看<code>reduceByKey(defaultPartitioner(self), func)</code>方法</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(partitioner: <span class="type">Partitioner</span>, func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = self.withScope &#123;</span><br><span class="line">    combineByKeyWithClassTag[<span class="type">V</span>]((v: <span class="type">V</span>) =&gt; v, func, func, partitioner)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   继续查看<code>combineByKeyWithClassTag[V]((v: V) =&gt; v, func, func, partitioner)</code>方法</p>
<p>   这是一个具体干活的方法，它使用一组自定义聚合函数组合每个键的元素。将RDD[(K, V)]转换为RDD[(K, C)]类型的结果，用于“组合类型”C。这是一个复杂的方法，暂不做解析。</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combineByKeyWithClassTag</span></span>[<span class="type">C</span>](</span><br><span class="line">    createCombiner: <span class="type">V</span> =&gt; <span class="type">C</span>,</span><br><span class="line">    mergeValue: (<span class="type">C</span>, <span class="type">V</span>) =&gt; <span class="type">C</span>,</span><br><span class="line">    mergeCombiners: (<span class="type">C</span>, <span class="type">C</span>) =&gt; <span class="type">C</span>,</span><br><span class="line">    partitioner: <span class="type">Partitioner</span>,</span><br><span class="line">    mapSideCombine: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">    serializer: <span class="type">Serializer</span> = <span class="literal">null</span>)(<span class="keyword">implicit</span> ct: <span class="type">ClassTag</span>[<span class="type">C</span>]): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">C</span>)] = self.withScope &#123;</span><br><span class="line">    require(mergeCombiners != <span class="literal">null</span>, <span class="string">"mergeCombiners must be defined"</span>) <span class="comment">// required as of Spark 0.9.0</span></span><br><span class="line">    <span class="keyword">if</span> (keyClass.isArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapSideCombine) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"Cannot use map-side combining with array keys."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (partitioner.isInstanceOf[<span class="type">HashPartitioner</span>]) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"HashPartitioner cannot partition array keys."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> aggregator = <span class="keyword">new</span> <span class="type">Aggregator</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>](</span><br><span class="line">        self.context.clean(createCombiner),</span><br><span class="line">        self.context.clean(mergeValue),</span><br><span class="line">        self.context.clean(mergeCombiners))</span><br><span class="line">    <span class="keyword">if</span> (self.partitioner == <span class="type">Some</span>(partitioner)) &#123;</span><br><span class="line">        self.mapPartitions(iter =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> context = <span class="type">TaskContext</span>.get()</span><br><span class="line">            <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, aggregator.combineValuesByKey(iter, context))</span><br><span class="line">        &#125;, preservesPartitioning = <span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ShuffledRDD</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>](self, partitioner)	<span class="comment">//创建ShuffledRDD</span></span><br><span class="line">        .setSerializer(serializer)</span><br><span class="line">        .setAggregator(aggregator)</span><br><span class="line">        .setMapSideCombine(mapSideCombine)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong><em>到此，reduceByKey产生了一个RDD，是ShuffledRDD。共五个RDD</em></strong></p>
<p>   <code>.saveAsTextFile(&quot;...&quot;)</code></p>
<p>   将每个元素使用字符串表示形式，将此RDD保存为文本文件。</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsTextFile</span></span>(path: <span class="type">String</span>): <span class="type">Unit</span> = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> nullWritableClassTag = implicitly[<span class="type">ClassTag</span>[<span class="type">NullWritable</span>]]	</span><br><span class="line">    <span class="keyword">val</span> textClassTag = implicitly[<span class="type">ClassTag</span>[<span class="type">Text</span>]]</span><br><span class="line">    <span class="keyword">val</span> r = <span class="keyword">this</span>.mapPartitions &#123; iter =&gt;	<span class="comment">//注意这里</span></span><br><span class="line">        <span class="keyword">val</span> text = <span class="keyword">new</span> <span class="type">Text</span>()</span><br><span class="line">        iter.map &#123; x =&gt;</span><br><span class="line">            text.set(x.toString)</span><br><span class="line">            (<span class="type">NullWritable</span>.get(), text)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RDD</span>.rddToPairRDDFunctions(r)(nullWritableClassTag, textClassTag, <span class="literal">null</span>)</span><br><span class="line">    .saveAsHadoopFile[<span class="type">TextOutputFormat</span>[<span class="type">NullWritable</span>, <span class="type">Text</span>]](path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   通过每次将一个分区的数据以流的方式传入到HDFS中再关闭流</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitions</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">    f: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],</span><br><span class="line">    preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">  <span class="keyword">val</span> cleanedF = sc.clean(f)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>(	<span class="comment">//创建MapPartitionsRDD</span></span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    (context: <span class="type">TaskContext</span>, index: <span class="type">Int</span>, iter: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; cleanedF(iter),</span><br><span class="line">    preservesPartitioning)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <del><strong><em>到此，saveAsTextFile产生了一个RDD，是MapPartitionsRDD。共六个RDD</em></strong></del></p>
<p>   <em>20200325更新：</em></p>
<p>   在最后的saveAsTextFile()算子中，我们忽略了一个RDD，它就是是<code>PairRDDFunctions</code>，这个RDD是通过RDD隐式转换过来的</p>
   <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">rddToPairRDDFunctions</span></span>[<span class="type">K</span>, <span class="type">V</span>](rdd: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)])</span><br><span class="line">(<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>], vt: <span class="type">ClassTag</span>[<span class="type">V</span>], ord: <span class="type">Ordering</span>[<span class="type">K</span>] = <span class="literal">null</span>): <span class="type">PairRDDFunctions</span>[<span class="type">K</span>, <span class="type">V</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">PairRDDFunctions</span>(rdd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong><em>修正后的 RDD数量是 7个</em></strong></p>
<ol start="3">
<li>总结：使用toDebugString方法，简单的看到了生成了多少个RDD，通过阅读源码的方式，详细了解到了生成了多少个RDD，他们分别做了什么事情。我们这个流程生成了<del>6</del>7个RDD，如果对结果进行排序，也是相同的方法可以看到答案。</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/19/scala/3/">Scala之var和val的比较&amp;lazy懒加载</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Scala/">Scala</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Scala/">Scala</a></span><div class="content"><h3 id="1：内容是否可变：val修饰的是不可变的，var修饰是可变的"><a href="#1：内容是否可变：val修饰的是不可变的，var修饰是可变的" class="headerlink" title="1：内容是否可变：val修饰的是不可变的，var修饰是可变的"></a>1：内容是否可变：val修饰的是不可变的，var修饰是可变的</h3><p>下面看一段代码，你猜是否有错误</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ValAndVar</span> </span>&#123;</span><br><span class="line">    <span class="comment">//val 修饰由于不可变性必须初始化</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">LOVE</span>:<span class="type">String</span> = _</span><br><span class="line">    <span class="keyword">var</span> <span class="type">SEX</span>:<span class="type">String</span>  = _</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> name = <span class="string">"tunan"</span></span><br><span class="line">        <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//val 修饰由于不可变性不能重新赋值</span></span><br><span class="line">        name = <span class="string">"zhangsan"</span></span><br><span class="line">        age = <span class="number">19</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实的结果:</p>
<p><img src="https://yerias.github.io/scala_img/val%E5%92%8Cvar%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7%E6%AF%94%E8%BE%83.jpg" alt="val和var的可变性比较"></p>
<ol>
<li>val是不可变的，所以修饰的变量必须初始化</li>
<li>val是不可变的，所以修饰的变量不能重新赋值</li>
<li>val是不可变的，所以是多线程安全的</li>
<li>val是不可变的，不用担心会改变它修饰的对象的状态</li>
<li>val是不可变的，增强了代码的可读性，不用担心它的内容发生变化</li>
<li>var是可变的，可以增强代码的灵活性，和val互补</li>
</ol>
<h3 id="2：val修饰的变量在编译后类似于java中的中的变量被final修饰"><a href="#2：val修饰的变量在编译后类似于java中的中的变量被final修饰" class="headerlink" title="2：val修饰的变量在编译后类似于java中的中的变量被final修饰"></a>2：val修饰的变量在编译后类似于java中的中的变量被final修饰</h3><ol>
<li><p>先看源代码</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ValAndVar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="type">LOVE</span>:<span class="type">String</span> = <span class="string">"篮球"</span></span><br><span class="line">    <span class="keyword">var</span> <span class="type">SEX</span>:<span class="type">String</span>  = _</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> name:<span class="type">String</span> = <span class="string">"tunan"</span></span><br><span class="line">        <span class="keyword">var</span> age:<span class="type">Int</span> = <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再看反编译后的代码(只保留了我们想要的部分)</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValAndVar$</span> </span>&#123;</span><br><span class="line">  public static <span class="type">ValAndVar</span>$ <span class="type">MODULE</span>$;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="type">LOVE</span>;</span><br><span class="line">    </span><br><span class="line">  public void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">    <span class="type">String</span> name = <span class="string">"tunan"</span>;</span><br><span class="line">    int age = <span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现这段代码很诡异，scala中的类变量，在字节码层面转换成了 parivate final ，而main方法中的变量却没有添加final修饰，这是否证明编译器有问题？</p>
<p>答案是否定的，对于val或者final都只是给编译器用的，编译器如果发现你给此变量重新赋值会抛出错误。同时字节码(bytecode)不具备表达一个局部变量是不可变(immutable)的能力。</p>
<p>所以就有了现在结果。</p>
</li>
</ol>
<h3 id="3：lazy修饰符可以修饰变量，但是这个变量必须是val修饰的"><a href="#3：lazy修饰符可以修饰变量，但是这个变量必须是val修饰的" class="headerlink" title="3：lazy修饰符可以修饰变量，但是这个变量必须是val修饰的"></a>3：lazy修饰符可以修饰变量，但是这个变量必须是val修饰的</h3><ol>
<li><p>在证明lazy修饰的变量必须是val之前，我们先看看lazy是什么？</p>
<p>Scala中使用关键字lazy来定义惰性变量，实现延迟加载(懒加载)。<br>惰性变量只能是不可变变量，并且只有在调用惰性变量时，才会去实例化这个变量。</p>
<p>在Java中，一般使用get和set实现延迟加载(懒加载)，而在Scala中对延迟加载这一特性提供了语法级别的支持:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> name = initName()</span><br></pre></td></tr></table></figure>

<p>使用lazy关键字修饰变量后，只有在使用该变量时，才会调用其实例化方法。也就是说在定义name=initName()时并不会调用initName()方法，只有在后面的代码中使用变量name时才会调用initName()方法。</p>
<p>如果<strong>不使用lazy关键字对变量修饰</strong>，那么变量name是立即实例化的，下面将通过一组案例对比认识：</p>
<p><code>不使用lazy修饰的方法：</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LazyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initName</span></span>:<span class="type">String</span>=&#123;</span><br><span class="line">        println(<span class="string">"初始化initName"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"返回intName"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//        lazy val name = initName</span></span><br><span class="line">        <span class="keyword">val</span> name = initName	<span class="comment">//程序走到这里，就打印了initName的输出语句</span></span><br><span class="line">        println(<span class="string">"hello，欢迎来到图南之家"</span>)</span><br><span class="line">        println(name)	<span class="comment">//程序走到这里，打印initName的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的name没有使用lazy关键字进行修饰，所以name是立即实例化的。</p>
<p>结果：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">初始化initName</span><br><span class="line">hello，欢迎来到图南之家</span><br><span class="line">返回intName</span><br></pre></td></tr></table></figure>

<p><code>使用lazy修饰后的方法：</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LazyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initName</span></span>:<span class="type">String</span>=&#123;</span><br><span class="line">        println(<span class="string">"初始化initName"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"返回intName"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">lazy</span> <span class="keyword">val</span> name = initName	<span class="comment">//不调用initName方法，即不打印initName中的输出语句</span></span><br><span class="line"><span class="comment">//        val name = initName</span></span><br><span class="line">        println(<span class="string">"hello，欢迎来到图南之家"</span>)	<span class="comment">//打印main方法中的输出语句</span></span><br><span class="line">        println(name)	<span class="comment">//打印initName的输出语句，打印返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明name时，并没有立即调用实例化方法initName(),而是在使用name时，才会调用实例化方法,并且无论调用多少次，实例化方法只会执行一次。</p>
<p>结果：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">hello，欢迎来到图南之家</span><br><span class="line">初始化initName</span><br><span class="line">返回intName</span><br></pre></td></tr></table></figure>
</li>
<li><p>证明lazy只能修饰的变量只能使用val</p>
<p>我们发现name都是使用val修饰的，如果我们使用var修饰会怎么样呢？</p>
<p><img src="https://yerias.github.io/scala_img/lazy%E6%87%92%E5%8A%A0%E8%BD%BD.jpg" alt="lazy懒加载"></p>
<p>我们发现报错：<code>&#39;lazy&#39; modifier allowed only with value definitions</code></p>
<p>实际上就是认为<code>lazy</code>修饰的变量只能<code>val</code>修饰</p>
</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/19/error/1/">执行Saprk or Scala程序:找不到或者无法加载主类 xxx</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Error/">Error</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Error/">Error</a></span><div class="content"><p>使用百度和谷歌，测试了广大程序员给出的各种解决办法，包括更换jdk版本(之前也是jdk8，小版本不同)，更换scala 的版本(2.12大版本内更换小版本，因为我的spark2.4.5需要的scala版本是2.12)，更换idea的输出路径，重构代码，清理idea的缓存，删除依赖重新下载，重建项目，导入其他同学的项目，皆出现<code>找不到或者无法加载主类 xxx</code>异常</p>
<p>最后重装idea，解决！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/17/java/11/">JAVA的包装类解析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>什么是包装类</li>
<li>自动装箱和自动拆箱</li>
<li>包装类可以为null，而基本类型不可以</li>
<li>包装类型可用于泛型，而基本类型不可以</li>
<li>基本类型比包装类型更高效</li>
<li>两个包装类型的值可以相同，但却可以不相等</li>
</ol>
<h2 id="什么是包装类"><a href="#什么是包装类" class="headerlink" title="什么是包装类"></a>什么是包装类</h2><p>Java的每个基本类型都有对应的包装类型，比如说int的包装类型是Integer，double的包装类型是Double。</p>
<h2 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h2><p>既然有了基本类型和包装类型，肯定有些是要在他们之间进行转换。把基本类型转换成包装类型的过程叫做装箱。反之，把包装类型转换成基本类型的过程叫做拆箱。</p>
<p>在Java5之前，开发人员要进行手动拆装箱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer2 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> j = integer2.intValue();</span><br></pre></td></tr></table></figure>
<p>java5引入了自动拆装箱的功能，减少了开发人员的工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer chenmo  = <span class="number">10</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> wanger = chenmo;     <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>使用反编译工作编译后的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer3 = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> k = integer3.intValue();</span><br></pre></td></tr></table></figure>

<p>也就说自动装箱是调用了<code>Integer.valueOf()</code>完成的，自动拆箱是通过调用<code>integer.intValue()</code>完成的。</p>
<p>理解了自动拆装箱的原理后，我们来看一道面试题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">System.out.println(a ==b);</span><br><span class="line"></span><br><span class="line">Integer c = <span class="number">100</span>;</span><br><span class="line">Integer d = <span class="number">100</span>;</span><br><span class="line">System.out.println(c == d);</span><br><span class="line"></span><br><span class="line">Integer e = <span class="number">200</span>;</span><br><span class="line">Integer f = <span class="number">200</span>;</span><br><span class="line">System.out.println(e == f);</span><br><span class="line"></span><br><span class="line">System.out.println( a == c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h = <span class="number">200</span>;</span><br><span class="line">System.out.println( e == h);</span><br></pre></td></tr></table></figure>

<p>在看这段代码之前，我们要明白的是 == 号，基础类型比较的是值，引用类型比较的是内存地址</p>
<p>第一段代码，很好理解，基础类型比较的是值</p>
<p>第二段代码是包装类，这里需要引入一个缓冲池(IntegerCache )的概念，JVM把-128到127的数值存到了内存中，需要的时候直接从内存拿，而不是重新创建一个对象</p>
<p>第三段代码也很容易理解，如果-128到127是从缓冲池中拿，那么超过这个范围的，自然就是堆中创建了</p>
<p>第四段是基本类型和包装类型做比较，这时候包装类型会先转成基本类型，然后再比较</p>
<p>第五段代码同上，没有在堆中创建的对象这一步</p>
<p>结果即是：<code>true、true、false、true、true</code></p>
<p>之前我们就已经知道了自动装箱是Integer.valueOf()方法，我们现在看看它的源码，如果做到-128到127是缓冲池中拿，而超过了则需要在堆中创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果需要包装的数值大于IntegerCache.low 并且小于IntegerCache.high，就在IntegerCache.cache中拿，否则就new一个Integer，从这里看cache应该是个数组，保存了-128到127的数值</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">       	<span class="comment">// 数据中的位置是0 - 255 ==&gt; -127 - 128 ==&gt; -IntegerCache.low的位置的值是0</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;	<span class="comment">//最小值-128</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//静态代码块，初始化时就加载好了</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 最大值可以通过配置文件设置</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;	<span class="comment">//最大值127</span></span><br><span class="line">        <span class="comment">//从jvm的配置中拿到自定义缓冲池最大值的参数</span></span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="comment">//integerCacheHighPropValue的值默认是null</span></span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//拿到传入的最大值</span></span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// 最大值不能超过Integer定义的最大值</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// 如果属性不能被解析成int型，就忽略它。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;	<span class="comment">//赋值给high</span></span><br><span class="line">					<span class="comment">//(high - low) + 1 = 256</span></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;<span class="comment">// 遍历 0 - 256</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            <span class="comment">// -127开始累加，并且都放到cache中，注意k是从0开始的</span></span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里也就明白了，-128-127是如何实现的，超过这个范围为什么是在堆中创建了，在这个源码中，还有一个地方没有解释，那就是参数<code>java.lang.Integer.IntegerCache.high</code>，这个参数可以加载到手动传入的值，从而扩大或者缩小缓冲池的最大值</p>
<p>如果我们设置这个值的大小为200：<code>-Djava.lang.Integer.IntegerCache.high=200</code>，那么我们就能看到下面的代码的结果是true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer e = <span class="number">200</span>;</span><br><span class="line">Integer f = <span class="number">200</span>;</span><br><span class="line">System.out.println(e == f);</span><br></pre></td></tr></table></figure>

<p>看完上面的分析之后，我希望大家记住一点：<strong>当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象</strong>。</p>
<p>注意：缓冲池只有Integer类型有</p>
<h2 id="包装类可以为null，而基本类型不可以"><a href="#包装类可以为null，而基本类型不可以" class="headerlink" title="包装类可以为null，而基本类型不可以"></a>包装类可以为null，而基本类型不可以</h2><p>别小看这一点区别，它使得包装类型可以应用于 POJO 中，而基本类型则不行。</p>
<p>那为什么 POJO 的属性必须要用包装类型呢？</p>
<p>对于基本数据类型，数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 <code>NullPointerException</code> 的异常。因为基础类型的值只能是数值。</p>
<h2 id="包装类型可用于泛型，而基本类型不可以"><a href="#包装类型可用于泛型，而基本类型不可以" class="headerlink" title="包装类型可用于泛型，而基本类型不可以"></a>包装类型可用于泛型，而基本类型不可以</h2><p>我们先尝试定义一个List</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Syntax error, insert <span class="string">"Dimensions"</span> to complete ReferenceTypeList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>原因是泛型只能使用Object 类及其子类，所以包装类型可用于泛型，而基本类型不可以</p>
<h2 id="基本类型比包装类型更高效"><a href="#基本类型比包装类型更高效" class="headerlink" title="基本类型比包装类型更高效"></a>基本类型比包装类型更高效</h2><p>基本数据类型在栈中直接存储具体的数值，而包装类型则存储在堆中，栈中存放的是引用</p>
<p><img src="https://yerias.github.io/java_img/13.png" alt=""></p>
<p>很显然，相对于基本数据类型而言，包装类型需要占用更多的内存空间，假如没有基本数据类型的话，对于数值这类经常能用到的数据来说，每次都要通过new来创建包装类型就显得非常笨重。</p>
<h2 id="两个包装类型的值可以相同，但却可以不相等"><a href="#两个包装类型的值可以相同，但却可以不相等" class="headerlink" title="两个包装类型的值可以相同，但却可以不相等"></a>两个包装类型的值可以相同，但却可以不相等</h2><p>两个包装类型的值可以相同，但却不相等</p>
<p>不相等是因为两个包装类型在使用“==”进行判断的时候，判断的是其指向的内存地址是否相等。包装类的值如果是在堆中创建出的话，因为内存地址不同，所以返回的是false。</p>
<p>而值相同是因为包装类型在做<code>equals</code>比较的时候，都先拆箱成了基础类型，然后再做比较，即比较的是内容，所以为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/16/scala/2/">Scala之使用ScalikeJDBC操作MySQL</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-16</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Scala/">Scala</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Scala/">Scala</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>简介</li>
<li>配置</li>
<li>操作数据库</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ScalikeJDBC是一款给Scala开发者使用的简介访问类库，它是基于SQL的，使用者只需要关注SQL逻辑的编写，所有的数据库操作都交给ScalikeJDBC。这个类库内置包含了JDBCAPI，并且给用户提供了简单易用并且非常灵活的API。并且，QueryDSl（通用查询查询框架）使你的代码类型安全，半年过去可重复使用。我们可以在生产环境大胆地使用这款DB访问类库。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li><p>解决依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.11.8<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scalikejdbc.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">scalikejdbc.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.jdbc.version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">mysql.jdbc.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Scala相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--scalikejdbc相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scalikejdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scalikejdbc_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scalikejdbc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scalikejdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scalikejdbc-config_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scalikejdbc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.jdbc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决配置</p>
<p>在<code>src</code>的<code>main</code>目录下配置一个<code>resource</code>文件夹，文件夹下再创建一个<code>application.conf</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.default.driver="com.mysql.jdbc.Driver"</span><br><span class="line">db.default.url="jdbc:mysql://hadoop001/ruoze_d6?characterEncoding=utf-8"</span><br><span class="line">db.default.user="root"</span><br><span class="line">db.default.password="123456"</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connection Pool settings</span></span><br><span class="line">db.default.poolInitialSize=10</span><br><span class="line">db.default.poolMaxSize=20</span><br><span class="line">db.default.connectionTimeoutMillis=1000</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><ol>
<li><p>建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Employer(</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    age <span class="built_in">varchar</span>(<span class="number">4</span>),</span><br><span class="line">    salary  <span class="built_in">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>scala编程实现增删改查操作</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wsk.bigdata.scala.scalikejdbc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scalikejdbc._</span><br><span class="line"><span class="keyword">import</span> scalikejdbc.config._</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义样例类获取数据</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employer</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, salary: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">DBs</span>.setupAll()	<span class="comment">//初始化配置</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="keyword">val</span> employers = <span class="type">List</span>(<span class="type">Employer</span>(<span class="string">"zhangsan"</span>, <span class="number">20</span>, <span class="number">18000</span>), <span class="type">Employer</span>(<span class="string">"zhangliu"</span>, <span class="number">50</span>, <span class="number">300000</span>), <span class="type">Employer</span>(<span class="string">"lisi"</span>, <span class="number">22</span>, <span class="number">22000</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//批量插入</span></span><br><span class="line">    insert(employers)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询出结果</span></span><br><span class="line">    <span class="keyword">val</span> results = select()</span><br><span class="line">    <span class="keyword">for</span> (employer &lt;- results) &#123;</span><br><span class="line">      println(employer.name, employer.age, employer.salary)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    update(<span class="number">1000</span>, <span class="string">"zhangsan"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据条件删除</span></span><br><span class="line">    deleteByname(<span class="string">"zhangliu"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除所有</span></span><br><span class="line">    deleteAll()</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//关闭资源</span></span><br><span class="line">    <span class="type">DBs</span>.closeAll()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(employers: <span class="type">List</span>[<span class="type">Employer</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//事物插入</span></span><br><span class="line">    <span class="type">DB</span>.localTx &#123; </span><br><span class="line">        <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">      		<span class="keyword">for</span> (employer &lt;- employers) &#123;</span><br><span class="line">        		<span class="type">SQL</span>(<span class="string">"insert into wsktest(name,age,salary) values(?,?,?)"</span>)</span><br><span class="line">          		.bind(employer.name, employer.age, employer.salary)</span><br><span class="line">          		.update()	<span class="comment">//更新操作</span></span><br><span class="line">                .apply()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//查询操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">select</span></span>(): <span class="type">List</span>[<span class="type">Employer</span>] = &#123;</span><br><span class="line">    <span class="type">DB</span>.readOnly &#123; </span><br><span class="line">        <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">      		<span class="type">SQL</span>(<span class="string">"select * from wsktest"</span>)</span><br><span class="line">        	.map(rs =&gt; <span class="type">Employer</span>(rs.string(<span class="string">"name"</span>), rs.int(<span class="string">"age"</span>), rs.long(<span class="string">"salary"</span>)))</span><br><span class="line">        	.list()  <span class="comment">//结果转换成list</span></span><br><span class="line">        	.apply() </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//更新操作</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(age: <span class="type">Int</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="type">DB</span>.autoCommit &#123; </span><br><span class="line">        <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">      		<span class="type">SQL</span>(<span class="string">"update wsktest set age = ? where name = ?"</span>)</span><br><span class="line">        	.bind(age, name)</span><br><span class="line">        	.update()	<span class="comment">//更新操作</span></span><br><span class="line">        	.apply()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据条件删除</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deleteByname</span></span>(name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">DB</span>.autoCommit &#123; </span><br><span class="line">        <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">      		<span class="type">SQL</span>(<span class="string">"delete from wsktest where name = ?"</span>)</span><br><span class="line">        	.bind(name)	<span class="comment">//更新操作</span></span><br><span class="line">        	.update()</span><br><span class="line">        	.apply()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除所有</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deleteAll</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="type">DB</span>.autoCommit &#123; </span><br><span class="line">        <span class="keyword">implicit</span> session =&gt;</span><br><span class="line">      		<span class="type">SQL</span>(<span class="string">"delete from wsktest "</span>)</span><br><span class="line">        	.update()	<span class="comment">//更新操作</span></span><br><span class="line">        	.apply()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/15/zookeeper/2/">Curator的介绍&amp;使用</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Zookeeper/">Zookeeper</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Zookeeper/">Zookeeper</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>简介</li>
<li>基于Curator的Zookeeper基本用法</li>
<li>监听器</li>
<li>分布式锁</li>
<li>Leader选举</li>
</ol>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Apache Curator是一个比较完善的ZooKeeper客户端框架，通过封装的一套高级API 简化了ZooKeeper的操作。通过查看官方文档，可以发现Curator主要解决了三类问题：</p>
<ul>
<li>封装ZooKeeper client与ZooKeeper server之间的连接处理</li>
<li>提供了一套Fluent风格的操作API</li>
<li>提供ZooKeeper各种应用场景(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装</li>
</ul>
<h3 id="Curator主要从以下几个方面降低了zk使用的复杂性："><a href="#Curator主要从以下几个方面降低了zk使用的复杂性：" class="headerlink" title="Curator主要从以下几个方面降低了zk使用的复杂性："></a>Curator主要从以下几个方面降低了zk使用的复杂性：</h3><ul>
<li>重试机制:提供可插拔的重试机制, 它将给捕获所有可恢复的异常配置一个重试策略，并且内部也提供了几种标准的重试策略(比如指数补偿)</li>
<li>连接状态监控: Curator初始化之后会一直对zk连接进行监听，一旦发现连接状态发生变化将会作出相应的处理</li>
<li>zk客户端实例管理:Curator会对zk客户端到server集群的连接进行管理，并在需要的时候重建zk实例，保证与zk集群连接的可靠性</li>
<li>各种使用场景支持:Curator实现了zk支持的大部分使用场景（甚至包括zk自身不支持的场景），这些实现都遵循了zk的最佳实践，并考虑了各种极端情况</li>
</ul>
<h2 id="基于Curator的Zookeeper基本用法"><a href="#基于Curator的Zookeeper基本用法" class="headerlink" title="基于Curator的Zookeeper基本用法"></a>基于Curator的Zookeeper基本用法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorBase</span> </span>&#123;</span><br><span class="line">    <span class="comment">//会话超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CONNECTION_TIMEOUT = <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ZooKeeper服务地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONNECT_ADDR = <span class="string">"192.168.1.1:2100,192.168.1.1:2101,192.168.1.:2102"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建连接实例</span></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">//1 重试策略：初试时间为1s 重试10次</span></span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2 通过工厂创建连接</span></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                    .connectString(CONNECT_ADDR).connectionTimeoutMs(CONNECTION_TIMEOUT)</span><br><span class="line">                    .sessionTimeoutMs(SESSION_TIMEOUT)</span><br><span class="line">                    .retryPolicy(retryPolicy)</span><br><span class="line"><span class="comment">//命名空间           .namespace("super")</span></span><br><span class="line">                    .build();</span><br><span class="line">        <span class="comment">//3 开启连接</span></span><br><span class="line">        cf.start();</span><br><span class="line">        </span><br><span class="line">        System.out.println(States.CONNECTED);</span><br><span class="line">        System.out.println(cf.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建永久节点</span></span><br><span class="line">        client.create().forPath(<span class="string">"/curator"</span>,<span class="string">"/curator data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建永久有序节点</span></span><br><span class="line">        client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(<span class="string">"/curator_sequential"</span>,<span class="string">"/curator_sequential data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建临时节点</span></span><br><span class="line">        client.create().withMode(CreateMode.EPHEMERAL)</span><br><span class="line">            .forPath(<span class="string">"/curator/ephemeral"</span>,<span class="string">"/curator/ephemeral data"</span>.getBytes());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//创建临时有序节点</span></span><br><span class="line">        client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL) .forPath(<span class="string">"/curator/ephemeral_path1"</span>,<span class="string">"/curator/ephemeral_path1 data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(<span class="string">"/curator/ephemeral_path2"</span>,<span class="string">"/curator/ephemeral_path2 data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//测试检查某个节点是否存在</span></span><br><span class="line">        Stat stat1 = client.checkExists().forPath(<span class="string">"/curator"</span>);</span><br><span class="line">        Stat stat2 = client.checkExists().forPath(<span class="string">"/curator2"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"'/curator'是否存在： "</span> + (stat1 != <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>));</span><br><span class="line">        System.out.println(<span class="string">"'/curator2'是否存在： "</span> + (stat2 != <span class="keyword">null</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取某个节点的所有子节点</span></span><br><span class="line">        System.out.println(client.getChildren().forPath(<span class="string">"/"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取某个节点数据</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(client.getData().forPath(<span class="string">"/curator"</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置某个节点数据</span></span><br><span class="line">        client.setData().forPath(<span class="string">"/curator"</span>,<span class="string">"/curator modified data"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建测试节点</span></span><br><span class="line">        client.create().orSetData().creatingParentContainersIfNeeded()</span><br><span class="line">            .forPath(<span class="string">"/curator/del_key1"</span>,<span class="string">"/curator/del_key1 data"</span>.getBytes());</span><br><span class="line"> </span><br><span class="line">        client.create().orSetData().creatingParentContainersIfNeeded()</span><br><span class="line">        .forPath(<span class="string">"/curator/del_key2"</span>,<span class="string">"/curator/del_key2 data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        client.create().forPath(<span class="string">"/curator/del_key2/test_key"</span>,<span class="string">"test_key data"</span>.getBytes());</span><br><span class="line">              </span><br><span class="line">        <span class="comment">//删除该节点</span></span><br><span class="line">        client.delete().forPath(<span class="string">"/curator/del_key1"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//级联删除子节点</span></span><br><span class="line">        client.delete().guaranteed().deletingChildrenIfNeeded().forPath(<span class="string">"/curator/del_key2"</span>);</span><br><span class="line">    ｝ </span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<ul>
<li><code>orSetData()</code>方法：如果节点存在则Curator将会使用给出的数据设置这个节点的值，相当于 setData() 方法</li>
<li><code>creatingParentContainersIfNeeded()</code>方法：如果指定节点的父节点不存在，则Curator将会自动级联创建父节点</li>
<li><code>guaranteed()</code>方法：如果服务端可能删除成功，但是client没有接收到删除成功的提示，Curator将会在后台持续尝试删除该节点</li>
<li><code>deletingChildrenIfNeeded()</code>方法：如果待删除节点存在子节点，则Curator将会级联删除该节点的子节点</li>
</ul>
<p>事务管理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 事务管理：碰到异常，事务会回滚</span><br><span class="line">     * <span class="meta">@throws</span> Exception</span><br><span class="line">     */</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//定义几个基本操作</span></span><br><span class="line">        CuratorOp createOp = client.transactionOp().create()</span><br><span class="line">                .forPath(<span class="string">"/curator/one_path"</span>,<span class="string">"some data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        CuratorOp setDataOp = client.transactionOp().setData()</span><br><span class="line">                .forPath(<span class="string">"/curator"</span>,<span class="string">"other data"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        CuratorOp deleteOp = client.transactionOp().delete()</span><br><span class="line">                .forPath(<span class="string">"/curator"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//事务执行结果</span></span><br><span class="line">        List&lt;CuratorTransactionResult&gt; results = client.transaction()</span><br><span class="line">                .forOperations(createOp,setDataOp,deleteOp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(CuratorTransactionResult result : results)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行结果是： "</span> + result.getForPath() + <span class="string">"--"</span> + result.getType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//因为节点“/curator”存在子节点，所以在删除的时候将会报错，事务回滚</span></span><br></pre></td></tr></table></figure>

<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>Curator提供了三种Watcher(Cache)来监听结点的变化：</p>
<ul>
<li><strong>Path Cache</strong>：监视一个路径下1）孩子结点的创建、2）删除，3）以及结点数据的更新。产生的事件会传递给注册的PathChildrenCacheListener。</li>
<li><strong>Node Cache</strong>：监视一个结点的创建、更新、删除，并将结点的数据缓存在本地。</li>
<li><strong>Tree Cache</strong>：Path Cache和Node Cache的“合体”，监视路径下的创建、更新、删除事件，并缓存路径下所有孩子结点的数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在注册监听器的时候，如果传入此参数，当事件触发时，逻辑由线程池处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 监听数据节点的变化情况</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, <span class="string">"/zk-huey/cnode"</span>, <span class="keyword">false</span>);</span><br><span class="line">        nodeCache.start(<span class="keyword">true</span>);</span><br><span class="line">        nodeCache.getListenable().addListener(</span><br><span class="line">            <span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Node data is changed, new data: "</span> + </span><br><span class="line">                        <span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, </span><br><span class="line">            pool</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 监听子节点的变化情况</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(client, <span class="string">"/zk-huey"</span>, <span class="keyword">true</span>);</span><br><span class="line">        childrenCache.start(StartMode.POST_INITIALIZED_EVENT);</span><br><span class="line">        childrenCache.getListenable().addListener(</span><br><span class="line">            <span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                            System.out.println(<span class="string">"CHILD_ADDED: "</span> + event.getData().getPath());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                            System.out.println(<span class="string">"CHILD_REMOVED: "</span> + event.getData().getPath());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                            System.out.println(<span class="string">"CHILD_UPDATED: "</span> + event.getData().getPath());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            pool</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        client.setData().forPath(<span class="string">"/zk-huey/cnode"</span>, <span class="string">"world"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        client.close();</span><br></pre></td></tr></table></figure>

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式编程时，比如最容易碰到的情况就是应用程序在线上多机部署，于是当多个应用同时访问某一资源时，就需要某种机制去协调它们。例如，现在一台应用正在rebuild缓存内容，要临时锁住某个区域暂时不让访问；又比如调度程序每次只想一个任务被一台应用执行等等。</p>
<p>下面的程序会启动两个线程t1和t2去争夺锁，拿到锁的线程会占用5秒。运行多次可以观察到，有时是t1先拿到锁而t2等待，有时又会反过来。Curator会用我们提供的lock路径的结点作为全局锁，这个结点的数据类似这种格式：[<em>c</em>64e0811f-9475-44ca-aa36-c1db65ae5350-lock-0000000005]，每次获得锁时会生成这种串，释放锁时清空数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.RetryNTimes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Curator framework's distributed lock test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorDistrLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Zookeeper info */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ADDRESS = <span class="string">"192.168.1.100:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_LOCK_PATH = <span class="string">"/zktest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.Connect to zk</span></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(</span><br><span class="line">                ZK_ADDRESS,</span><br><span class="line">                <span class="keyword">new</span> RetryNTimes(<span class="number">10</span>, <span class="number">5000</span>)</span><br><span class="line">        );</span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(<span class="string">"zk client start successfully!"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            doWithLock(client);</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            doWithLock(client);</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithLock</span><span class="params">(CuratorFramework client)</span> </span>&#123;</span><br><span class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(client, ZK_LOCK_PATH);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">10</span> * <span class="number">1000</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" hold lock"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" release lock"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>当集群里的某个服务down机时，我们可能要从slave结点里选出一个作为新的master，这时就需要一套能在分布式环境中自动协调的Leader选举方法。Curator提供了LeaderSelector监听器实现Leader选举功能。同一时刻，只有一个Listener会进入takeLeadership()方法，说明它是当前的Leader。注意：<strong>当Listener从takeLeadership()退出时就说明它放弃了“Leader身份”</strong>，这时Curator会利用Zookeeper再从剩余的Listener中选出一个新的Leader。autoRequeue()方法使放弃Leadership的Listener有机会重新获得Leadership，如果不设置的话放弃了的Listener是不会再变成Leader的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.state.ConnectionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.RetryNTimes;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.EnsurePath;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Curator framework's leader election test.</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> *  LeaderSelector-2 take leadership!</span></span><br><span class="line"><span class="comment"> *  LeaderSelector-2 relinquish leadership!</span></span><br><span class="line"><span class="comment"> *  LeaderSelector-1 take leadership!</span></span><br><span class="line"><span class="comment"> *  LeaderSelector-1 relinquish leadership!</span></span><br><span class="line"><span class="comment"> *  LeaderSelector-0 take leadership!</span></span><br><span class="line"><span class="comment"> *  LeaderSelector-0 relinquish leadership! </span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLeaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Zookeeper info */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_ADDRESS = <span class="string">"192.168.1.100:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_PATH = <span class="string">"/zktest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LeaderSelectorListener listener = <span class="keyword">new</span> LeaderSelectorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" take leadership!"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// takeLeadership() method should only return when leadership is being relinquished.</span></span><br><span class="line">                Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" relinquish leadership!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState state)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            registerListener(listener);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            registerListener(listener);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            registerListener(listener);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(LeaderSelectorListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.Connect to zk</span></span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.newClient(</span><br><span class="line">                ZK_ADDRESS,</span><br><span class="line">                <span class="keyword">new</span> RetryNTimes(<span class="number">10</span>, <span class="number">5000</span>)</span><br><span class="line">        );</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.Ensure path</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> EnsurePath(ZK_PATH).ensure(client.getZookeeperClient());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Register listener</span></span><br><span class="line">        LeaderSelector selector = <span class="keyword">new</span> LeaderSelector(client, ZK_PATH, listener);</span><br><span class="line">        selector.autoRequeue();</span><br><span class="line">        selector.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>转载：<a href="https://www.cnblogs.com/erbing/p/9799098.html" target="_blank" rel="noopener">https://www.cnblogs.com/erbing/p/9799098.html</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/03/11/java/10/">JAVA的String类源码解析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><div class="content"><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>源码的角度解析String不可变</li>
<li>String Pool 的角度解析String不可变</li>
<li>String对象不可变性的优缺点</li>
<li>String对象是否真的不可变</li>
<li>从源码的角度解析StringBuilder的可变</li>
<li>从源码的角度解析StringBuffer和StringBuilder的异同</li>
<li>编译器对String做出了哪些优化</li>
</ol>
<h2 id="从源码的角度解析String不可变"><a href="#从源码的角度解析String不可变" class="headerlink" title="从源码的角度解析String不可变"></a>从源码的角度解析String不可变</h2><p>所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。</p>
<p>String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"tunan"</span>;</span><br><span class="line">    System.out.println(name);	<span class="comment">//tunan</span></span><br><span class="line"></span><br><span class="line">    String name2 = upcase(name);</span><br><span class="line">    System.out.println(name2);	<span class="comment">//TUNAN</span></span><br><span class="line"></span><br><span class="line">    System.out.println(name);	<span class="comment">//tunan</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当把name传给upcase()方法的时候，实际上传递的是一个引用的拷贝。而该引用所指的对象其实一直待在单一的物理位置上，从未动过。</p>
<p>回到upcase()的定义，传入其中的引用有了名字s，只有upcase()运行的时候，局部引用s才存在。一旦upcase()运行结束，s就消失了。当然了，upcase()的返回值，其实只是最终结果的引用。这足已说明，upcase()返回的引用已经指向了一个新的对象name2，而原本的name则还在原地。</p>
<p>既然String类型的变量name没有变过，我们从源码的角度去看为什么没有改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用字节数组存储字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储hash值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到String类是一个final类，但这并不是String不可变的真正原因，继续看String实现了CharSequence接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CharSequence是一个接口，它只包括length(), charAt(int index), subSequence(int start, int end)这几个API接口。同时除了String实现了CharSequence之外，StringBuffer和StringBuilder也实现了CharSequence接口。 </p>
<p>也就是说，CharSequence其实也就是定义了字符串操作的接口，其他具体的实现是由String、StringBuilder、StringBuffer完成的，String、StringBuilder、StringBuffer都可以转化为CharSequence类型。</p>
<p>继续看String类，<code>private final char value[];</code>这个final类型的字符型变量才是真正存储字符串的容器，也正是因为这个变量是final的，才真正决定了字符串不可变，也许你不相信，你可以说Stirng类也是final修饰的，也是不可变的，那么如果StringBuilder和StringBuffer也是final修饰的呢？</p>
<h2 id="String-Pool-的角度解析String不可变"><a href="#String-Pool-的角度解析String不可变" class="headerlink" title="String Pool 的角度解析String不可变"></a>String Pool 的角度解析String不可变</h2><p>JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心，即字符串池（String Pool）。</p>
<p>我们知道，在Java中有两种创建字符串对象的方式：</p>
<ol>
<li><p>采用字面值的方式赋值 </p>
</li>
<li><p>采用new关键字新建一个字符串对象。</p>
<p>这两种方式在性能和内存占用方面存在着差别。</p>
</li>
</ol>
<p>方式一：采用字面值的方式赋值，例如：</p>
<p><img src="https://yerias.github.io/java_img/1.png" alt=""></p>
<p>采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在”aaa”这个对象，如果不存在，则在字符串池中创建”aaa”这个对象，然后将池中”aaa”这个对象的引用地址返回给字符串常量str，这样str会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。</p>
<p><img src="https://yerias.github.io/java_img/3.jpg" alt=""></p>
<p> 在本例中，执行：str == str2 ，会得到以下结果：</p>
<p><img src="https://yerias.github.io/java_img/2.png" alt=""></p>
<p>这是因为，创建字符串对象str2时，字符串池中已经存在”aaa”这个对象，直接把对象”aaa”的引用地址返回给str2，这样str2指向了池中”aaa”这个对象，也就是说str和str2指向了同一个对象，因此语句System.out.println(str == str2)输出：true。</p>
<p>方式二：采用new关键字新建一个字符串对象，例如：</p>
<p><img src="https://yerias.github.io/java_img/4.png" alt=""></p>
<p>采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象，如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象；如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。</p>
<p><img src="https://yerias.github.io/java_img/6.jpg" alt=""></p>
<p>在这个例子中，执行：str3 == str4，得到以下结果：</p>
<p><img src="https://yerias.github.io/java_img/5.png" alt=""></p>
<p>因为，采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str3和str4指向的是两个不同的对象，因此语句System.out.println(str3 == str4)输出：false。</p>
<p>字符串池的实现有一个前提条件：String对象是不可变的。因为这样可以保证多个引用可以同时指向字符串池中的同一个对象。如果字符串是可变的，那么一个引用操作改变了对象的值，对其他引用会有影响，这样显然是不合理的。</p>
<p><strong>Java语言规范（Java Language Specification）</strong>中对字符串做出了如下说明：每一个字符串常量都是指向一个字符串类实例的引用。字符串对象有一个固定值。字符串常量，或者一般的说，常量表达式中的字符串都被使用方法 String.intern进行保留来共享唯一的实例。</p>
<p>以上是Java语言规范中的原文，比较官方，用更通俗易懂的语言翻译过来主要说明了三点：</p>
<ol>
<li>每一个字符串常量都指向字符串池中或者堆内存中的一个字符串实例。</li>
<li>字符串对象值是固定的，一旦创建就不能再修改。</li>
<li>字符串常量或者常量表达式中的字符串都被方法String.intern()在字符串池中保留了唯一的实例。</li>
</ol>
<p><img src="https://yerias.github.io/java_img/7.jpg" alt=""></p>
<p>​        其他包</p>
<p>​            <img src="https://yerias.github.io/java_img/8.png" alt=""></p>
<p>​        结果</p>
<p>​                <img src="https://yerias.github.io/java_img/9.png" alt=""></p>
<p>结论：</p>
<ul>
<li>同一个包下同一个类中的字符串常量的引用指向同一个字符串对象；</li>
<li>同一个包下不同的类中的字符串常量的引用指向同一个字符串对象；</li>
<li>不同的包下不同的类中的字符串常量的引用仍然指向同一个字符串对象；</li>
<li>由常量表达式计算出的字符串是在编译时进行计算,然后被当作常量；</li>
<li>在运行时通过连接计算出的字符串是新创建的，因此是不同的；</li>
<li>通过计算生成的字符串显示调用intern方法后产生的结果与原来存在的同样内容的字符串常量是一样的。</li>
</ul>
<p>从上面的例子可以看出，字符串常量在<strong>编译时</strong>计算和在<strong>运行时</strong>计算，其执行过程是不同的，得到的结果也是不同的。我们来看看下面这段代码：</p>
<p><img src="https://yerias.github.io/java_img/10.png" alt=""></p>
<p> 代码输出如下：</p>
<p><img src="https://yerias.github.io/java_img/11.png" alt=""></p>
<p>为什么出现上面的结果呢？这是因为，字符串字面量拼接操作是在Java编译器编译期间就执行了，也就是说编译器编译时，直接把”java”、”language”和”specification”这三个字面量进行”+”操作得到一个”javalanguagespecification” 常量，并且直接将这个常量放入字符串池中，这样做实际上是一种优化，将3个字面量合成一个，避免了创建多余的字符串对象。而字符串引用的”+”运算是在Java运行期间执行的，即str + str2 + str3在程序执行期间才会进行计算，它会在堆内存中重新创建一个拼接后的字符串对象。总结来说就是：字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中；而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。</p>
<p><strong>到这里我们也能理解了什么是字符串的不可变性</strong>，其本质是在字符串池中开辟了一块空间，字符串的地址不变，字符串变量重新赋值感觉是字符串变了，其实是在字符串池中开辟了另外一块空间，并且字符串的引用重新指向新的空间地址，而原来的字符串内容和内存地址在字符串池中没有改变过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"aaa"</span>;</span><br><span class="line">name = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(name);</span><br></pre></td></tr></table></figure>

<p><img src="https://yerias.github.io/java_img/12.jpg" alt=""></p>
<p>字符串池的位置是在堆中，那么GC的时候<strong>字符串如何保证不被GC？</strong><br>为了优化空间，运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用。这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收。</p>
<p>总结：字符串是常量，字符串池中的每个字符串对象只有唯一的一份，可以被多个引用所指向，避免了重复创建内容相同的字符串；通过字面值赋值创建的字符串对象存放在字符串池中，通过关键字new出来的字符串对象存放在堆中。</p>
<h2 id="String对象不可变性的优缺点"><a href="#String对象不可变性的优缺点" class="headerlink" title="String对象不可变性的优缺点"></a>String对象不可变性的优缺点</h2><p><strong>1.字符串常量池的需要</strong>.<br>字符串常量池可以将一些字符常量放在常量池中重复使用，避免每次都重新创建相同的对象、节省存储空间。但如果字符串是可变的，此时相同内容的String还指向常量池的同一个内存空间，当某个变量改变了该内存的值时，其他遍历的值也会发生改变。所以不符合常量池设计的初衷。</p>
<p><strong>2. 线程安全考虑</strong>。<br>同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p>
<p><strong>3. 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载</strong>。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</p>
<p><strong>4. 支持hash映射和缓存。</strong><br>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>
<p>缺点：</p>
<ol>
<li>如果有对String对象值改变的需求，那么会创建大量的String对象(使用StringBuffer或者StringBuilder替代)。</li>
</ol>
<h2 id="String对象是否真的不可变"><a href="#String对象是否真的不可变" class="headerlink" title="String对象是否真的不可变"></a>String对象是否真的不可变</h2><p>String对象的不可变，其根本是内存地址的不可变，这在字符串池中有解析</p>
<p>虽然String对象将value设置为final，并且还通过各种机制保证其成员变量不可改变。但是还是可以通过反射机制的手段改变其值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">String s = <span class="string">"hello world"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> +s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取String类中的value字段(private final char value[];)</span></span><br><span class="line">Field valueFieldOfString  = String.class.getDeclaredField("value");</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变value属性的访问权限</span></span><br><span class="line">valueFieldOfString .setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line"><span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">value[<span class="number">5</span>] =<span class="string">'_'</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> +s);</span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = Hello World</span><br><span class="line">s = Hello_World</span><br></pre></td></tr></table></figure>

<p>发现String的值已经发生了改变。也就是说，通过反射是可以修改所谓的“不可变”对象的</p>
<h2 id="从源码的角度解析StringBuilder的可变"><a href="#从源码的角度解析StringBuilder的可变" class="headerlink" title="从源码的角度解析StringBuilder的可变"></a>从源码的角度解析StringBuilder的可变</h2><p>StringBuilder可以动态构造字符串，并且是线程不安全的，我们从源码的角度解析StringBuilder为什么可以动态构造字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//默认char容量16</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//指定了则使用父类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们首先看到StringBuilder也是final修饰的， 和String一样，不仅如此StringBuffer也是final修饰的，下面将不再解释，它继承了AbstractStringBuilder，并且和String、StringBuffer一样，都实现了CharSequence接口</p>
<p>看构造方法默认容量是16，指定了容量则使用父类的构造方法，我们现在去看下父类中如何实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用字节数组存储字符串</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录存储的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空构造方法</span></span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入初始值的构造方法</span></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类的构造方法中是new了一个指定长度的char字节数组，这说明StringBuilder底层也是使用字符数组保存字符串的，需要注意的是value的定义，和String类中的实现不同，这里没有private和final修饰，正是因为这点，所以StringBuilder是可变的，StringBuilder的value字节数组可以动态的改变大小。</p>
<p>我们已经知道了StringBuilder为什么可变，还需要注意的是它的append方法，该方法直接决定了StringBuilder如何追加字符串。也是和StringBuffer唯一不同的地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接重写的父类方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)	<span class="comment">//检查是否空</span></span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();	<span class="comment">//获得字符串长度</span></span><br><span class="line">    ensureCapacityInternal(count + len);	<span class="comment">//检查容量/库容</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);	<span class="comment">//拷贝内容</span></span><br><span class="line">    count += len;	<span class="comment">//增加长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;	<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;	<span class="comment">//扩容为原字节数组长度的两倍+2，注意不是count</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现append方法的底层是对字符数组内容的复制，并且容量不够时，是扩容为原字节数组长度的两倍+2，是字节数组，不是容量</p>
<h2 id="从源码的角度解析StringBuffer和StringBuilder的异同"><a href="#从源码的角度解析StringBuffer和StringBuilder的异同" class="headerlink" title="从源码的角度解析StringBuffer和StringBuilder的异同"></a>从源码的角度解析StringBuffer和StringBuilder的异同</h2><p>StringBuffer和StringBuilder的所有实现一模一样，包括继承的父类，实现的接口，扩容机制，value的定义，正是这些特性让他们两很像，同时也都支持动态构造字符串。</p>
<p>我们知道StringBuffer和StringBuilder最大的不同是线程安全性的问题，StringBuffer在所有以StringBuilder为基础的代码上，在重写父类的方法的同时加了synchronized修饰，保证了线程的安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面只是节选一些StringBuffer中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(<span class="keyword">char</span>[] chars)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(String string)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(StringBuffer sb)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(CharSequence s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span>[] chars)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> StringBuffer     <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, String string)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="编译器对String做出了哪些优化"><a href="#编译器对String做出了哪些优化" class="headerlink" title="编译器对String做出了哪些优化"></a>编译器对String做出了哪些优化</h2><p>String的不可变性会带来一定的效率问题。为String对象重载的 “+” 操作符就是一个例子。重载的意思是，一个操作符在应用于特定的类时，被赋予了特殊的意义。</p>
<p>我们用一段代码来验证 “+” 用来拼接String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String mongo = <span class="string">"mongo"</span>;</span><br><span class="line">String s = <span class="string">"abc"</span> + mongo + <span class="string">"def"</span> +<span class="number">47</span>;</span><br><span class="line">System.out.println(s);	<span class="comment">//abcmongodef47</span></span><br></pre></td></tr></table></figure>

<p>我们猜想一下字符串s的工作方式，它可能有一个append方法，首先s的内容是abc，然后新建一个字符串的内容是abcmongo，继续新建内容是abcmongodef的字符串，最后新建abcmongodef47的字符串，也许你会说为什么不是 “abc” + mongo + “def” +47 一起生成一个字符串然后赋值给s，但是我们不要忘记字符串String，它是一个类。</p>
<p>这种设计方法可以行的通，但是为了最终生成的String，产生了一大堆的需要GC的中间对象。这样的性能是非常糟糕的。</p>
<p>那么String是如何做优化的？我们使用JDK自带的工具javap来反编译以上代码，-c表示生成JVM字节码，删除没用的部分，剩下的内容如下</p>
<p><code>javap -c StringTest</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">"StringTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string</span>.<span class="title">StringTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String mongo</span><br><span class="line">       <span class="number">2</span>: astore_1							<span class="comment">// store mongo</span></span><br><span class="line">       3: new           #3                  // StringBuilder</span><br><span class="line">       <span class="number">6</span>: dup								</span><br><span class="line">       7: invokespecial #4                  // StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      10: ldc           #5                  // String abc</span><br><span class="line">      12: invokevirtual #6                  // StringBuilder.append：abc</span><br><span class="line">      <span class="number">15</span>: aload_1							<span class="comment">// load mongo</span></span><br><span class="line">      16: invokevirtual #6                  // StringBuilder.append：mongo</span><br><span class="line">      19: ldc           #7                  // String def</span><br><span class="line">      21: invokevirtual #6                  // StringBuilder.append：def</span><br><span class="line">      <span class="number">24</span>: bipush        <span class="number">47</span>						</span><br><span class="line">      26: invokevirtual #8                  // StringBuilder.append：47</span><br><span class="line">      29: invokevirtual #9                  // StringBuilder.toString：abcmongodef47</span><br><span class="line">      <span class="number">32</span>: astore_2							<span class="comment">// store s = abcmongodef47</span></span><br><span class="line">      33: getstatic     #10                 // Field System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">36</span>: aload_2</span><br><span class="line">      37: invokevirtual #11                 // PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使看不懂编译语句也不重要，我们需要注意的重点是：编译器自动引入了java.lang.StringBuilder类，虽然我们在源码中并没有使用StringBuilder类，但是编译器却自动使用了它，因为它更加高效。</p>
<p>现在也许你会觉得可以随意的使用String对象，反正编译器会自动优化性能，<strong>可是我们千万要记住一点，在循环的内部拼接字符串，并不会起到优化的效果。</strong></p>
<p>下面的程序采用两种方式生成String：方法一使用多个String对象；方法二中使用了StringBuilder。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WitherStringBuilder</span> </span>&#123;</span><br><span class="line">	<span class="comment">//方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">implicit</span><span class="params">(String[] fields)</span></span>&#123;</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            result += fields[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">explicit</span><span class="params">(String[] fields)</span></span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            result.append(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行javap -c WitherStringBuilder，可以看到两个方法对应的(简化过的)字节码，首先是implicit()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">implicit</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: ldc           #2                  // String</span><br><span class="line">     <span class="number">2</span>: astore_2</span><br><span class="line">     <span class="number">3</span>: iconst_0</span><br><span class="line">     <span class="number">4</span>: istore_3</span><br><span class="line">     <span class="number">5</span>: iload_3</span><br><span class="line">     <span class="number">6</span>: aload_1</span><br><span class="line">     <span class="number">7</span>: arraylength</span><br><span class="line">     <span class="number">8</span>: if_icmpge     <span class="number">38</span></span><br><span class="line">    11: new           #3                  // StringBuilder</span><br><span class="line">    <span class="number">14</span>: dup</span><br><span class="line">    15: invokespecial #4                  // StringBuilder."&lt;init&gt;":()</span><br><span class="line">    <span class="number">18</span>: aload_2</span><br><span class="line">    19: invokevirtual #5                  // StringBuilder.append:()</span><br><span class="line">    <span class="number">22</span>: aload_1</span><br><span class="line">    <span class="number">23</span>: iload_3</span><br><span class="line">    <span class="number">24</span>: aaload</span><br><span class="line">    25: invokevirtual #5                  //StringBuilder.append:()</span><br><span class="line">    28: invokevirtual #6                  // StringBuilder.toString:()</span><br><span class="line">    <span class="number">31</span>: astore_2</span><br><span class="line">    <span class="number">32</span>: iinc          <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">35</span>: goto          <span class="number">5</span></span><br><span class="line">    <span class="number">38</span>: aload_2</span><br><span class="line">    <span class="number">39</span>: areturn</span><br></pre></td></tr></table></figure>

<p>注意从第8行到第35行构成一个循环体。</p>
<p>第8行：对堆栈中的操作数进行 “大于或等于的整数比较运算”，循环结束时跳到第38行。</p>
<p>第35行：返回循环体的起始点(第5行)。</p>
<p>要注意的重点是：StringBuilder是在循环之内构造的，这意味着每经过循环一次，就会创建一个新的StringBuilder对象。这样的操作没有任何优化可言。</p>
<p>下面是explicit()方法对应的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> java.lang.<span class="function">String <span class="title">explicit</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">  Code:</span><br><span class="line">     0: new           #3                  // StringBuilder</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: invokespecial #4                  // StringBuilder."&lt;init&gt;":()</span><br><span class="line">     <span class="number">7</span>: astore_2</span><br><span class="line">     <span class="number">8</span>: iconst_0</span><br><span class="line">     <span class="number">9</span>: istore_3</span><br><span class="line">    <span class="number">10</span>: iload_3</span><br><span class="line">    <span class="number">11</span>: aload_1</span><br><span class="line">    <span class="number">12</span>: arraylength</span><br><span class="line">    <span class="number">13</span>: if_icmpge     <span class="number">30</span></span><br><span class="line">    <span class="number">16</span>: aload_2</span><br><span class="line">    <span class="number">17</span>: aload_1</span><br><span class="line">    <span class="number">18</span>: iload_3</span><br><span class="line">    <span class="number">19</span>: aaload</span><br><span class="line">    20: invokevirtual #5                  // StringBuilder.append:()</span><br><span class="line">    <span class="number">23</span>: pop</span><br><span class="line">    <span class="number">24</span>: iinc          <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">    <span class="number">27</span>: goto          <span class="number">10</span></span><br><span class="line">    <span class="number">30</span>: aload_2</span><br><span class="line">    31: invokevirtual #6                  // StringBuilder.toString:()</span><br><span class="line">    <span class="number">34</span>: areturn</span><br></pre></td></tr></table></figure>

<p>可以看到，不仅循环部分的代码更加简短，而且它只生成了一个StringBuilder对象。所以遇到循环内拼接字符串时在循环体的外部定义StringBuilder()可以大大提升程序的性能。当然，如果字符串操作简单的话，那么就可以信赖编译器的优化。</p>
<p>而且显示地创建StringBuilder还允许你预先为其指定大小。如果你已经知道最终的字符串大概多长，那预先指定StringBuilder的大小还可以避免多次重新分配缓冲。</p>
<hr>
<p>参考书籍：《Java编程思想(第4版)》</p>
<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/kissazi2/p/3648671.html" target="_blank" rel="noopener">https://www.cnblogs.com/kissazi2/p/3648671.html</a></p>
<p><a href="https://www.cnblogs.com/xudong-bupt/p/3961159.html" target="_blank" rel="noopener">https://www.cnblogs.com/xudong-bupt/p/3961159.html</a></p>
<p><a href="https://www.cnblogs.com/fangfuhai/p/5500065.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangfuhai/p/5500065.html</a></p>
<p><a href="https://www.cnblogs.com/jaylon/p/5721571.html" target="_blank" rel="noopener">https://www.cnblogs.com/jaylon/p/5721571.html</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/">&lt;&lt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/">&gt;&gt;</a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2020 By Tunan</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="#"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>